<configuration>
  <Category DisplayName="输入输出">
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.FileInput,ControlTactic,文件输入,输入输出">
      <BasicProperty>
        <Property name="ModuleName">FILEIN</Property>
        <Property name="ModuleColor">255,238,232,170</Property>
        <Property name="ModuleSort">文件输入</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[		
// 文件输入
uint8 FILEINControl(char *filename)
{
#ifdef CASS_MV_PC_VERSION
	FILE *source;
   	int  x,y,scanline;
	int width,height,fileSize,dwSize,current;
	static int flag=0;
	
	if(flag==1)
		return 1;
	else
	{
		memset(raw_data,0,360000);
		memset(out_data,0,360000);

		if((source=fopen((char *)filename,"rb+"))==NULL)
			{
				printf("can't open the source file!\n");
				return 0;
			}

		/*读取bmp文件头和信息头存到数组里*/
		fseek(source,0,SEEK_SET);
		fread(bmpinfoarray,sizeof(unsigned char),54,source);
		fseek(source,54,SEEK_SET);
		fread(plltee,sizeof(unsigned char),1024,source);

		fseek(source,2,0);
		fread(&fileSize,sizeof(long),1,source);//读取bmp数据区大小

		fseek(source,14,0);
		fread(&dwSize,sizeof(long),1,source);

			  //bmpinfo.width=bmpinfoarray[18]+bmpinfoarray[19]*255;
			  //bmpinfo.height=bmpinfoarray[22]+bmpinfoarray[23]*255;
			  //bmpinfo.fileSize=fileSize;
			  //bmpinfo.dwSize=dwSize;

			  width=bmpinfoarray[18]+bmpinfoarray[19]*256;
			  height=bmpinfoarray[22]+bmpinfoarray[23]*25;

			  if(width%4)//bmp宽度不为4要补0
				scanline=(width*8+31)/32*4;
			  else
				scanline=width;

		for(x=0;x<height;x++)//读取bmp进数组		
		{	
			for(y=0;y<scanline;y++)
			{
				current=14+dwSize+1024+x*scanline+y;
				fseek(source,current,0); 
				raw_data[(height-1-x)*scanline+y]=fgetc(source);
				//out_data[(height-1-x)*scanline+y]=fgetc(source);
			}	
		}		
		memcpy(out_data,raw_data,360000);
		fclose(source);
		flag=1;
	}
#else

#endif
	return 1;
}]]>
</Property>
        <Property name="Description">FILEIN

</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.FileOutput,ControlTactic,文件输出,输入输出">
      <BasicProperty>
        <Property name="ModuleName">FILEOUT</Property>
        <Property name="ModuleColor">255,238,232,170</Property>
        <Property name="ModuleSort">文件输出</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[			
// 输出
void FILEOUTControl(char *folderName)
{
#ifdef CASS_MV_PC_VERSION
        FILE *fp;
        char pass[4];
		if((fp=fopen("result.txt","a"))==NULL)
		{
			printf("can't open the source file!\n");
			return;
		}
        //itoa(cass_mv_match_percent,pass,10);
        fprintf(fp,"%s,",cass_mv_match_percent);
		itoa(cass_mv_match_result,pass,10);
        fprintf(fp,"%s\n",pass);   
	    fclose(fp);
#endif
}
]]>    
        </Property>
        <Property name="Description">FILEOUT</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.CameraIn,ControlTactic,设备输入,输入输出">
      <BasicProperty>
        <Property name="ModuleName">CAMERAIN</Property>
        <Property name="ModuleColor">255,238,232,170</Property>
        <Property name="ModuleSort">设备输入</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="设备号" varname="portName" type="COM" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">COM4</Property>
        <Property name="波特率" varname="baudRate" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">115200</Property>
        <Property name="数据位" varname="dataBits" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">8</Property>
		<Property name="停止位" varname="stopBits" type="System.String" visible="no" exp="" optype="" opvalue="" opnode="" relate="">ONESTOPBIT</Property>
        <Property name="奇偶校验" varname="parity" type="System.String" visible="no" exp="" optype="" opvalue="" opnode="" relate="">NOPARITY</Property>   
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">
<![CDATA[	
		// 设备输入
uint8 CAMERAINControl(CAMERAINStruct *CamIn)
{
#ifdef CASS_MV_PC_VERSION
    unsigned int length;
    int width = 0, height = 0;
    int ret;

    //模块参数传入
  //  ret = SeiralPortOpen(cass_mv_cameraIn_serialportname,cass_mv_cameraIn_serialBaudrate, cass_mv_cameraIn_serialStopbits,cass_mv_cameraIn_serialParity);
	ret = SeiralPortOpen(CamIn->portName,CamIn->baudRate, CamIn->stopBits,CamIn->parity);
    if(ret == -1)
    {      
        return ret;
    }

    raw_data[0] = 1;
    raw_data[1] = 32;
    raw_data[2] = 0;
    raw_data[3] = 1;
    raw_data[4] = 0;
    raw_data[5] = 1;
    raw_data[6] = 16;
    raw_data[7] = 13;
    length = 0;
    
    ret = write_scc(raw_data,8, &length);
    if(length == 8)
    {
        length = 0;
        ret = read_scc(out_data,360000,&length);
        if(length >6)
        {
                width= out_data[2] + out_data[3]*255;
                height = out_data[4] + out_data[5]*255;
                if(length == width * height + 6)
                	memcpy(raw_data, out_data+6, length-6);
		
        }
    }
    //printf("w:%d h:%d len:%d\n", width, height, length);
    SerialPortClose();
    //save as bmp;
    Save_File(CamIn->index, height, width);
    return ret;
#else

#endif
	return 1;
}
]]>
        </Property>
        <Property name="Description">CAMERAIN</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="滤波">
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.GaussianSmoothing,ControlTactic,高斯滤波,滤波">
      <BasicProperty>
        <Property name="ModuleName">GAUSSIANSMOOTHING</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">高斯滤波</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模板大小" varname="length" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">3</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
          // 高斯函数
          uint8 GAUSSIANSMOOTHINGControl(GAUSSIANSMOOTHINGStruct *GAUSSIANSMOOTHING)
          {
          #ifdef CASS_MV_PC_VERSION
          int x,y,scanline;
    int cur_value,thresh_value,sum;
    int width,height;
    int v[9];
        
	static int win[9] = { 1,2,1,2,4,2,1,2,1};
	
    width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)//bmp宽度不为4要补0
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

    for(y=0;y<cass_mv_border_height;y++)  
	{
		for (x=0;x<cass_mv_border_width;x++)
		{
			if(y==0||y==cass_mv_border_height-1)
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
			else if(x==0||x==cass_mv_border_width-1)
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
			else
			{
				v[0] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
				v[1] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
				v[2] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];
				v[3] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
				v[4] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
				v[5] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];
				v[6] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
				v[7] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
				v[8] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];


				sum = win[0]*v[0] + win[1]*v[1] + win[2]*v[2]
				+ win[3]*v[3] + win[4]*v[4] + win[5]*v[5]
				+ win[6]*v[6] + win[7]*v[7] + win[8]*v[8];

				sum = (int)(sum/16);
				if(sum>255)  
					sum=255;
				if(sum<0)    
					sum=0;
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=(unsigned char)sum;
			}		
		}
    }

	memcpy(raw_data,out_data,360000);
          Save_File(GAUSSIANSMOOTHING->index, height,width);
          #else
          u16 x=0,y=0,scanline=320;
	u16 cur_value=0;
	u8	value=0;
	u8  v[9];
	static u8 win[9] = {1,2,1,2,4,2,1,2,1};
	
	for(y=0;y<cass_mv_border_height;y++)  
		for (x=0;x<cass_mv_border_width;x++)
		{ 		
			v[0] = raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound-1];//有边缘隐患，如果是对全图或者边缘处理有危险。
			v[1] = raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound];
			v[2] = raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound+1];
			v[3] = raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-1];
			v[4] = raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
			v[5] = raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound+1];
			v[6] = raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound-1];
			v[7] = raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound];
			v[8] = raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound+1];
			
			cur_value = win[0]*v[0] + win[1]*v[1] + win[2]*v[2]
          + win[3]*v[3] + win[4]*v[4] + win[5]*v[5]
          + win[6]*v[6] + win[7]*v[7] + win[8]*v[8];
			value = (u8)(cur_value>>4);
			out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=value;
    }
	 
	memcpy(raw_data,out_data,240*scanline);//可以改为就复制选取区域的一部分，会更快
	
          #endif
          return 0;
          }
]]>
        </Property>
        <Property name="Description">高斯滤波/GAUSSIANSMOOTHING</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.MedianFilter,ControlTactic,中值滤波,滤波">
      <BasicProperty>
        <Property name="ModuleName">MEDIANFILTER</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
         <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">中值滤波</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模板大小" varname="length" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">3</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
          // 中值滤波函数
          uint8 MEDIANFILTERControl(MEDIANFILTERStruct *MEDIANFILTER)
          {
          #ifdef CASS_MV_PC_VERSION
          int x,y,scanline;
    int width,height;
    int v[9],jj,ii,k,min,m,n;
	unsigned char temp;

	width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)//bmp宽度不为4要补0
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

    for(y=0;y<cass_mv_border_height;y++)  
	{
		for (x=0;x<cass_mv_border_width;x++)
		{
			if(y==0||y==cass_mv_border_height-1)
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
			else if(x==0||x==cass_mv_border_width-1)
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
			else
			{
				 k = 0;  
				//unsigned char window[9];  
           
				for ( jj = y - 1; jj < y + 2; ++jj)  
					for ( ii = x - 1; ii < x + 2; ++ii)  
					{
						v[k++] = raw_data[(jj+cass_mv_border_topbound) * scanline + (ii+cass_mv_border_leftbound)];  
					}

				for ( m = 0; m < 5; ++m)  
				{  
					min = m;  
					for ( n = m + 1; n < 9; ++n) 
					{
						if (v[n] < v[min])  
							min = n;  
					}
					temp = v[m];  
					v[m] = v[min];  
					v[min] = temp;  
				}  
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)] = v[4];  
			}  
		}
    } 

	memcpy(raw_data,out_data,360000);
          Save_File(MEDIANFILTER->index, height,width);
          #else
		u16 x=0,y=0,scanline=320;
	u8  v[9],ii,jj,m,n,min,k,temp;
	
	for(y=0;y<cass_mv_border_height;y++)  
		for (x=0;x<cass_mv_border_width;x++)
		{
			if(y==cass_mv_border_topbound||y==cass_mv_border_topbound+cass_mv_border_height-1)
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
			else if(x==cass_mv_border_leftbound||x==cass_mv_border_leftbound+cass_mv_border_width-1)
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
			else
			{
				k=0;
				for (jj=y-1;jj < y+2; ++jj)
					for ( ii=x-1;ii < x+2; ++ii)
					{
						v[k++] = raw_data[(jj+cass_mv_border_topbound) * scanline +cass_mv_border_leftbound + ii];
					}
				for ( m = 0; m < 5; ++m)
				{
					  min = m;
					  for ( n = m + 1; n < 9; ++n)
					  {
							if (v[n] < v[min])
							min = n;
					  }
					  temp = v[m];
					  v[m] = v[min];
					  v[min] = temp;
				}  
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound] = v[4];
			}				
		}	
	memcpy(raw_data,out_data,240*scanline);//可以改为就复制选取区域的一部分，会更快
	#endif
          return 0;
          }
		  ]]></Property>
        <Property name="Description">中值滤波</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.MeanFilter,ControlTactic,均值滤波,滤波">
      <BasicProperty>
        <Property name="ModuleName">MEANFILTER</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">均值滤波</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模板大小" varname="length" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">3</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">
	<![CDATA[
          // 均值滤波函数
          uint8 MEANFILTERControl(MEANFILTERStruct *MEANFILTER)
          {
          #ifdef CASS_MV_PC_VERSION
          int x,y,sum;
    int width,height,scanline;
    int v[9];

	width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)//bmp宽度不为4要补0
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

    for(y=0;y<cass_mv_border_height;y++)  
	{
		for (x=0;x<cass_mv_border_width;x++)
		{
			if(y==0||y==cass_mv_border_height-1)
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
			else if(x==0||x==cass_mv_border_width-1)
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
			else
			{
				v[0] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
				v[1] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
				v[2] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];
				v[3] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
				v[4] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
				v[5] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];
				v[6] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
				v[7] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
				v[8] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];

				sum = v[0] + v[1] + v[2]+ v[3] + v[4] + v[5]+ v[6] + v[7] + v[8];
				sum = (int)(sum/9);

				if(sum>255)  
					sum=255;
				if(sum<0)    
					sum=0;
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=(unsigned char)sum;
			}
			
		}
    }

	memcpy(raw_data,out_data,360000);
          Save_File(MEANFILTER->index, height,width);
          #else
		  u16 x=0,y=0,scanline=320;
	u8  v[9],ii,jj,m,n,min,k,temp;
	
	for(y=0;y<cass_mv_border_height;y++)  
		for (x=0;x<cass_mv_border_width;x++)
		{
			if(y==cass_mv_border_topbound||y==cass_mv_border_topbound+cass_mv_border_height-1)
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
			else if(x==cass_mv_border_leftbound||x==cass_mv_border_leftbound+cass_mv_border_width-1)
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
			else
			{
				k=0;
				for (jj=y-1;jj < y+2; ++jj)
					for ( ii=x-1;ii < x+2; ++ii)
					{
						v[k++] = raw_data[(jj+cass_mv_border_topbound) * scanline +cass_mv_border_leftbound + ii];
					}
				for ( m = 0; m < 5; ++m)
				{
					  min = m;
					  for ( n = m + 1; n < 9; ++n)
					  {
							if (v[n] < v[min])
							min = n;
					  }
					  temp = v[m];
					  v[m] = v[min];
					  v[min] = temp;
				}  
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound] = v[4];
			}				
		}
		
	memcpy(raw_data,out_data,240*scanline);//可以改为就复制选取区域的一部分，会更快
	
          #endif
          return 0;
          }
		  ]]></Property>
        <Property name="Description">均值滤波/MEDIANFILTER</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Sobel,ControlTactic,索贝尔处理,滤波">
      <BasicProperty>
        <Property name="ModuleName">SOBEL</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">索贝尔处理</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="梯度阈值" varname="threshold" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">128</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
          // 索贝尔函数
          uint8 SOBELControl(SOBELStruct  *SOBEL)
          {
          #ifdef CASS_MV_PC_VERSION
          int x,y,scanline;
    int cur_value,thresh_value,sumx,sumy,sum;
    int width,height;
    int v[9];
        
	static int winy[9] = { -1,-2,-1,0,0,0,1,2,1};
	static int winx[9] = { -1,0,1,-2,0,2,-1,0,1};
    width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)//bmp宽度不为4要补0
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

    for(y=0;y<cass_mv_border_height;y++)  
	{
		for (x=0;x<cass_mv_border_width;x++)
		{
			if(y==0||y==cass_mv_border_height-1)
				sum=0;
			else if(x==0||x==cass_mv_border_width-1)
				sum=0;
			else
			{
				v[0] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
				v[1] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
				v[2] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];
				v[3] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
				v[4] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
				v[5] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];
				v[6] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
				v[7] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
				v[8] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];

				sumx = winx[0]*v[0] + winx[1]*v[1] + winx[2]*v[2]
				+ winx[3]*v[3] + winx[4]*v[4] + winx[5]*v[5]
				+ winx[6]*v[6] + winx[7]*v[7] + winx[8]*v[8];

				sumx = (int)(sumx/16);
				if(sumx>255)  
					sumx=255;
				if(sumx<0)    
					sumx=0;

				sumy = winy[0]*v[0] + winy[1]*v[1] + winy[2]*v[2]
				+ winy[3]*v[3] + winy[4]*v[4] + winy[5]*v[5]
				+ winy[6]*v[6] + winy[7]*v[7] + winy[8]*v[8];
				sumy = (int)(sumy/16);
				if(sumy>255)  
					sumx=255;
				if(sumy<0)    
					sumx=0;

				//sum=abs(sumx)+abs(sumy);
				sum=(int)sqrt((float)(sumx*sumx+sumy*sumy));				
			}	
			//out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=255-(unsigned char)sum;
			if(sum>SOBEL->threshold)
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=255;
			else
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=0;
		}
    }
	memcpy(raw_data,out_data,360000);
    Save_File(SOBEL->index, height,width);
#else
          int x,y,scanline=320;
	int sumx,sumy,sum;
	u8 v[9];    
	static int winy[9] = { -1,-2,-1,0,0,0,1,2,1};
	static int winx[9] = { -1,0,1,-2,0,2,-1,0,1};

	for (y=0;y<cass_mv_border_height;y++)
	{
		for (x=0;x<cass_mv_border_width;x++)
		{
			sumx=0;
			sumy=0;
			if(y==0||y==cass_mv_border_height-1)
				sum=0;
			else if(x==0||x==cass_mv_border_width-1)
				sum=0;
			else
			{
				v[0] = raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound-1];
				v[1] = raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound];
				v[2] = raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound+1];
				v[3] = raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-1];
				v[4] = raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
				v[5] = raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound+1];
				v[6] = raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound-1];
				v[7] = raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound];
				v[8] = raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound+1];

				sumx = winx[0]*v[0] + winx[1]*v[1] + winx[2]*v[2]
					   + winx[3]*v[3] + winx[4]*v[4] + winx[5]*v[5]
					   + winx[6]*v[6] + winx[7]*v[7] + winx[8]*v[8];

				sumx = (int)(sumx/16);
				if(sumx>255)  
					sumx=255;
				if(sumx<0)    
					sumx=0;

				sumy = winy[0]*v[0] + winy[1]*v[1] + winy[2]*v[2]
					   + winy[3]*v[3] + winy[4]*v[4] + winy[5]*v[5]
					   + winy[6]*v[6] + winy[7]*v[7] + winy[8]*v[8];
				sumy = (int)(sumy/16);
				if(sumy>255)  
					sumx=255;
				if(sumy<0)    
					sumx=0;
				
				sum=(int)sqrt((float)(sumx*sumx+sumy*sumy));				
			}	
			//out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=255-(u8)sum;
			if(sum>SOBEL->threshold)
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=255;
			else
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=0;
		}
  }
	memcpy(raw_data,out_data,scanline*240);
          
          #endif
          return 0;
          }
    ]]>    </Property>
        <Property name="Description">索贝尔处理</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Prewitt,ControlTactic,普锐维特处理,滤波">
      <BasicProperty>
        <Property name="ModuleName">PREWITT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">普锐维特处理</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="梯度阈值" varname="threshold" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">128</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
          // 普锐维特函数
          uint8 PREWITTControl(PREWITTStruct  *PREWITT)
          {
          #ifdef CASS_MV_PC_VERSION
          int x,y,scanline;
    int cur_value,thresh_value,sumx,sumy,sum;
    int width,height;
    int v[9];
        
	static int winy[9] = { -1,0,1,-1,0,1,-1,0,1};
	static int winx[9] = { -1,-1,1,0,0,0,1,1,1};
    width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)//bmp宽度不为4要补0
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

    for(y=0;y<cass_mv_border_height;y++)  
	{
		for (x=0;x<cass_mv_border_width;x++)
		{
			if(y==0||y==cass_mv_border_height-1)
				sum=0;
			else if(x==0||x==cass_mv_border_width-1)
				sum=0;
			else
			{
				v[0] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
				v[1] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
				v[2] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];
				v[3] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
				v[4] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
				v[5] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];
				v[6] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
				v[7] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
				v[8] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];

				sumx = winx[0]*v[0] + winx[1]*v[1] + winx[2]*v[2]
				+ winx[3]*v[3] + winx[4]*v[4] + winx[5]*v[5]
				+ winx[6]*v[6] + winx[7]*v[7] + winx[8]*v[8];

				sumx = (int)(sumx/16);
				if(sumx>255)  
					sumx=255;
				if(sumx<0)    
					sumx=0;

				sumy = winy[0]*v[0] + winy[1]*v[1] + winy[2]*v[2]
				+ winy[3]*v[3] + winy[4]*v[4] + winy[5]*v[5]
				+ winy[6]*v[6] + winy[7]*v[7] + winy[8]*v[8];
				sumy = (int)(sumy/16);
				if(sumy>255)  
					sumx=255;
				if(sumy<0)    
					sumx=0;

				//sum=abs(sumx)+abs(sumy);
				sum=(int)sqrt((float)(sumx*sumx+sumy*sumy));
			}
			if(sum>PREWITT->threshold)
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)] = 255;
			else
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)] = 0;
			//out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=255-(unsigned char)sum;
		}
    }
	memcpy(raw_data,out_data,360000);
          Save_File(PREWITT->index, height,width);
          #else
          int x,y,scanline=320;
	int sumx,sumy,sum;
	u8 v[9];
        
	static int winy[9] = { -1,0,1,-1,0,1,-1,0,1};
	static int winx[9] = { -1,-1,1,0,0,0,1,1,1};

	for (y=0;y<cass_mv_border_height;y++)
	{
		for (x=0;x<cass_mv_border_width;x++)
		{
			sumx=0;
			sumy=0;
			if(y==0||y==cass_mv_border_height-1)
				sum=0;
			else if(x==0||x==cass_mv_border_width-1)
				sum=0;
			else
			{
				v[0] = raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound-1];
				v[1] = raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound];
				v[2] = raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound+1];
				v[3] = raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-1];
				v[4] = raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
				v[5] = raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound+1];
				v[6] = raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound-1];
				v[7] = raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound];
				v[8] = raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound+1];

				sumx = winx[0]*v[0] + winx[1]*v[1] + winx[2]*v[2]
				+ winx[3]*v[3] + winx[4]*v[4] + winx[5]*v[5]
				+ winx[6]*v[6] + winx[7]*v[7] + winx[8]*v[8];

				sumx = (int)(sumx/16);
				if(sumx>255)  
					sumx=255;
				if(sumx<0)    
					sumx=0;

				sumy = winy[0]*v[0] + winy[1]*v[1] + winy[2]*v[2]
				+ winy[3]*v[3] + winy[4]*v[4] + winy[5]*v[5]
				+ winy[6]*v[6] + winy[7]*v[7] + winy[8]*v[8];
				sumy = (int)(sumy/16);
				if(sumy>255)  
					sumx=255;
				if(sumy<0)    
					sumx=0;
				
				sum=(int)sqrt((float)(sumx*sumx+sumy*sumy));				
			}	
			//out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=255-(u8)sum;
			if(sum>PREWITT->threshold)
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=255;
			else
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=0;
		}
	}
	
	memcpy(raw_data,out_data,scanline*240);
          #endif
          return 0;
          }
      ]]>  </Property>
        <Property name="Description">普锐维特处理</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Laplace,ControlTactic,拉普拉斯处理,滤波">
      <BasicProperty>
        <Property name="ModuleName">LAPLACE</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">拉普拉斯处理</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
          // laplace函数
          uint8 LAPLACEControl(LAPLACEStruct *LAPLACE)
          {
          #ifdef CASS_MV_PC_VERSION
          int x,y,scanline;
    int cur_value,thresh_value,sum;
    int width,height;
    int v[9];
        
	static int win[9] = {0,1,0,1,-4,1,0,1,0};
    
	width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)//bmp宽度不为4要补0
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

    for(y=0;y<cass_mv_border_height;y++)  
	{
		for (x=0;x<cass_mv_border_width;x++)
		{
			if(y==0||y==cass_mv_border_height-1)
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
			else if(x==0||x==cass_mv_border_width-1)
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
			else
			{
				v[0] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
				v[1] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
				v[2] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];
				v[3] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
				v[4] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
				v[5] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];
				v[6] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
				v[7] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
				v[8] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];


				sum = win[0]*v[0] + win[1]*v[1] + win[2]*v[2]
				+ win[3]*v[3] + win[4]*v[4] + win[5]*v[5]
				+ win[6]*v[6] + win[7]*v[7] + win[8]*v[8];

				sum = (int)(sum/16);
				if(sum>255)  
					sum=255;
				if(sum<0)    
					sum=0;
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=(unsigned char)sum;
			}		
		}
    }

	memcpy(raw_data,out_data,360000);
          Save_File(LAPLACE->index, height,width);
          #else
          u16 x=0,y=0,scanline=320;
	u16 cur_value=0;
	u8	value=0;
	u8  v[9];
	static int win[9] = {0,1,0,1,-4,1,0,1,0};
	
	for(y=0;y<cass_mv_border_height;y++)  
		for (x=0;x<cass_mv_border_width;x++)
		{ 		
			v[0] = raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound-1];//有边缘隐患，如果是对全图或者边缘处理有危险。
			v[1] = raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound];
			v[2] = raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound+1];
			v[3] = raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-1];
			v[4] = raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
			v[5] = raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound+1];
			v[6] = raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound-1];
			v[7] = raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound];
			v[8] = raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound+1];
			
			cur_value = win[0]*v[0] + win[1]*v[1] + win[2]*v[2]
						+ win[3]*v[3] + win[4]*v[4] + win[5]*v[5]
						+ win[6]*v[6] + win[7]*v[7] + win[8]*v[8];
			value = (u8)(cur_value>>4);
			out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=value;
		}
	 
	memcpy(raw_data,out_data,240*scanline);//可以改为就复制选取区域的一部分，会更快
          #endif
          return 0;
          }
        ]]></Property>
        <Property name="Description">指令名：拉普拉斯处理</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="匹配">
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Match,ControlTactic,工件识别,匹配">
      <BasicProperty>
        <Property name="ModuleName">WORKMATCH</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">工件识别</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="匹配率" varname="percent" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">50</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 识别处理函数
uint8 WORKMATCHControl(WORKMATCHStruct *MATCH)
{
#ifdef CASS_MV_PC_VERSION
	int tempx,tempy,tempvalue,tempdot,scanline;
	int sum=0,sumvalue=0,x=0,count=0;
	int space_count=0;//待识别区域个数
	int small_leftbound=0,small_rightbound=0,small_topbound=0,small_downbound=0;//待检测区域内的框住数字最小框
	int j;
	
	int width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    int height=bmpinfoarray[22]+bmpinfoarray[23]*256;
	
	if(width%4)
		scanline=(width*8+31)/32*4;
    else
		scanline=width;
		
	for(j=0;j<30;j++)
	{
		tempx=image_data_packet_desc.space[0].point[j].x;
		tempy=image_data_packet_desc.space[0].point[j].y;
		tempdot=image_data_packet_desc.space[0].point[j].v;
		tempvalue=abs(image_data_packet_desc.space[0].point[j].w);
		
		if(tempvalue<0)
			tempvalue=-tempvalue;
		
		sum+=tempvalue;
		if((image_data_packet_desc.space[0].point[j].w)!=0)//不是空点
			if(raw_data[tempy*scanline+tempx]==tempdot)
				sumvalue+=tempvalue;
	}	

	cass_mv_match_percent ="BOOL";
	if(sum)
		cass_mv_match_result =( sumvalue * 100/sum);
	else
		cass_mv_match_result = 0;
#else
    uint16 tempx,tempy,tempdot;
	int16 tempvalue;
    uint16 sum=0,sumvalue=0,x=0;

	while(x<256&&(image_data_packet_desc.point[x].w != 0))
	{
		tempx=image_data_packet_desc.point[x].x;
		tempy=image_data_packet_desc.point[x].y;
		tempdot=image_data_packet_desc.point[x].v;
		tempvalue=image_data_packet_desc.point[x].w;
		if(tempvalue <0)
			tempvalue = - tempvalue;
		sum += tempvalue;

		if(raw_data[tempx*cass_mv_border_width+tempy]==tempdot)
		{
			sumvalue+=tempvalue;
		}
		x++;
	}
	
	if(sum)
		cass_mv_match_result =( sumvalue * 100/sum);			
	else
		cass_mv_match_result  = 0;
		
#endif
          return 1;
          }
		  ]]></Property>
        <Property name="Description">工件识别</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
	<FDToolBoxItem Type="ControlTactic.GraphicsControl.Match,ControlTactic,数字识别,匹配">
      <BasicProperty>
        <Property name="ModuleName">NUMMATCH</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">数字识别</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="匹配率" varname="percent" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">50</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 识别处理函数
uint8 NUMMATCHControl(NUMMATCHStruct *MATCH)
{
#ifdef CASS_MV_PC_VERSION
	int tempx,tempy,tempvalue,tempdot,scanline,temp;
	int sum=0,sumvalue=0,x=0,count=0;
	int space_count=0;//待识别区域个数
	int compare_sum[10]={0},correct_sum[10]={0};
	int small_leftbound=0,small_rightbound=0,small_topbound=0,small_downbound=0;//待检测区域内的框住数字最小框
	int temp_topbound,temp_leftbound;
	int i,j;
	
	int width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    int height=bmpinfoarray[22]+bmpinfoarray[23]*256;
	
	if(width%4)
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

	for(i=0;i<10;i++)
	{
		int temp_sum=0;
		for( j=0;j<30;j++)
		{
			temp=abs(image_data_packet_desc.space[0].point[i*30+j].w);
			if(temp!=100)//权值为100的点为模板中数字的左上，右下点，
				temp_sum+=temp;
		}
		correct_sum[i]=temp_sum;
	}
	
	for(i=cass_mv_border_leftbound;i<cass_mv_border_leftbound+cass_mv_border_width;i++)
	{	
		count=0;
		for(j=cass_mv_border_topbound;j<cass_mv_border_topbound+cass_mv_border_height;j++)
		{
			if(raw_data[j*scanline+i]==255)
				count++;
		}
		if(count>0)
		{
			small_leftbound=i;
			break;
		}
	}
	for(i=cass_mv_border_leftbound+cass_mv_border_width-1;i>=cass_mv_border_leftbound;i--)
	{
		count=0;
		for(j=cass_mv_border_topbound;j<cass_mv_border_topbound+cass_mv_border_height;j++)
		{
			if(raw_data[j*scanline+i]==255)
				count++;
		}
		if(count>0)
		{
			small_rightbound=i;//LCD下边
			break;
		}
	}
	for(j=cass_mv_border_topbound;j<cass_mv_border_topbound+cass_mv_border_height;j++)
	{
		count=0;
		for(i=cass_mv_border_leftbound;i<cass_mv_border_leftbound+cass_mv_border_width;i++)
		{
			
			if(raw_data[j*scanline+i]==255)
				count++;
		}
		if(count>0)
		{
			small_topbound=j;//LCD左边
			break;
		}
	}
	for(j=cass_mv_border_topbound+cass_mv_border_height-1;j>=cass_mv_border_topbound;j--)
	{
		count=0;
		for(i=cass_mv_border_leftbound;i<cass_mv_border_leftbound+cass_mv_border_width;i++)
		{
			if(raw_data[j*scanline+i]==255)
				count++;
		}
		if(count>0)
		{
			small_downbound=j;//LCD右边
			break;
		}
	}
	
	if(((small_rightbound-small_leftbound)/(small_downbound-small_topbound))>3)
		cass_mv_match_result=1;//最小框长宽比大于3，直接识别为数字1
	else
	{
		int small_temp_leftbound,small_temp_topbound;
	    int max=compare_sum[0];
		int maxnumber;
		for( i=0;i<10;i++)
		{
			int value_sum=0;
			/*模板内的数字最小框左上角*/
			if(image_data_packet_desc.space[0].point[i*30].w==100)//100是确保坐标是最小框左上角
			{
				small_temp_topbound=image_data_packet_desc.space[0].point[i*30].y;
				small_temp_leftbound=image_data_packet_desc.space[0].point[i*30].x;	 
			}

			if(i==1)
			{
				compare_sum[1]=0;
				continue;
			}

			for( j=1;j<30;j++)
			{
			
				tempx=image_data_packet_desc.space[0].point[i*30+j].x-small_temp_leftbound;//相对坐标：坐标系为模板中数字最小框
				tempy=image_data_packet_desc.space[0].point[i*30+j].y-small_temp_topbound;
				tempdot=image_data_packet_desc.space[0].point[i*30+j].v;
				tempvalue=abs(image_data_packet_desc.space[0].point[i*30+j].w);
				
				if((image_data_packet_desc.space[0].point[i*30+j].w)!=0)//不是空点
					if(raw_data[(small_topbound+tempy)*scanline+(small_leftbound+tempx)]==tempdot)//待识别区域中 数字最小框左上角 加上 特征点相对坐标
						value_sum+=tempvalue;
			}
			compare_sum[i]=value_sum;
		}

		for( i=0;i<10;i++)//算百分比
		{
			if(correct_sum[i])
				compare_sum[i]=compare_sum[i]*100/correct_sum[i];
			else
				getchar();
			
		}

		for( i=0;i<10;i++)
			if(max<=compare_sum[i])
			{
				max=compare_sum[i];
				maxnumber=i;
			}
		
		cass_mv_match_result=maxnumber;
		cass_mv_match_percent="UINT";
	}	
#else
    u16 tempx,tempy,tempvalue,tempdot,temp,i,j,scanline=320;
	u16 compare_sum[10]={0},correct_sum[10]={0};
	u16	max,maxnumber,count=0;
	u16 small_leftbound=0,small_rightbound=0,small_topbound=0,small_downbound=0;//待检测区域内的框住数字最小框
	u16 small_temp_leftbound,small_temp_topbound;//模板中的数字最小框左上角
	u16 temp_topbound,temp_leftbound;//待识别区域左上角
	
 	for(i=0;i<10;i++)
	{
		int temp_sum=0;
		for( j=0;j<30;j++)
		{
			temp=abs(image_data_packet_desc.space[0].point[i*30+j].w);
			if(temp!=100)//权值为100的点为模板中数字的左上，右下点，
				temp_sum+=temp;
		}
		correct_sum[i]=temp_sum;
	}

	/*待识别区域左上角*/
	temp_topbound=cass_mv_boarder_topbound;
	temp_leftbound=cass_mv_boarder_leftbound;

	/*找到待识别区域内读数最小框*/
	for(i=cass_mv_boarder_leftbound;i<cass_mv_boarder_leftbound+cass_mv_boarder_width;i++)
	{	
		count=0;
		for(j=cass_mv_boarder_topbound;j<cass_mv_boarder_topbound+cass_mv_boarder_height;j++)
		{
			if(out_data[j*scanline+i]==255)
				count++;
		}
		if(count>0)
		{
			small_leftbound=i;
			break;
		}
	}
	for(i=cass_mv_boarder_leftbound+cass_mv_boarder_width-1;i>=cass_mv_boarder_leftbound;i--)
	{
		count=0;
		for(j=cass_mv_boarder_topbound;j<cass_mv_boarder_topbound+cass_mv_boarder_height;j++)
		{
			if(out_data[j*scanline+i]==255)
				count++;
		}
		if(count>0)
		{
			small_rightbound=i;//LCD下边
			break;
		}
	}
	for(j=cass_mv_boarder_topbound;j<cass_mv_boarder_topbound+cass_mv_boarder_height;j++)
	{
		count=0;
		for(i=cass_mv_boarder_leftbound;i<cass_mv_boarder_leftbound+cass_mv_boarder_width;i++)
		{
			
			if(out_data[j*scanline+i]==255)
				count++;
		}
		if(count>0)
		{
			small_topbound=j;//LCD左边
			break;
		}
	}
	for(j=cass_mv_boarder_topbound+cass_mv_boarder_height-1;j>=cass_mv_boarder_topbound;j--)
	{
		count=0;
		for(i=cass_mv_boarder_leftbound;i<cass_mv_boarder_leftbound+cass_mv_boarder_width;i++)
		{
			if(out_data[j*scanline+i]==255)
				count++;
		}
		if(count>0)
		{
			small_downbound=j;//LCD右边
			break;
		}
	}

	if(((small_rightbound-small_leftbound)/(small_downbound-small_topbound))>3)
		return 1;//最小框长宽比大于3，直接识别为数字1
	else
	{
		for(i=0;i<10;i++)
		{
			int value_sum=0;
			/*模板内的数字最小框左上角*/
			if(image_data_packet_desc.space[0].point[i*30].w==100)//100是确保坐标是最小框左上角
			{
				small_temp_topbound=image_data_packet_desc.space[0].point[i*30].y;
				small_temp_leftbound=image_data_packet_desc.space[0].point[i*30].x;	 
			}

			if(i==1)
			{
				compare_sum[1]=0;
				continue;
			}

			for(j=1;j<30;j++)
			{
				tempx=image_data_packet_desc.space[0].point[i*30+j].x-small_temp_leftbound;//相对坐标：坐标系为模板中数字最小框
				tempy=image_data_packet_desc.space[0].point[i*30+j].y-small_temp_topbound;
				tempdot=image_data_packet_desc.space[0].point[i*30+j].v;
				tempvalue=abs(image_data_packet_desc.space[0].point[i*30+j].w);
				
				if((image_data_packet_desc.space[0].point[i*30+j].w)!=0)//不是空点
					if(out_data[(small_topbound+tempy)*scanline+(small_leftbound+tempx)]==tempdot)//待识别区域中 数字最小框左上角 加上 特征点相对坐标
						value_sum+=tempvalue;
			}
			compare_sum[i]=value_sum;
		}

		for(i=0;i<10;i++)//算百分比
		{
			if(correct_sum[i])
				compare_sum[i]=compare_sum[i]*100/correct_sum[i];
		}
		
		/*找和第x模板最近似*/
		max=compare_sum[0];
		maxnumber=0;
		for(i=0;i<10;i++)
		{
			if(max<=compare_sum[i])
			{
				max=compare_sum[i];
				maxnumber=i;
			}
		}

		return maxnumber;
	
#endif
          return 1;
          }
		  ]]></Property>
        <Property name="Description">数字识别</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="色彩">
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Binary,ControlTactic,二值化,色彩">
      <BasicProperty>
        <Property name="ModuleName">BINARY</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">二值化</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="阈值" varname="threshold" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">128</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
uint8 BINARYControl(BINARYStruct *BINARY)
{
#ifdef CASS_MV_PC_VERSION
	int x,y,scanline,width,height;

	width=bmpinfoarray[18]+bmpinfoarray[19]*256;
	height=bmpinfoarray[22]+bmpinfoarray[23]*256;
	
	if(width%4)//bmp宽度不为4要补0
		scanline=(width*8+31)/32*4;
	else
		scanline=width;

	for(y=0;y<cass_mv_border_height;y++)  
	{
		for (x=0;x<cass_mv_border_width;x++)
		{ 		
			if(raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]<70)
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=0;
			else
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=255;
        }
	} 

	 memcpy(raw_data,out_data,360000);

	memcpy(raw_data,out_data,360000);
	Save_File(BINARY->index,height,width);	
#else
   u16 x=0,y=0,scanline=320;
	
	for(y=0;y<cass_mv_border_height;y++)  
		for (x=0;x<cass_mv_border_width;x++)	
		{
			if(raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]<BINARY->threshold)
				raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=0;	
			else
				raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=255;				
		}
	
#endif
	return 0;
}
  ]]>    </Property>
        <Property name="Description">二值化</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.OstuBinary,ControlTactic,最优二值化,色彩">
      <BasicProperty>
        <Property name="ModuleName">OSTUBINARY</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">最优二值化</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
          // 最优二值化函数
          uint8 OSTUBINARYControl(OSTUBINARYStruct *OSTUBINARY)
          {
          #ifdef CASS_MV_PC_VERSION	  
			int x,y,i,j;
			int height,width,scanline,thresh_value;
			double piexlsum,greyscale;
			float piexlcount[255];
			float piexlpercent[255];
			float w0,w1,u0tmp,u1tmp,u0,u1,u,deltaTmp,deltaMax;
			unsigned char *tempspace=NULL;

			thresh_value=0;
			greyscale=255;
			deltaMax=0;
		   
			width=bmpinfoarray[18]+bmpinfoarray[19]*256;
			height=bmpinfoarray[22]+bmpinfoarray[23]*256;

		   piexlsum=cass_mv_border_width*cass_mv_border_height;//总像素

		   memset(piexlcount,0,sizeof(piexlcount));
		   memset(piexlpercent,0,sizeof(piexlpercent));
			
		   if(width%4)
				scanline=(width*8+31)/32*4;
			else
				scanline=width;

		   for (y=0;y<cass_mv_border_height;y++)  
			  for (x=0;x<cass_mv_border_width;x++)
			  { 
				piexlcount[(int)raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]]++;//每级灰度的像素个数
			  }
			  
		   for(i=0;i<greyscale;i++)
		   {
			  piexlpercent[i]=(float)piexlcount[i]/piexlsum;//每级灰度的像素占总像素数比率
		   }
		   
		   for(i=0;i<greyscale;i++)//阈值扫描
		   {
			 w0=w1=u0tmp=u1tmp=u0=u1=u=deltaTmp=0;
			 for(j=0;j<greyscale;j++)
			 {
			  if(j<i)
			  {
				w0+=piexlpercent[j];//前景像素占总像素比率
				u0tmp+=j*piexlpercent[j];//前景像素灰度平均值
			  }
			  else
			  {
				w1+=piexlpercent[j];//背景像素占总像素比率
				u1tmp+=j*piexlpercent[j];//背景像素灰度平均值
			  }
			 }
			 u0=u0tmp/w0;//前景像素灰度平均值
			 u1=u1tmp/w1;//背景像素灰度平均值
			 u=u0tmp+u1tmp;//所有像素灰度平均值
			 deltaTmp=w0*pow((u0-u),2)+w1*pow((u1-u),2);//前景背景差距=w0(u0-u)^2+w1(u1-u)^2
			 if(deltaTmp>deltaMax)//最大的deltaMax时，前景背景差异最大
			 {
			   deltaMax=deltaTmp;
			   thresh_value=i;
			 }   
		   }  
		   
		   for (y=0;y<cass_mv_border_height;y++)  
			{
				for (x=0;x<cass_mv_border_width;x++)
				{ 		
					if(raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]<thresh_value)
						out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=0;
					else
						out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=255;
				}
			} 

			memcpy(raw_data,out_data,360000);
			Save_File(OSTUBINARY->index,height,width);
#else
	u8 x,y,i,j;
	u16 scanline,thresh_value;
   double piexlsum,greyscale;
   float piexlcount[255];
   float piexlpercent[255];
   float w0,w1,u0tmp,u1tmp,u0,u1,u,deltaTmp,deltaMax;

   thresh_value=0;
   greyscale=255;
   deltaMax=0;
   
   scanline=320;
   //height=240;

   piexlsum=cass_mv_border_width*cass_mv_border_height;//总像素

   memset(piexlcount,0,sizeof(piexlcount));
   memset(piexlpercent,0,sizeof(piexlpercent));

   for (y=0;y<cass_mv_border_height;y++)  
      for (x=0;x<cass_mv_border_width;x++)
	  { 
			piexlcount[(int)raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]]++;//每级灰度的像素个数
      }
      
   for(i=0;i<greyscale;i++)
   {
      piexlpercent[i]=(float)piexlcount[i]/piexlsum;//每级灰度的像素占总像素数比率
   }
   
   for(i=0;i<greyscale;i++)//阈值扫描
   {
     w0=w1=u0tmp=u1tmp=u0=u1=u=deltaTmp=0;
     for(j=0;j<greyscale;j++)
     {
      if(j<i)
      {
        w0+=piexlpercent[j];//前景像素占总像素比率
        u0tmp+=j*piexlpercent[j];//前景像素灰度平均值
      }
      else
      {
        w1+=piexlpercent[j];//背景像素占总像素比率
        u1tmp+=j*piexlpercent[j];//背景像素灰度平均值
      }
     }
     u0=u0tmp/w0;//前景像素灰度平均值
     u1=u1tmp/w1;//背景像素灰度平均值
     u=u0tmp+u1tmp;//所有像素灰度平均值
     deltaTmp=w0*pow((u0-u),2)+w1*pow((u1-u),2);//前景背景差距=w0(u0-u)^2+w1(u1-u)^2
     if(deltaTmp>deltaMax)//最大的deltaMax时，前景背景差异最大
     {
       deltaMax=deltaTmp;
       thresh_value=i;
     }   
   }  
   
   for (y=0;y<cass_mv_border_height;y++)  
	{
		for (x=0;x<cass_mv_border_width;x++)
		{ 		
			if(raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]<thresh_value)
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=0;
			else
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=255;
    }
	} 

	memcpy(raw_data,out_data,240*scanline);//可以改为就复制选取区域的一部分，会更快
          #endif
          return 0;
          }
		  ]]></Property>
        <Property name="Description">大津法最优二值化</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.AntiColor,ControlTactic,反转颜色,色彩">
      <BasicProperty>
        <Property name="ModuleName">ANTICOLOR</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">反转颜色</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 反转颜色函数
uint8 ANTICOLORControl(ANTICOLORStruct *ANTICOLOR)
{
#ifdef CASS_MV_PC_VERSION
	int x,y,sum;
    int width,height,scanline;

	width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

	for(y=0;y<cass_mv_border_height;y++)  
	{
		for (x=0;x<cass_mv_border_width;x++)
		{
			out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=255-raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
		}
	 }
	memcpy(raw_data,out_data,360000);
    Save_File(ANTICOLOR->index,height,width);
    #else
	u16 x=0,y=0,scanline=320;
	
	for(y=0;y<cass_mv_border_height;y++)  
		for (x=0;x<cass_mv_border_width;x++)	
		{
			out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=255-raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
		}

	memcpy(raw_data,out_data,240*scanline);//可以改为就复制选取区域的一部分，会更快
    #endif
    return 0;
}
       ]]> </Property>
        <Property name="Description">反转颜色</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.GrayScaleStretch,ControlTactic,灰度拉伸,色彩">
      <BasicProperty>
        <Property name="ModuleName">GRAYSCALESTRETCH</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">灰度拉伸</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="原灰度范围下界" varname="left_gray_in" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">50</Property>
        <Property name="原灰度范围上界" varname="left_gray_out" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="目的灰度范围下界" varname="right_gray_in" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">20</Property>
        <Property name="目的灰度范围上界" varname="right_gray_out" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">200</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		//灰度拉伸函数
uint8 GRAYSCALESTRETCHControl(GRAYSCALESTRETCHStruct*GRAYSCALESTRETCH)
{
#ifdef CASS_MV_PC_VERSION
	int x,y,sum;
    int width,height,scanline;
	unsigned char map[256]={0};
	double dTemp;
	float cass_mv_left_gray_in=50,cass_mv_right_gray_in=100,cass_mv_left_gray_out=20,cass_mv_right_gray_out=200;

	width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)//bmp宽度不为4要补0
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

	for(x=0;x<256;x++)
	{
		// 如果在第一条直线上
		if ( x < cass_mv_left_gray_in)
		{
			if ( fabs(cass_mv_left_gray_in - 0) > 0.0001 )
				dTemp = (float)cass_mv_left_gray_out / (float)cass_mv_left_gray_in * x;
			else
				dTemp = 0;
		}
		// 如果在第二条直线上
		else if ( x <= cass_mv_right_gray_in )
		{
			if ( fabs(cass_mv_right_gray_in - cass_mv_left_gray_in) > 0.0001 )
				dTemp = (float)(cass_mv_right_gray_out - cass_mv_left_gray_out) / (float)(cass_mv_right_gray_in - cass_mv_left_gray_in) * (x - cass_mv_left_gray_in) + cass_mv_left_gray_out;
			else
				dTemp = x;
		}
		// 如果在第三条直线上
		else
		{
			if ( fabs(cass_mv_right_gray_out - 255) > 0.0001 )
				dTemp = (float)(255 - cass_mv_right_gray_out) / (float)(255 - cass_mv_right_gray_in) * (x - cass_mv_right_gray_in) + cass_mv_right_gray_out;
			else
				dTemp = 255;
		}

		// 四舍五入
		map[x] = (int)(dTemp + 0.5);
        //  map[x] = (int)dTemp;
	}

	for (y=0;y<cass_mv_border_height;y++)  
	{
		for (x=0;x<cass_mv_border_width;x++)
		{
			out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=map[raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]];
		}
	}

	memcpy(raw_data,out_data,360000);
    Save_File(GRAYSCALESTRETCH->index, height,width);
#else
	int x,y,sum,scanline=320;
	u8 map[256]={0};
	double dTemp;

	for(x=0;x<256;x++)
	{
		// 如果在第一条直线上
		if ( x < GRAYSCALESTRETCH->left_gray_in)
		{
			if ( fabs(GRAYSCALESTRETCH->left_gray_in - 0) > 0.0001 )
				dTemp = (float)GRAYSCALESTRETCH->left_gray_out / (float)GRAYSCALESTRETCH->left_gray_in * x;
			else
				dTemp = 0;
		}
		// 如果在第二条直线上
		else if ( x <= GRAYSCALESTRETCH->right_gray_in )
		{
			if ( fabs(GRAYSCALESTRETCH->right_gray_in - GRAYSCALESTRETCH->left_gray_in) > 0.0001 )
				dTemp = (float)(GRAYSCALESTRETCH->right_gray_out - GRAYSCALESTRETCH->left_gray_out) / (float)(GRAYSCALESTRETCH->right_gray_in - GRAYSCALESTRETCH->left_gray_in) * (x - GRAYSCALESTRETCH->left_gray_in) + GRAYSCALESTRETCH->left_gray_out;
			else
				dTemp = x;
		}
		// 如果在第三条直线上
		else
		{
			if ( fabs(GRAYSCALESTRETCH->right_gray_out - 255) > 0.0001 )
				dTemp = (float)(255 - GRAYSCALESTRETCH->right_gray_out) / (float)(255 - GRAYSCALESTRETCH->right_gray_in) * (x - GRAYSCALESTRETCH->right_gray_in) + GRAYSCALESTRETCH->right_gray_out;
			else
				dTemp = 255;
		}

		// 四舍五入
		map[x] = (int)(dTemp + 0.5);
	}

	for(y=0;y<cass_mv_border_height;y++)
		for(x=0;x<cass_mv_border_width;x++)
		{
			out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=map[raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]];
		}
	
	memcpy(raw_data,out_data,240*scanline);//可以改为就复制选取区域的一部分，会更快
#endif
    return 0;
          }
       ]]> </Property>
        <Property name="Description">GRAYSCALESTRETCH</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.HiagramEqualization,ControlTactic,直方图均衡化,色彩">
      <BasicProperty>
        <Property name="ModuleName">HIAGRAM</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">直方图均衡化</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
          // 直方图均衡化函数
          uint8 HIAGRAMControl(HIAGRAMStruct *HIAGRAM)
          {
          #ifdef CASS_MV_PC_VERSION
         int x,y,scanline;
	int width,height,max,min;
	float p[256]={0},c[256]={0},count=0;
	int n[256]={0};

	width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)//bmp宽度不为4要补0
		scanline=(width*8+31)/32*4;
    else
		scanline=width;
	
	for (y=0;y<cass_mv_border_height;y++)  
	{
		for (x=0;x<cass_mv_border_width;x++)
		{
			n[raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]]++;
			count++;
		}
	}
    for(x=0;x<256;x++)
	{
        p[x]=(float)n[x]/(float)(cass_mv_border_height*cass_mv_border_width);
    }

	for(x=0;x<256;x++)
	{
       for(y=0;y<=x;y++)
	   {
          c[x]+=p[y];
       }
    }

	max=min=raw_data[y+cass_mv_border_topbound*scanline+cass_mv_border_leftbound];
    for (y=0;y<cass_mv_border_height;y++)  
	{
		for (x=0;x<cass_mv_border_width;x++)
		{
           if(max<raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)])
		   {
               max=raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
           }
		   else if(min>raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)])
		   {
               min=raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
           }
       }
    }

	for (y=0;y<cass_mv_border_height;y++)  
	{
		for (x=0;x<cass_mv_border_width;x++)
	   {
		  out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=c[raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]]*(max-min)+min;
	   }
	}

	memcpy(raw_data,out_data,360000);
          Save_File(HIAGRAM->index,height,width);
          #else
		u16 x=0,y=0,scanline=320;
	u16 max,min;
	float p[256]={0},c[256]={0},count=0;
	int n[256]={0};
	
	for(y=0;y<cass_mv_border_height;y++)  
		for (x=0;x<cass_mv_border_width;x++)	
		{
			n[raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]]++;
			count++;
		}
	
    for(x=0;x<256;x++)
	        p[x]=(float)n[x]/(float)(cass_mv_border_width*cass_mv_border_height);


	for(x=0;x<256;x++)
     for(y=0;y<=x;y++)
	{
          c[x]+=p[y];
    }

	max=min=raw_data[cass_mv_border_topbound*scanline+cass_mv_border_leftbound];
	for(y=0;y<cass_mv_border_height;y++)
	{
     for(x=0;x<cass_mv_border_width;x++)
	   {
		   if(max<raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound])
			{
			   max=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
			}
			else if(min>raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound])
			{
			  min=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
			}
	 }
   }

	for(y=0;y<cass_mv_border_height;y++)
		for(x=0;x<cass_mv_border_width;x++)
		{
		  out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=c[raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]]*(max-min)+min;
		}
		
	memcpy(raw_data,out_data,240*scanline);//可以改为就复制选取区域的一部分，会更快
          #endif
          return 0;
          }
        ]]></Property>
        <Property name="Description">HiagramEqualization</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="形态学">
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Denoising,ControlTactic,去噪,形态学">
      <BasicProperty>
        <Property name="ModuleName">DENOSING</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">去噪</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="去噪大小" varname="noise_size" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">1</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 去噪函数
uint8 DENOSINGControl(DENOSINGStruct *DENOSING)
{
#ifdef CASS_MV_PC_VERSION
	int x,y,sum,m,n;
    int width,height,scanline;
	int v[9];

	width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

	for(y=0;y<cass_mv_border_height;y++)  
	{
		for (x=0;x<cass_mv_border_width;x++)
		{
			if(y==0||y==cass_mv_border_height-1)
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
			else if(x==0||x==cass_mv_border_width-1)
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
			else
			{
				if(raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]==0)
				{
					for( m = y-1; m<y+2; m++)
					{
						for( n = x-1;n<x+2; n++ )
						{
							if( raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]==0)
							{  
							   sum++;
							}
						}
					}                             //sum记录黑点的个数
					if(sum < 5 )   
						out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=255;
				}
			}
		}
	}
	memcpy(raw_data,out_data,360000);
    Save_File(DENOSING->index,height,width);
#else
	int x,y,m,n,sum=0;
	int scanline=320;
		
	for (y=cass_mv_border_topbound;y<cass_mv_border_topbound+cass_mv_border_height;y++)
	{
		for (x=cass_mv_border_leftbound;x<cass_mv_border_leftbound+cass_mv_border_width;x++)
		{
			sum=0;
			if(y==cass_mv_border_topbound||y==cass_mv_border_topbound+cass_mv_border_height-1)
				out_data[y*scanline+x]=0;
			else if(x==cass_mv_border_leftbound||x==cass_mv_border_leftbound+cass_mv_border_width-1)
				out_data[y*scanline+x]=0;
			else
			{
				if(raw_data[y*scanline+x]==255)
				{
					for( m = y-1; m<y+2; m++)
					{
						for( n = x-1;n<x+2; n++ )
						{
							if(out_data[m*scanline+n]==255)
							{  
							   sum++;
							}
						}
					}                             //sum记录黑点的个数
					if(sum < 5 )   
						out_data[y*scanline+x]=0;
				}
			}
		}
	}
	memcpy(raw_data,out_data,240*scanline);//可以改为就复制选取区域的一部分，会更快 
          #endif
          return 0;
          }
        ]]></Property>
        <Property name="Description">去噪</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.ZhangParallelFastThinning,ControlTactic,细化,形态学">
      <BasicProperty>
        <Property name="ModuleName">ZHANGTHIN</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">细化</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		
          // 细化函数
          uint8 ZHANGTHINControl(ZHANGTHINStruct *ZHANGTHIN)
          {
          #ifdef CASS_MV_PC_VERSION
          int neighbor[8];
          int x,y,i,k,np,sp;
          int width,height,scanline;
          int markNum=0;
          int loop=1;


          width=bmpinfoarray[18]+bmpinfoarray[19]*256;
          height=bmpinfoarray[22]+bmpinfoarray[23]*256;

          if(width%4)
          scanline=(width*8+31)/32*4;
          else
          scanline=width;

          while(loop)
          {
          loop=0;

          markNum=0;
          for (y=1;y<cass_mv_border_height-1;y++)  
		{
		for (x=1;x<cass_mv_border_width-1;x++)
           {
              //条件1：p必须是前景点
              if(raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]==0 ) 
				  continue;
 
              neighbor[0]= raw_data[(y+cass_mv_border_topbound)*scanline+x+1+cass_mv_border_leftbound] ;
              neighbor[1]= raw_data[(y-1+cass_mv_border_topbound)*scanline+x+1+cass_mv_border_leftbound];
              neighbor[2]= raw_data[(y-1+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
              neighbor[3]= raw_data[(y-1+cass_mv_border_topbound)*scanline+x-1+cass_mv_border_leftbound];
              neighbor[4]= raw_data[(y+cass_mv_border_topbound)*scanline+x-1+cass_mv_border_leftbound];
              neighbor[5]= raw_data[(y+1+cass_mv_border_topbound)*scanline+x-1+cass_mv_border_leftbound];
              neighbor[6]= raw_data[(y+1+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
              neighbor[7]= raw_data[(y+1+cass_mv_border_topbound)*scanline+x+1+cass_mv_border_leftbound];
 
 
              np=(neighbor[0]+neighbor[1]+neighbor[2]+neighbor[3]+neighbor[4]+neighbor[5]+neighbor[6]+neighbor[7])/255;
              if(np<2 || np>6) continue;
 
              sp=0;
              for(i=1;i<8;i++)
              {
                  if(neighbor[i]-neighbor[i-1]==255)
                     sp++;
              }
              if(neighbor[0]-neighbor[7]==255)
                  sp++;            
              if(sp!=1) continue;
 
              if(neighbor[2]&neighbor[0]&neighbor[6]!=0)
                  continue;
              if(neighbor[0]&neighbor[6]&neighbor[4]!=0)
                  continue;

              out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=1;     
              markNum++;
              loop=1;
           }
       }

       //将标记删除的点置为背景色
       if(markNum>0)
       {
        for (y=0;y<cass_mv_border_height;y++)  
		{
			for (x=0;x<cass_mv_border_width;x++) 
			{
                 // k=y*w+x;
                  if(out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]==1)
                  {
                     raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=0;
                  }
              }
           }
       }
      
        markNum=0;
      for (y=1;y<cass_mv_border_height-1;y++)  
		{
			for (x=1;x<cass_mv_border_width-1;x++) 
			{
              //条件1：p必须是前景点
              if(raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]==0 ) 
				  continue;
 
              neighbor[0]= raw_data[(y+cass_mv_border_topbound)*scanline+x+1+cass_mv_border_leftbound] ;
              neighbor[1]= raw_data[(y-1+cass_mv_border_topbound)*scanline+x+1+cass_mv_border_leftbound];
              neighbor[2]= raw_data[(y-1+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
              neighbor[3]= raw_data[(y-1+cass_mv_border_topbound)*scanline+x-1+cass_mv_border_leftbound];
              neighbor[4]= raw_data[(y+cass_mv_border_topbound)*scanline+x-1+cass_mv_border_leftbound];
              neighbor[5]= raw_data[(y+1+cass_mv_border_topbound)*scanline+x-1+cass_mv_border_leftbound];
              neighbor[6]= raw_data[(y+1+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
              neighbor[7]= raw_data[(y+1+cass_mv_border_topbound)*scanline+x+1+cass_mv_border_leftbound];
 
 
              np=(neighbor[0]+neighbor[1]+neighbor[2]+neighbor[3]+neighbor[4]+neighbor[5]+neighbor[6]+neighbor[7])/255;
              if(np<2 || np>6) continue;
 
              sp=0;
              for(i=1;i<8;i++)
              {
                  if(neighbor[i]-neighbor[i-1]==255)
                     sp++;
              }
              if(neighbor[0]-neighbor[7]==255)
                  sp++;
              if(sp!=1) continue;
 
              if(neighbor[2]&neighbor[0]&neighbor[4]!=0)
                  continue;
              if(neighbor[2]&neighbor[6]&neighbor[4]!=0)
                  continue;
 
             out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=1;   
              markNum++;
              loop=1;
           }
       }
 
       //将标记删除的点置为背景色
        if(markNum>0)
       {
         for (y=0;y<cass_mv_border_height;y++)  
		{
			for (x=0;x<cass_mv_border_width;x++) 
              {
                 // k=y*w+x;
                  if(out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]==1)
                  {
                     raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=0;
                  }
              }
           }
       }

          }
          Save_File(ZHANGTHIN->index,height,width);
		  
		  
		  
          #else
	u16 neighbor[8];
	u16 x=0,y=0,scanline=320;
	int loop=1;
  int markNum=0;
	int np,sp,i;
	
  while(loop)
  {
       loop=0;
 
       //第一步
       markNum=0;
       for(y=1;y<cass_mv_border_height-1;y++)
       {
           for(x=1;x<cass_mv_border_width-1;x++)
           {
              //条件1：p必须是前景点
              if(raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]==0 ) 
				  continue;
 
              neighbor[0]= raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound+1] ;
              neighbor[1]= raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound+1];
              neighbor[2]= raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound];
              neighbor[3]= raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound-1];
              neighbor[4]= raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-1];
              neighbor[5]= raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound-1];
              neighbor[6]= raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound];
              neighbor[7]= raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound+1];
 
              //条件2：2<=N(p)<=6
              np=(neighbor[0]+neighbor[1]+neighbor[2]+neighbor[3]+neighbor[4]+neighbor[5]+neighbor[6]+neighbor[7])/255;
              if(np<2 || np>6) 
				continue;
 
              //条件3：S(p）=1
              sp=0;
              for( i=1;i<8;i++)
              {
                  if(neighbor[i]-neighbor[i-1]==255)
                     sp++;
              }
              if(neighbor[0]-neighbor[7]==255)
                sp++;            
              if(sp!=1) 
				continue;
 
              //条件4：p2*p0*p6=0
              if(neighbor[2]&neighbor[0]&neighbor[6]!=0)
                  continue;
                //条件5：p0*p6*p4=0
              if(neighbor[0]&neighbor[6]&neighbor[4]!=0)
                  continue;
 
              //标记删除
              out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=1;   
              markNum++;
              loop=1;
           }
				}
 
       //将标记删除的点置为背景色
       if(markNum>0)
       {
           for(y=0;y<cass_mv_border_height;y++)
              for(x=0;x<cass_mv_border_width;x++)
              {
                 // k=y*w+x;
                  if(out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]==1)
                  {
                     raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=0;
                  }
              }           
       }
      
 
       //第二步
        markNum=0;
       for(y=1;y<cass_mv_border_height-1;y++)
       {
           for(x=1;x<cass_mv_border_width-1;x++)
           {
              //条件1：p必须是前景点
              if(raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]==0 ) continue;
 
              neighbor[0]= raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound+1] ;
              neighbor[1]= raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound+1];
              neighbor[2]= raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound];
              neighbor[3]= raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound-1];
              neighbor[4]= raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-1];
              neighbor[5]= raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound-1];
              neighbor[6]= raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound];
              neighbor[7]= raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound+1];
 
              //条件2：<=N(p)<=6
               np=(neighbor[0]+neighbor[1]+neighbor[2]+neighbor[3]+neighbor[4]+neighbor[5]+neighbor[6]+neighbor[7])/255;
              if(np<2 || np>6)
					continue;
 
              //条件3：S(p)=1
               sp=0;
              for( i=1;i<8;i++)
              {
                  if(neighbor[i]-neighbor[i-1]==255)
                     sp++;
              }
              if(neighbor[0]-neighbor[7]==255)
                  sp++;
              if(sp!=1) 
				continue;
 
              //条件4：p2*p0*p4==0
              if(neighbor[2]&neighbor[0]&neighbor[4]!=0)
                  continue;
              //条件5：p2*p6*p4==0
              if(neighbor[2]&neighbor[6]&neighbor[4]!=0)
                  continue;
 
              //标记删除
             out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=1;   
              markNum++;
              loop=1;
           }
       }
 
       //将标记删除的点置为背景色
       if(markNum>0)
       {
           for(y=0;y<cass_mv_border_height;y++)
              for(x=0;x<cass_mv_border_width;x++)
              {
                 // k=y*w+x;
                  if(out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]==1)
                  {
                     raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=0;
                  }
              }     
       }
     
  } 
          #endif
          return 0;
          }
       ]]> </Property>
        <Property name="Description">Zhang并行快速细化算法/ZhangParallelFastThinning</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Dialate,ControlTactic,膨胀,形态学">
      <BasicProperty>
        <Property name="ModuleName">DIALATE</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">膨胀</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="膨胀强度" varname="length" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">3</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
          // 膨胀函数
          uint8 DIALATEControl(DIALATEStruct *DIALATE)
          {
          #ifdef CASS_MV_PC_VERSION
         int scanline,k,i,j;
	int flag;
	unsigned char pix[5];

	int width=bmpinfoarray[18]+bmpinfoarray[19]*255;
	int height=bmpinfoarray[22]+bmpinfoarray[23]*255;

	if(width%4)
		scanline=(width*8+31)/32*4;
	else
		scanline=width;

	for (i=1;i<cass_mv_border_height-1;i++)  
	{
		for (j=1;j<cass_mv_border_width-1;j++)
		{
			flag=1;
			pix[0]=raw_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound];
			pix[1]=raw_data[(i+cass_mv_border_topbound)*scanline+j-2+cass_mv_border_leftbound];
			pix[2]=raw_data[(i+cass_mv_border_topbound)*scanline+j-1+cass_mv_border_leftbound];
			pix[3]=raw_data[(i+cass_mv_border_topbound)*scanline+j+1+cass_mv_border_leftbound];
			pix[4]=raw_data[(i+cass_mv_border_topbound)*scanline+j+2+cass_mv_border_leftbound];

			for(k=0;k<5;k++)
			{
				if((pix[0]==255)||(pix[k]==255))
				{
				flag=0;
				break;
				}
				if(flag==0)
				{
				break;
				}
			}
			if(flag==0)
				out_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound]=255;
			else
				out_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound]=0;
		}
	}
	memcpy(raw_data,out_data,360000);
    Save_File(DIALATE->index,height,width);
    #else
         u8 k;
  u16 y,x,scanline=320;
  u8 flag;
  u8 pix[5];

	for(y=0;y<cass_mv_border_height;y++)  
		for (x=0;x<cass_mv_border_width;x++)
		{
		  flag=1;
		  pix[0]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
		  pix[1]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-2];
		  pix[2]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-1];
		  pix[3]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound+1];
		  pix[4]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];

		  for(k=0;k<5;k++)
		  {
			if((pix[0]==255)||(pix[k]==255))
			{
				flag=0;
				break;
			}
			if(flag==0)
			{
				break;
			}
		  }
		  if(flag==0)
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=255;
		  else
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=0;
		}

  memcpy(raw_data,out_data,scanline*240);
          #endif
          return 0;
          }
        ]]></Property>
        <Property name="Description">膨胀</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Erode,ControlTactic,腐蚀,形态学">
      <BasicProperty>
        <Property name="ModuleName">ERODE</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">腐蚀</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="腐蚀强度" varname="length" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">3</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
        
uint8 ERODEControl(ERODEStruct *ERODE)
{
#ifdef CASS_MV_PC_VERSION
	int scanline,k,i,j;
	int flag;
	unsigned char pix[5];

	int width=bmpinfoarray[18]+bmpinfoarray[19]*255;
	int height=bmpinfoarray[22]+bmpinfoarray[23]*255;

	if(width%4)
		scanline=(width*8+31)/32*4;
	else
		scanline=width;

	for (i=1;i<cass_mv_border_height-1;i++)  
	{
		for (j=1;j<cass_mv_border_width-1;j++)
		{
			flag=1;
			pix[0]=raw_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound];
			pix[1]=raw_data[(i+cass_mv_border_topbound)*scanline+j-2+cass_mv_border_leftbound];
			pix[2]=raw_data[(i+cass_mv_border_topbound)*scanline+j-1+cass_mv_border_leftbound];
			pix[3]=raw_data[(i+cass_mv_border_topbound)*scanline+j+1+cass_mv_border_leftbound];
			pix[4]=raw_data[(i+cass_mv_border_topbound)*scanline+j+2+cass_mv_border_leftbound];

			for(k=0;k<5;k++)
			{
				if((pix[0]==0)||(pix[k]==0))
				{
				flag=0;
				break;
				}
				if(flag==0)
				{
				break;
				}
			}
			if(flag==0)
				out_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound]=0;
			else
				out_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound]=255;
		}
	}
	memcpy(raw_data,out_data,360000);
	Save_File(ERODE->index,height,width);
#else
    u16 scanline=320,k,x,y;
	u8 flag;
  u8 pix[5];

	for(y=1;y<cass_mv_border_height-1;y++)                                      
	{
    for(x=1;x<cass_mv_border_width-1;x++)
		{
		  flag=1;
		  pix[0]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
		  pix[1]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-2];
		  pix[2]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-1];
		  pix[3]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound+1];
		  pix[4]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound+2];
        
		for(k=0;k<5;k++)
		{
			if((pix[0]==0)||(pix[k]==0))
			{
				flag=0;
				break;
			}
			if(flag==0)
			{
				break;
			}
		}
		if(flag==0)
			out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=0;		
		else	
			out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=255;			
		}
	}
	
 	memcpy(raw_data,out_data,scanline*240);
#endif
    return 0;	
}
     ]]> </Property>
        <Property name="Description">腐蚀处理</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.OpenOperation,ControlTactic,开操作,形态学">
      <BasicProperty>
        <Property name="ModuleName">OPENOPERATION</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">开操作</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="开强度" varname="length" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">3</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 开操作函数
uint8 OPENOPERATIONControl(OPENOPERATIONStruct *OPENOPERATION)
{
#ifdef CASS_MV_PC_VERSION
		int scanline,k,i,j;
	int flag;
	unsigned char pix[5];

	int width=bmpinfoarray[18]+bmpinfoarray[19]*255;
	int height=bmpinfoarray[22]+bmpinfoarray[23]*255;

	if(width%4)
		scanline=(width*8+31)/32*4;
	else
		scanline=width;

	for (i=1;i<cass_mv_border_height-1;i++)  
	{
		for (j=1;j<cass_mv_border_width-1;j++)
		{
			flag=1;
			pix[0]=raw_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound];
			pix[1]=raw_data[(i+cass_mv_border_topbound)*scanline+j-2+cass_mv_border_leftbound];
			pix[2]=raw_data[(i+cass_mv_border_topbound)*scanline+j-1+cass_mv_border_leftbound];
			pix[3]=raw_data[(i+cass_mv_border_topbound)*scanline+j+1+cass_mv_border_leftbound];
			pix[4]=raw_data[(i+cass_mv_border_topbound)*scanline+j+2+cass_mv_border_leftbound];

			for(k=0;k<5;k++)
			{
				if((pix[0]==0)||(pix[k]==0))
				{
				flag=0;
				break;
				}
				if(flag==0)
				{
				break;
				}
			}
			if(flag==0)
				out_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound]=0;
			else
				out_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound]=255;
		}
	}
	memcpy(raw_data,out_data,360000);

	for (i=1;i<cass_mv_border_height-1;i++)  
	{
		for (j=1;j<cass_mv_border_width-1;j++)
		{
			flag=1;
			pix[0]=raw_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound];
			pix[1]=raw_data[(i+cass_mv_border_topbound)*scanline+j-2+cass_mv_border_leftbound];
			pix[2]=raw_data[(i+cass_mv_border_topbound)*scanline+j-1+cass_mv_border_leftbound];
			pix[3]=raw_data[(i+cass_mv_border_topbound)*scanline+j+1+cass_mv_border_leftbound];
			pix[4]=raw_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound];

			for(k=0;k<5;k++)
			{
				if((pix[0]==255)||(pix[k]==255))
				{
				flag=0;
				break;
				}
				if(flag==0)
				{
				break;
				}
			}
			if(flag==0)
				out_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound]=255;
			else
				out_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound]=0;
		}
	}
	memcpy(raw_data,out_data,360000);
	Save_File(OPENOPERATION->index,height,width);
#else
u16 scanline=320,k,x,y;
	u8 flag;
  u8 pix[5];

	for(y=1;y<cass_mv_border_height-1;y++)                                      
	{
    for(x=1;x<cass_mv_border_width-1;x++)
		{
			flag=1;
		  pix[0]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
		  pix[1]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-2];
		  pix[2]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-1];
		  pix[3]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound+1];
		  pix[4]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound+2];
        
			for(k=0;k<5;k++)
			{
				if((pix[0]==0)||(pix[k]==0))
				{
					flag=0;
					break;
				}
				if(flag==0)
				{
					break;
				}
			}
			if(flag==0)
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=0;		
			else	
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=255;			
		}
	}
	
	for(y=0;y<cass_mv_border_height;y++)  
		for (x=0;x<cass_mv_border_width;x++)
		{
		  flag=1;
		  pix[0]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
		  pix[1]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-2];
		  pix[2]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-1];
		  pix[3]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound+1];
		  pix[4]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];

		  for(k=0;k<5;k++)
		  {
			if((pix[0]==255)||(pix[k]==255))
			{
				flag=0;
				break;
			}
			if(flag==0)
			{
				break;
			}
		  }
		  if(flag==0)
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=255;
		  else
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=0;
		}

  memcpy(raw_data,out_data,scanline*240);
#endif
          return 0;
}       
     ]]>   </Property>
        <Property name="Description">先腐蚀再膨胀</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.CloseOperation,ControlTactic,闭操作,形态学">
      <BasicProperty>
        <Property name="ModuleName">CLOSEOPERATION</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">闭操作</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="闭强度" varname="length" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">3</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 闭操作函数
uint8 CLOSEOPERATIONControl(CLOSEOPERATIONStruct *CLOSEOPERATION)
{
#ifdef CASS_MV_PC_VERSION
	int scanline,k,i,j;
	int flag;
	unsigned char pix[5];

	int width=bmpinfoarray[18]+bmpinfoarray[19]*255;
	int height=bmpinfoarray[22]+bmpinfoarray[23]*255;

	if(width%4)
		scanline=(width*8+31)/32*4;
	else
		scanline=width;

		for (i=1;i<cass_mv_border_height-1;i++)  
	{
		for (j=1;j<cass_mv_border_width-1;j++)
		{
			flag=1;
			pix[0]=raw_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound];
			pix[1]=raw_data[(i+cass_mv_border_topbound)*scanline+j-2+cass_mv_border_leftbound];
			pix[2]=raw_data[(i+cass_mv_border_topbound)*scanline+j-1+cass_mv_border_leftbound];
			pix[3]=raw_data[(i+cass_mv_border_topbound)*scanline+j+1+cass_mv_border_leftbound];
			pix[4]=raw_data[(i+cass_mv_border_topbound)*scanline+j+2+cass_mv_border_leftbound];

			for(k=0;k<5;k++)
			{
				if((pix[0]==255)||(pix[k]==255))
				{
				flag=0;
				break;
				}
				if(flag==0)
				{
				break;
				}
			}
			if(flag==0)
				out_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound]=255;
			else
				out_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound]=0;
		}
	}
	memcpy(raw_data,out_data,360000);

	for (i=1;i<cass_mv_border_height-1;i++)  
	{
		for (j=1;j<cass_mv_border_width-1;j++)
		{
			flag=1;
			pix[0]=raw_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound];
			pix[1]=raw_data[(i+cass_mv_border_topbound)*scanline+j-2+cass_mv_border_leftbound];
			pix[2]=raw_data[(i+cass_mv_border_topbound)*scanline+j-1+cass_mv_border_leftbound];
			pix[3]=raw_data[(i+cass_mv_border_topbound)*scanline+j+1+cass_mv_border_leftbound];
			pix[4]=raw_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound];

			for(k=0;k<5;k++)
			{
				if((pix[0]==0)||(pix[k]==0))
				{
				flag=0;
				break;
				}
				if(flag==0)
				{
				break;
				}
			}
			if(flag==0)
				out_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound]=0;
			else
				out_data[(i+cass_mv_border_topbound)*scanline+j+cass_mv_border_leftbound]=255;
		}
	}
	memcpy(raw_data,out_data,360000);
	Save_File(CLOSEOPERATION->index,height,width);
#else
	u8 k;
  u16 y,x,scanline=320;
  u8 flag;
  u8 pix[5];

	for(y=0;y<cass_mv_border_height;y++)  
		for (x=0;x<cass_mv_border_width;x++)
		{
		  flag=1;
		  pix[0]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
		  pix[1]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-2];
		  pix[2]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-1];
		  pix[3]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound+1];
		  pix[4]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];

		  for(k=0;k<5;k++)
		  {
			if((pix[0]==255)||(pix[k]==255))
			{
				flag=0;
				break;
			}
			if(flag==0)
			{
				break;
			}
		  }
		  if(flag==0)
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=255;
		  else
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=0;
		}
		
		for(y=1;y<cass_mv_border_height-1;y++)                                      
	{
    for(x=1;x<cass_mv_border_width-1;x++)
		{
			flag=1;
		  pix[0]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
		  pix[1]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-2];
		  pix[2]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-1];
		  pix[3]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound+1];
		  pix[4]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound+2];
        
			for(k=0;k<5;k++)
			{
				if((pix[0]==0)||(pix[k]==0))
				{
					flag=0;
					break;
				}
				if(flag==0)
				{
					break;
				}
			}
			if(flag==0)
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=0;		
			else	
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=255;			
		}
	}
 	memcpy(raw_data,out_data,scanline*240);
	return 1;
#endif
          return 0;
}       
      ]]>  </Property>
        <Property name="Description">先膨胀再腐蚀</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="轮廓检测">
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Canny,ControlTactic,卡尼边缘检测,轮廓检测">
      <BasicProperty>
        <Property name="ModuleName">CANNY</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">卡尼边缘检测</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="低阈值" varname="low_threshold" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">30</Property>
        <Property name="高阈值" varname="high_threshold" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">70</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 卡尼边缘检测函数
uint8 CANNYControl(CANNYStruct *CANNY)
{
#ifdef CASS_MV_PC_VERSION
	
#else

#endif
          return 0;
}       
   ]]>     </Property>
        <Property name="Description">卡尼边缘检测</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.HoughLines,ControlTactic,霍夫直线检测,轮廓检测">
      <BasicProperty>
        <Property name="ModuleName">HOUGHLINES</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">霍夫直线检测</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 霍夫直线检测函数
uint8 HOUGHLINESControl(HOUGHLINESStruct *HOUGHLINES)
{
#ifdef CASS_MV_PC_VERSION
	
#else

#endif
          return 0;
}       
      ]]>  </Property>
        <Property name="Description">霍夫直线检测</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Hollowed,ControlTactic,掏空,轮廓检测">
      <BasicProperty>
        <Property name="ModuleName">HOLLOWED</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">掏空</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 掏空函数
uint8 HOLLOWEDControl(HOLLOWEDStruct *HOLLOWED)
{
#ifdef CASS_MV_PC_VERSION
	int x,y,sum;
    int width,height,scanline;
	int v[9];

	width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

	for (y=0;y<cass_mv_border_height;y++)  
	{
		for (x=0;x<cass_mv_border_width;x++)
		{
			if(y==0||y==cass_mv_border_height-1)
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
			else if(x==0||x==cass_mv_border_width-1)
				out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
			else
			{
				if(raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]==0)
				{
					v[0] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
					v[1] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
					v[2] = raw_data[(y-1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];
					v[3] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
					v[4] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
					v[5] = raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];
					v[6] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)-1];
					v[7] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
					v[8] = raw_data[(y+1+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)+1];

					if(v[0]+v[1]+v[2]+v[3]+v[5]+v[6]+v[7]+v[8]==0)
						out_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)]=255;
				}
			}
		}
	}
	memcpy(raw_data,out_data,360000);
          Save_File(HOLLOWED->index,height,width);
          #else
	u16 x,y,sum,scanline=320;
  u8 v[9];

	for (y=0 ;y<cass_mv_border_height;y++)
		for (x=0;x<cass_mv_border_width;x++)
    {
			  if(y==0||y==cass_mv_border_height-1)
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
			  else if(x==0||x==cass_mv_border_width-1)
				out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
			  else
			  {
				if(raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]==0)
				{
				  v[0] = raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound-1];
				  v[1] = raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound];
				  v[2] = raw_data[(y+cass_mv_border_topbound-1)*scanline+x+cass_mv_border_leftbound+1];
				  v[3] = raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound-1];
				  v[4] = raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
				  v[5] = raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound+1];
				  v[6] = raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound-1];
				  v[7] = raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound];
				  v[8] = raw_data[(y+cass_mv_border_topbound+1)*scanline+x+cass_mv_border_leftbound+1];

				  if(v[0]+v[1]+v[2]+v[3]+v[5]+v[6]+v[7]+v[8]==0)
					out_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound]=255;
				}
			  }
		}
    
		memcpy(raw_data,out_data,scanline*240);		  
          #endif
          return 0;
          }
       ]]> </Property>
        <Property name="Description">掏空</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="特征点检测">
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Harris,ControlTactic,哈里斯角点,特征点检测">
      <BasicProperty>
        <Property name="ModuleName">HARRIS</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">0</Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">哈里斯角点</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="低阈值" varname="low_threshold" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">30</Property>
        <Property name="高阈值" varname="high_threshold" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">70</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 哈里斯角点函数
uint8 HARRISControl(HARRISStruct *HARRIS)
{
#ifdef CASS_MV_PC_VERSION
	
#else

#endif
          return 0;
}       
       ]]> </Property>
        <Property name="Description">哈里斯角点</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="数值计算">
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.CenterOfGravity,ControlTactic,区域重心,数值计算">
      <BasicProperty>
        <Property name="ModuleName">CENTEROFGRAVITY</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">
        </Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		//区域重心函数
uint8 CENTEROFGRAVITYControl(CENTEROFGRAVITYStruct *CENTEROFGRAVITY)
{
#ifdef CASS_MV_PC_VERSION
	int x,y,sum;
    int width,height,scanline;
	double s00=0,s10=0,s01=0;//0阶矩和1阶矩
	int Center_x=0,Center_y=0;//重心坐标

	width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

	for (y=0;y<cass_mv_border_height;y++)  
	{
		for (x=0;x<cass_mv_border_width;x++)
		{
			s00+=raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
			s10+=x*raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
			s01+=y*raw_data[(y+cass_mv_border_topbound)*scanline+(x+cass_mv_border_leftbound)];
		}
	}

	Center_x=(s10/s00+0.5);
    Center_y=(s01/s00+0.5);

	//将重心周五3×3区域灰度置于128
	raw_data[(Center_y-1+cass_mv_border_topbound)*scanline+Center_x-1+cass_mv_border_leftbound]=128;
	raw_data[(Center_y-1+cass_mv_border_topbound)*scanline+Center_x+cass_mv_border_leftbound]=128;
	raw_data[(Center_y-1+cass_mv_border_topbound)*scanline+Center_x+1+cass_mv_border_leftbound]=128;
	raw_data[(Center_y+cass_mv_border_topbound)*scanline+Center_x-1+cass_mv_border_leftbound]=128;
	raw_data[(Center_y+cass_mv_border_topbound)*scanline+Center_x+cass_mv_border_leftbound]=128;
	raw_data[(Center_y+cass_mv_border_topbound)*scanline+Center_x+1+cass_mv_border_leftbound]=128;
	raw_data[(Center_y+1+cass_mv_border_topbound)*scanline+Center_x-1+cass_mv_border_leftbound]=128;
	raw_data[(Center_y+1+cass_mv_border_topbound)*scanline+Center_x+cass_mv_border_leftbound]=128;
	raw_data[(Center_y+1+cass_mv_border_topbound)*scanline+Center_x+1+cass_mv_border_leftbound]=128;
    Save_File(CENTEROFGRAVITY->index,height,width);
          #else
u16 x,y,scanline=320;
	double s00=0,s10=0,s01=0;//0阶矩和1阶矩
	u16 Center_x=0,Center_y=0;//重心坐标

	for (y=0;y<cass_mv_border_height;y++)
	{
		for (x=0;x<cass_mv_border_width;x++)
		{
			s00+=raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
			s10+=x*raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
			s01+=y*raw_data[(y+cass_mv_border_topbound)*scanline+x+cass_mv_border_leftbound];
		}
	}

	Center_x=(s10/s00+0.5);
	Center_y=(s01/s00+0.5);
	raw_data[(Center_y+cass_mv_border_topbound-1)*scanline+Center_x+cass_mv_border_leftbound-1]=128;
	raw_data[(Center_y+cass_mv_border_topbound-1)*scanline+Center_x+cass_mv_border_leftbound]=128;
	raw_data[(Center_y+cass_mv_border_topbound-1)*scanline+Center_x+cass_mv_border_leftbound+1]=128;
	raw_data[(Center_y+cass_mv_border_topbound)*scanline+Center_x+cass_mv_border_leftbound-1]=128;
	raw_data[(Center_y+cass_mv_border_topbound)*scanline+Center_x+cass_mv_border_leftbound]=128;
	raw_data[(Center_y+cass_mv_border_topbound)*scanline+Center_x+cass_mv_border_leftbound+1]=128;
	raw_data[(Center_y+cass_mv_border_topbound+1)*scanline+Center_x+cass_mv_border_leftbound-1]=128;
	raw_data[(Center_y+cass_mv_border_topbound+1)*scanline+Center_x+cass_mv_border_leftbound]=128;
	raw_data[(Center_y+cass_mv_border_topbound+1)*scanline+Center_x+cass_mv_border_leftbound+1]=128;
          #endif
          return 0;
          }
      ]]>  </Property>
        <Property name="Description">CenterOfGravity</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
</configuration>