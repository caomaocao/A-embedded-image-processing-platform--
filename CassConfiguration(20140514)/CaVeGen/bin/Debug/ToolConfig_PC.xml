<configuration>
  <Category DisplayName="输入输出">
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.FileInput,ControlTactic,文件输入,输入输出">
      <BasicProperty>
        <Property name="ModuleName">FILEIN</Property>
        <Property name="ModuleColor">255,238,232,170</Property>
        <Property name="ModuleSort">文件输入</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[		
// 文件输入
uint8 FILEINControl(char *filename)
{
#ifdef CASS_MV_PC_VERSION
	FILE *source;
   	int  x,y,scanline;
	int width,height,fileSize,dwSize,current;
	
	memset(raw_data,0,360000);
	memset(out_data,0,360000);
	
	if((source=fopen((char *)filename,"r"))==NULL)
    	{
        	printf("can't open the source file!\n");
        	return 0;
    	}
	
	/*读取bmp文件头和信息头存到数组里*/
	fseek(source,0,SEEK_SET);
	fread(bmpinfoarray,sizeof(unsigned char),54,source);
	fseek(source,54,SEEK_SET);
	fread(plltee,sizeof(unsigned char),1024,source);
	
	fseek(source,2,0);
	fread(&fileSize,sizeof(long),1,source);//读取bmp数据区大小
	
	fseek(source,14,0);
	fread(&dwSize,sizeof(long),1,source);

          //bmpinfo.width=bmpinfoarray[18]+bmpinfoarray[19]*255;
          //bmpinfo.height=bmpinfoarray[22]+bmpinfoarray[23]*255;
          //bmpinfo.fileSize=fileSize;
          //bmpinfo.dwSize=dwSize;

          width=bmpinfoarray[18]+bmpinfoarray[19]*255;
          height=bmpinfoarray[22]+bmpinfoarray[23]*255;

          if(width%4)//bmp宽度不为4要补0
          	scanline=(width*8+31)/32*4;
          else
          	scanline=width;

 	for(x=0;x<height;x++)//读取bmp进数组		
	{	
		for(y=0;y<scanline;y++)
		{
			current=14+dwSize+1024+x*scanline+y;
			fseek(source,current,0); 
			raw_data[(height-1-x)*scanline+y]=fgetc(source);
		}	
	}		
	fclose(source);
#else

#endif
	return 1;
}]]>
</Property>
        <Property name="Description">FILEIN

</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.FileOutput,ControlTactic,文件输出,输入输出">
      <BasicProperty>
        <Property name="ModuleName">FILEOUT</Property>
        <Property name="ModuleColor">255,238,232,170</Property>
        <Property name="ModuleSort">文件输出</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[			
// 输出
void FILEOUTControl(char *folderName)
{
#ifdef CASS_MV_PC_VERSION
        FILE *fp;
        char pass[4];
		if((fp=fopen("result.txt","w"))==NULL)
    		{
        		printf("can't open the source file!\n");
        		return;
    		}
                itoa(cass_mv_match_percent,pass,10);
                fprintf(fp,"%s\n",pass);
		itoa(cass_mv_match_result,pass,10);
                fprintf(fp,"%s\n",pass);                				
	        fclose(fp);
#endif
}
]]>    
        </Property>
        <Property name="Description">FILEOUT</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.CameraIn,ControlTactic,设备输入,输入输出">
      <BasicProperty>
        <Property name="ModuleName">CAMERAIN</Property>
        <Property name="ModuleColor">255,238,232,170</Property>
        <Property name="ModuleSort">设备输入</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="设备号" varname="portName" type="COM" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">COM4</Property>
        <Property name="波特率" varname="baudRate" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">115200</Property>
        <Property name="数据位" varname="dataBits" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">8</Property>
		<Property name="停止位" varname="stopBits" type="System.String" visible="no" exp="" optype="" opvalue="" opnode="" relate="">ONESTOPBIT</Property>
        <Property name="奇偶校验" varname="parity" type="System.String" visible="no" exp="" optype="" opvalue="" opnode="" relate="">NOPARITY</Property>   
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">
<![CDATA[	
		// 设备输入
uint8 CAMERAINControl(CAMERAINStruct *CamIn)
{
#ifdef CASS_MV_PC_VERSION
    unsigned int length;
    int width = 0, height = 0;
    int ret;

    //模块参数传入
  //  ret = SeiralPortOpen(cass_mv_cameraIn_serialportname,cass_mv_cameraIn_serialBaudrate, cass_mv_cameraIn_serialStopbits,cass_mv_cameraIn_serialParity);
	ret = SeiralPortOpen(CamIn->portName,CamIn->baudRate, CamIn->stopBits,CamIn->parity);
    if(ret == -1)
    {      
        return ret;
    }

    raw_data[0] = 1;
    raw_data[1] = 32;
    raw_data[2] = 0;
    raw_data[3] = 1;
    raw_data[4] = 0;
    raw_data[5] = 1;
    raw_data[6] = 16;
    raw_data[7] = 13;
    length = 0;
    
    ret = write_scc(raw_data,8, &length);
    if(length == 8)
    {
        length = 0;
        ret = read_scc(out_data,360000,&length);
        if(length >6)
        {
                width= out_data[2] + out_data[3]*255;
                height = out_data[4] + out_data[5]*255;
                if(length == width * height + 6)
                	memcpy(raw_data, out_data+6, length-6);
		
        }
    }
    //printf("w:%d h:%d len:%d\n", width, height, length);
    SerialPortClose();
    //save as bmp;
    Save_File(CamIn->index, height, width);
    return ret;
#else

#endif
	return 1;
}
]]>
        </Property>
        <Property name="Description">CAMERAIN</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="滤波">
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.GaussianSmoothing,ControlTactic,高斯滤波,滤波">
      <BasicProperty>
        <Property name="ModuleName">GAUSSIANSMOOTHING</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">高斯滤波</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模板大小" varname="length" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">3</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
          // 高斯函数
          uint8 GAUSSIANSMOOTHINGControl(GAUSSIANSMOOTHINGStruct *GAUSSIANSMOOTHING)
          {
          #ifdef CASS_MV_PC_VERSION
          int x,y,scanline;
          int cur_value,thresh_value,sum;
          int width,height;
          int v[9];

          static int win[9] = { 1,2,1,2,4,2,1,2,1};

          width=bmpinfoarray[18]+bmpinfoarray[19]*256;
          height=bmpinfoarray[22]+bmpinfoarray[23]*256;

          if(width%4)//bmp宽度不为4要补0
          scanline=(width*8+31)/32*4;
          else
          scanline=width;

          for (y=0 ;y<height;y++)
          {
          for (x=0;x<width;x++)
          {
          sum=0;

          if(y==0||y==height-1)
          out_data[y*scanline+x]=raw_data[y*scanline+x];
          else if(x==0||x==width-1)
          out_data[y*scanline+x]=raw_data[y*scanline+x];
          else
          {
          v[0] = raw_data[(y-1)*scanline+x-1];
          v[1] = raw_data[(y-1)*scanline+x];
          v[2] = raw_data[(y-1)*scanline+x+1];
          v[3] = raw_data[y*scanline+x-1];
          v[4] = raw_data[y*scanline+x];
          v[5] = raw_data[y*scanline+x+1];
          v[6] = raw_data[(y+1)*scanline+x-1];
          v[7] = raw_data[(y+1)*scanline+x];
          v[8] = raw_data[(y+1)*scanline+x+1];

          sum = win[0]*v[0] + win[1]*v[1] + win[2]*v[2]
          + win[3]*v[3] + win[4]*v[4] + win[5]*v[5]
          + win[6]*v[6] + win[7]*v[7] + win[8]*v[8];

          sum = (int)(sum/16);
          if(sum>255)
          sum=255;
          if(sum<0)
          sum=0;
          out_data[y*scanline+x]=(unsigned char)sum;
          }
          }
          }
          memcpy(raw_data,out_data,360000);
          Save_File(GAUSSIANSMOOTHING->index, height,width);
          #else
          u16 x=0,y=0;
          u16 cur_value=0;
          u8	value=0;
          u8  v[9];

          static int win[9] = { 1,2,1,2,4,2,1,2,1	};

          for (y=0;y<cass_mv_boarder_height ;y++)
          {
          for (x=0;x<cass_mv_boarder_width ;x++)
          {
          v[0] = out_data[(y-1)*cass_mv_boarder_width+x-1];
          v[1] = out_data[(y-1)*cass_mv_boarder_width+x];
          v[2] = out_data[(y-1)*cass_mv_boarder_width+x+1];
          v[3] = out_data[y*cass_mv_boarder_width+x-1];
          v[4] = out_data[y*cass_mv_boarder_width+x];
          v[5] = out_data[y*cass_mv_boarder_width+x+1];
          v[6] = out_data[(y+1)*cass_mv_boarder_width+x-1];
          v[7] = out_data[(y+1)*cass_mv_boarder_width+x];
          v[8] = out_data[(y+1)*cass_mv_boarder_width+x+1];

          cur_value = win[0]*v[0] + win[1]*v[1] + win[2]*v[2]
          + win[3]*v[3] + win[4]*v[4] + win[5]*v[5]
          + win[6]*v[6] + win[7]*v[7] + win[8]*v[8];

          value = (u8)(cur_value>>4);

          temp_data[y*cass_mv_boarder_width+x] = value;
          }
          }
          memcpy(out_data,temp_data,cass_mv_boarder_width*cass_mv_boarder_height);//注意边缘处理，无边缘情况。copy数据过去会错位
          #endif
          return 0;
          }
]]>
        </Property>
        <Property name="Description">高斯滤波/GAUSSIANSMOOTHING</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.MedianFilter,ControlTactic,中值滤波,滤波">
      <BasicProperty>
        <Property name="ModuleName">MEDIANFILTER</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
         <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">中值滤波</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模板大小" varname="length" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">3</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
          // 中值滤波函数
          uint8 MEDIANFILTERControl(MEDIANFILTERStruct *MEDIANFILTER)
          {
          #ifdef CASS_MV_PC_VERSION
          int x,y,scanline;
          int width,height;
          int v[9],ii,jj,m,n,min;
          unsigned char temp;

          width=bmpinfoarray[18]+bmpinfoarray[19]*256;
          height=bmpinfoarray[22]+bmpinfoarray[23]*256;

          if(width%4)//bmp宽度不为4要补0
          scanline=(width*8+31)/32*4;
          else
          scanline=width;

          for (y=0;y<height;y++)
          {
          for (x=0;x<width;x++)
          {
          if(y==0||y==height-1)
          out_data[y*scanline+x]=raw_data[y*scanline+x];
          else if(x==0||x==width-1)
          out_data[y*scanline+x]=raw_data[y*scanline+x];
          else
          {
          int k = 0;

          for ( jj=y-1;jj < y+2; ++jj)
          for ( ii=x-1;ii < x+2; ++ii)
          {
          v[k++] = raw_data[jj * scanline + ii];
          }

          for ( m = 0; m < 5; ++m)
          {
          min = m;
          for ( n = m + 1; n < 9; ++n)
          {
          if (v[n] < v[min])
          min = n;
          }
          temp = v[m];
          v[m] = v[min];
          v[min] = temp;
          }
          out_data[y*scanline+x] = v[4];
          }
          }
          }
          memcpy(raw_data,out_data,360000);
          Save_File(MEDIANFILTER->index, height,width);
          #else

          #endif
          return 0;
          }
		  ]]></Property>
        <Property name="Description">中值滤波</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.MeanFilter,ControlTactic,均值滤波,滤波">
      <BasicProperty>
        <Property name="ModuleName">MEANFILTER</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">均值滤波</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模板大小" varname="length" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">3</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">
	<![CDATA[
          // 均值滤波函数
          uint8 MEANFILTERControl(MEANFILTERStruct *MEANFILTER)
          {
          #ifdef CASS_MV_PC_VERSION
          int x,y,sum;
          int width,height,scanline;
          int v[9];

          width=bmpinfoarray[18]+bmpinfoarray[19]*256;
          height=bmpinfoarray[22]+bmpinfoarray[23]*256;

          if(width%4)//bmp宽度不为4要补0
          scanline=(width*8+31)/32*4;
          else
          scanline=width;

          for (y=0 ;y<height;y++)
          {
          for (x=0;x<width;x++)
          {
          sum=0;
          if(y==0||y==height-1)
          out_data[y*scanline+x]=raw_data[y*scanline+x];
          else if(x==0||x==width-1)
          out_data[y*scanline+x]=raw_data[y*scanline+x];
          else
          {
          v[0] = raw_data[(y-1)*scanline+x-1];
          v[1] = raw_data[(y-1)*scanline+x];
          v[2] = raw_data[(y-1)*scanline+x+1];
          v[3] = raw_data[y*scanline+x-1];
          v[4] = raw_data[y*scanline+x];
          v[5] = raw_data[y*scanline+x+1];
          v[6] = raw_data[(y+1)*scanline+x-1];
          v[7] = raw_data[(y+1)*scanline+x];
          v[8] = raw_data[(y+1)*scanline+x+1];

          sum = v[0] + v[1] + v[2]+ v[3] + v[4] + v[5]+ v[6] + v[7] + v[8];
          sum = (int)(sum/9);
          out_data[y*scanline+x]=(unsigned char)sum;
          }
          }
          }
          memcpy(raw_data,out_data,360000);
          Save_File(MEANFILTER->index, height,width);
          #else

          #endif
          return 0;
          }
		  ]]></Property>
        <Property name="Description">均值滤波/MEDIANFILTER</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Sobel,ControlTactic,索贝尔处理,滤波">
      <BasicProperty>
        <Property name="ModuleName">SOBEL</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">索贝尔处理</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="梯度阈值" varname="threshold" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">128</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
          // 索贝尔函数
          uint8 SOBELControl(SOBELStruct  *SOBEL)
          {
          #ifdef CASS_MV_PC_VERSION
          int x,y,scanline;
          int cur_value,thresh_value,sumx,sumy,sum;
          int width,height;
          int v[9];

          static int winy[9] = { -1,-2,-1,0,0,0,1,2,1};
          static int winx[9] = { -1,0,1,-2,0,2,-1,0,1};
          width=bmpinfoarray[18]+bmpinfoarray[19]*256;
          height=bmpinfoarray[22]+bmpinfoarray[23]*256;

          if(width%4)//bmp宽度不为4要补0
          scanline=(width*8+31)/32*4;
          else
          scanline=width;

          for (y=0 ;y<height;y++)
          {
          for (x=0;x<width;x++)
          {
          sumx=0;
          sumy=0;
          if(y==0||y==height-1)
          sum=0;
          else if(x==0||x==width-1)
          sum=0;
          else
          {
          v[0] = raw_data[(y-1)*scanline+x-1];
          v[1] = raw_data[(y-1)*scanline+x];
          v[2] = raw_data[(y-1)*scanline+x+1];
          v[3] = raw_data[y*scanline+x-1];
          v[4] = raw_data[y*scanline+x];
          v[5] = raw_data[y*scanline+x+1];
          v[6] = raw_data[(y+1)*scanline+x-1];
          v[7] = raw_data[(y+1)*scanline+x];
          v[8] = raw_data[(y+1)*scanline+x+1];

          sumx = winx[0]*v[0] + winx[1]*v[1] + winx[2]*v[2]
          + winx[3]*v[3] + winx[4]*v[4] + winx[5]*v[5]
          + winx[6]*v[6] + winx[7]*v[7] + winx[8]*v[8];

          sumx = (int)(sumx/16);
          if(sumx>255)
          sumx=255;
          if(sumx<0)
          sumx=0;

          sumy = winy[0]*v[0] + winy[1]*v[1] + winy[2]*v[2]
          + winy[3]*v[3] + winy[4]*v[4] + winy[5]*v[5]
          + winy[6]*v[6] + winy[7]*v[7] + winy[8]*v[8];
          sumy = (int)(sumy/16);
          if(sumy>255)
          sumx=255;
          if(sumy<0)
          sumx=0;

          sum=(int)sqrt((float)(sumx*sumx+sumy*sumy));
          }
          //out_data[y*scanline+x]=255-(unsigned char)sum;
          if(sum>SOBEL->threshold)//改了
          out_data[y*scanline+x]=255;
          else
          out_data[y*scanline+x]=0;
          }
          }
          memcpy(raw_data,out_data,360000);
          Save_File(SOBEL->index, height,width);
          #else
          u16 x=0,y=0;
          u16 cur_value=0;
          u8	value=0;
          u8  v[9];

          static int win[9] = { 1,2,1,0,0,0,-1,-2,-1};

          for (y=0;y<cass_mv_boarder_height ;y++)
          {
          for (x=0;x<cass_mv_boarder_width ;x++)
          {
          v[0] = out_data[(y-1)*cass_mv_boarder_width+x-1];
          v[1] = out_data[(y-1)*cass_mv_boarder_width+x];
          v[2] = out_data[(y-1)*cass_mv_boarder_width+x+1];
          v[3] = out_data[y*cass_mv_boarder_width+x-1];
          v[4] = out_data[y*cass_mv_boarder_width+x];
          v[5] = out_data[y*cass_mv_boarder_width+x+1];
          v[6] = out_data[(y+1)*cass_mv_boarder_width+x-1];
          v[7] = out_data[(y+1)*cass_mv_boarder_width+x];
          v[8] = out_data[(y+1)*cass_mv_boarder_width+x+1];

          cur_value = win[0]*v[0] + win[1]*v[1] + win[2]*v[2]
          + win[3]*v[3] + win[4]*v[4] + win[5]*v[5]
          + win[6]*v[6] + win[7]*v[7] + win[8]*v[8];

          value = (u8)(cur_value>>4);

          temp_data[y*cass_mv_boarder_width+x] = value;
          }
          }
          memcpy(out_data,temp_data,cass_mv_boarder_width*cass_mv_boarder_height);
          
          #endif
          return 0;
          }
    ]]>    </Property>
        <Property name="Description">索贝尔处理</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Prewitt,ControlTactic,普锐维特处理,滤波">
      <BasicProperty>
        <Property name="ModuleName">PREWITT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">普锐维特处理</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="梯度阈值" varname="threshold" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">128</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
          // 普锐维特函数
          uint8 PREWITTControl(PREWITTStruct  *PREWITT)
          {
          #ifdef CASS_MV_PC_VERSION
          int x,y,scanline;
          int sumx,sumy,sum;
          int width,height;
          int v[9];

          static int winy[9] = { -1,0,1,-1,0,1,-1,0,1};
          static int winx[9] = { -1,-1,1,0,0,0,1,1,1};
          width=bmpinfoarray[18]+bmpinfoarray[19]*256;
          height=bmpinfoarray[22]+bmpinfoarray[23]*256;

          if(width%4)//bmp宽度不为4要补0
          scanline=(width*8+31)/32*4;
          else
          scanline=width;

          for (y=0 ;y<height;y++)
          {
          for (x=0;x<width;x++)
          {
          sumx=0;
          sumy=0;
          if(y==0||y==height-1)
          sum=0;
          else if(x==0||x==width-1)
          sum=0;
          else
          {
          v[0] = raw_data[(y-1)*scanline+x-1];
          v[1] = raw_data[(y-1)*scanline+x];
          v[2] = raw_data[(y-1)*scanline+x+1];
          v[3] = raw_data[y*scanline+x-1];
          v[4] = raw_data[y*scanline+x];
          v[5] = raw_data[y*scanline+x+1];
          v[6] = raw_data[(y+1)*scanline+x-1];
          v[7] = raw_data[(y+1)*scanline+x];
          v[8] = raw_data[(y+1)*scanline+x+1];

          sumx = winx[0]*v[0] + winx[1]*v[1] + winx[2]*v[2]
          + winx[3]*v[3] + winx[4]*v[4] + winx[5]*v[5]
          + winx[6]*v[6] + winx[7]*v[7] + winx[8]*v[8];

          sumx = (int)(sumx/16);
          if(sumx>255)
          sumx=255;
          if(sumx<0)
          sumx=0;

          sumy = winy[0]*v[0] + winy[1]*v[1] + winy[2]*v[2]
          + winy[3]*v[3] + winy[4]*v[4] + winy[5]*v[5]
          + winy[6]*v[6] + winy[7]*v[7] + winy[8]*v[8];
          sumy = (int)(sumy/16);
          if(sumy>255)
          sumx=255;
          if(sumy<0)
          sumx=0;

          sum=(int)sqrt((float)(sumx*sumx+sumy*sumy));
          }
          if(sum>PREWITT->threshold)
          out_data[y*scanline+x] = 255;
          else
          out_data[y*scanline+x] = 0;
          //out_data[y*scanline+x]=255-(unsigned char)sum;
          }
          }
          memcpy(raw_data,out_data,360000);
          Save_File(PREWITT->index, height,width);
          #else
          u16 x=0,y=0;
          u16 cur_value=0;
          u8	value=0;
          u8  v[9];

          static int win[9] = { -1,-1,-1,0,0,0,1,1,1};

          for (y=0;y<cass_mv_boarder_height ;y++)
          {
          for (x=0;x<cass_mv_boarder_width ;x++)
          {
          v[0] = out_data[(y-1)*cass_mv_boarder_width+x-1];
          v[1] = out_data[(y-1)*cass_mv_boarder_width+x];
          v[2] = out_data[(y-1)*cass_mv_boarder_width+x+1];
          v[3] = out_data[y*cass_mv_boarder_width+x-1];
          v[4] = out_data[y*cass_mv_boarder_width+x];
          v[5] = out_data[y*cass_mv_boarder_width+x+1];
          v[6] = out_data[(y+1)*cass_mv_boarder_width+x-1];
          v[7] = out_data[(y+1)*cass_mv_boarder_width+x];
          v[8] = out_data[(y+1)*cass_mv_boarder_width+x+1];

          cur_value = win[0]*v[0] + win[1]*v[1] + win[2]*v[2]
          + win[3]*v[3] + win[4]*v[4] + win[5]*v[5]
          + win[6]*v[6] + win[7]*v[7] + win[8]*v[8];

          value = (u8)(cur_value>>4);

          temp_data[y*cass_mv_boarder_width+x] = value;
          }
          }
          memcpy(out_data,temp_data,cass_mv_boarder_width*cass_mv_boarder_height);

          #endif
          return 0;
          }
      ]]>  </Property>
        <Property name="Description">普锐维特处理</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Laplace,ControlTactic,拉普拉斯处理,滤波">
      <BasicProperty>
        <Property name="ModuleName">LAPLACE</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">拉普拉斯处理</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
          // laplace函数
          uint8 LAPLACEControl(LAPLACEStruct *LAPLACE)
          {
          #ifdef CASS_MV_PC_VERSION
          int x,y,scanline;
          int cur_value,thresh_value;
          int width,height;
          int v[9];

          static int win[9] = { 0,1,0,   /*高斯滤波模板窗体*/
          1,-4,1,
          0,1,0
          };

          width=bmpinfoarray[18]+bmpinfoarray[19]*255;
          height=bmpinfoarray[22]+bmpinfoarray[23]*255;

          if(width%4)//bmp宽度不为4要补0
          scanline=(width*8+31)/32*4;
          else
          scanline=width;

          for(x=1;x<height-1;x++)
          for(y=1;y<width-1;y++)
          {
          v[0] = raw_data[(x-1)*scanline+y-1];
          v[1] = raw_data[(x-1)*scanline+y];
          v[2] = raw_data[(x-1)*scanline+y+1];
          v[3] = raw_data[(x)*scanline+y-1];
          v[4] = raw_data[(x)*scanline+y];
          v[5] = raw_data[(x)*scanline+y+1];
          v[6] = raw_data[(x+1)*scanline+y-1];
          v[7] = raw_data[(x+1)*scanline+y];
          v[8] = raw_data[(x+1)*scanline+y+1];

          cur_value = win[0]*v[0] + win[1]*v[1] + win[2]*v[2]
          + win[3]*v[3] + win[4]*v[4] + win[5]*v[5]
          + win[6]*v[6] + win[7]*v[7] + win[8]*v[8];

          cur_value = (int)(cur_value/16);

          out_data[x*scanline+y] = cur_value;
          }
          memcpy(raw_data,out_data,360000);
          Save_File(LAPLACE->index, height,width);
          #else
          u16 x,y;
          u16 cur_value=0;
          u8 v[9];
          static int win[9] = {0,1,0,1,-4,1,0,1,0};

          for (y=0 ;y<cass_mv_boarder_height ;y++)
          {
          for (x=0;x<cass_mv_boarder_width ;x++)
          {
          v[0] = out_data[(y-1)*cass_mv_boarder_width+x-1];
          v[1] = out_data[(y-1)*cass_mv_boarder_width+x];
          v[2] = out_data[(y-1)*cass_mv_boarder_width+x+1];
          v[3] = out_data[y*cass_mv_boarder_width+x-1];
          v[4] = out_data[y*cass_mv_boarder_width+x];
          v[5] = out_data[y*cass_mv_boarder_width+x+1];
          v[6] = out_data[(y+1)*cass_mv_boarder_width+x-1];
          v[7] = out_data[(y+1)*cass_mv_boarder_width+x];
          v[8] = out_data[(y+1)*cass_mv_boarder_width+x+1];

          cur_value = win[0]*v[0] + win[1]*v[1] + win[2]*v[2]
          + win[3]*v[3] + win[4]*v[4] + win[5]*v[5]
          + win[6]*v[6] + win[7]*v[7] + win[8]*v[8];

          cur_value = (u8)(cur_value>>4);

          temp_data[y*cass_mv_boarder_width+x] = cur_value;
          }
          }
          memcpy(out_data,temp_data,cass_mv_boarder_width*cass_mv_boarder_height);//注意边缘处理，无边缘情况。copy数据过去会错位

          #endif
          return 0;
          }
        ]]></Property>
        <Property name="Description">指令名：拉普拉斯处理</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="匹配">
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Match,ControlTactic,识别处理,匹配">
      <BasicProperty>
        <Property name="ModuleName">MATCH</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">识别处理</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="匹配率" varname="percent" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">50</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 识别处理函数
uint8 MATCHControl(MATCHStruct *MATCH)
{
#ifdef CASS_MV_PC_VERSION
	uint16 tempx,tempy,tempdot;
        int16 tempvalue;
	uint16 sum=0,sumvalue=0,x=0;
	int scanline;
	int width=bmpinfoarray[18]+bmpinfoarray[19]*255;
	int height=bmpinfoarray[22]+bmpinfoarray[23]*255;

	if(width%4)
		scanline=(width*8+31)/32*4;
	else
		scanline=width;
	
	while(x<256&&(image_data_packet_desc.point[x].w != 0))
	{
		tempx=image_data_packet_desc.point[x].x;
		tempy=image_data_packet_desc.point[x].y;
		tempdot=image_data_packet_desc.point[x].v;
		tempvalue=image_data_packet_desc.point[x].w;
		if(tempvalue < 0)
			tempvalue = - tempvalue;

		sum += tempvalue;
		if(raw_data[tempx*scanline+tempy]==tempdot)
		{
			sumvalue+=tempvalue;
		}

		x++;
	}

	cass_mv_match_percent = MATCH->percent;  //2014.03.26
	if(sum)
        	cass_mv_match_result =( sumvalue * 100/sum);
	else
		cass_mv_match_result = 0;

#else
    	uint16 tempx,tempy,tempdot;
	int16 tempvalue;
        uint16 sum=0,sumvalue=0,x=0;

	while(x<256&&(image_data_packet_desc.point[x].w != 0))
	{
		tempx=image_data_packet_desc.point[x].x;
		tempy=image_data_packet_desc.point[x].y;
		tempdot=image_data_packet_desc.point[x].v;
		tempvalue=image_data_packet_desc.point[x].w;
		if(tempvalue <0)
			tempvalue = - tempvalue;
		sum += tempvalue;

		if(raw_data[tempx*cass_mv_boarder_width+tempy]==tempdot)
		{
			sumvalue+=tempvalue;
		}
		x++;
	}
	
	if(sum)
        	cass_mv_match_result =( sumvalue * 100/sum);
	else
		cass_mv_match_result  = 0;
#endif
          return 1;
          }
		  ]]></Property>
        <Property name="Description">识别处理</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="色彩">
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Binary,ControlTactic,二值化,色彩">
      <BasicProperty>
        <Property name="ModuleName">BINARY</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">二值化</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="阈值" varname="threshold" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">128</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
uint8 BINARYControl(BINARYStruct *BINARY)
{
#ifdef CASS_MV_PC_VERSION
	int x,y,scanline,width,height;

	width=bmpinfoarray[18]+bmpinfoarray[19]*255;
	height=bmpinfoarray[22]+bmpinfoarray[23]*255;
	
	if(width%4)//bmp宽度不为4要补0
		scanline=(width*8+31)/32*4;
	else
		scanline=width;
	for(x=0;x<scanline*height;x++)
	{
		if(raw_data[x]>BINARY->threshold)
		{
			out_data[x]=255;
			raw_data[x]=255;
		}
		else
		{
			out_data[x]=0;
			raw_data[x]=0;
		}
	}

	Save_File(BINARY->index,height,width);	
#else
    u16 x,y;
	
	for(y=0;y<cass_mv_boarder_height;y++)
		for(x=0;x<cass_mv_boarder_width;x++)
		{
			if(out_data[y*cass_mv_boarder_width+x]<BINARY->threshold)
				out_data[y*cass_mv_boarder_width+x]=0;			
			else
				out_data[y*cass_mv_boarder_width+x]=255;
		}
	
#endif
	return 1;
}
  ]]>    </Property>
        <Property name="Description">二值化</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.OstuBinary,ControlTactic,最优二值化,色彩">
      <BasicProperty>
        <Property name="ModuleName">OSTUBINARY</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">最优二值化</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
          // 最优二值化函数
          uint8 OSTUBINARYControl(OSTUBINARYStruct *OSTUBINARY)
          {
          #ifdef CASS_MV_PC_VERSION
          int x,y,i,j;
          int height,width,scanline,thresh_value;
          double piexlsum,greyscale;
          float piexlcount[255]={0};
          float piexlpercent[255]={0};
          float w0,w1,u0tmp,u1tmp,u0,u1,u,deltaTmp,deltaMax;

          thresh_value=0;
          greyscale=255;
          deltaMax=0;

          width=bmpinfoarray[18]+bmpinfoarray[19]*256;
          height=bmpinfoarray[22]+bmpinfoarray[23]*256;
          piexlsum=width*height;

          if(width%4)
          scanline=(width*8+31)/32*4;
          else
          scanline=width;

          for (y=0;y<height;y++)
          for (x=0;x<width;x++)
          {
          piexlcount[(int)raw_data[y*scanline+x]]++;//每级灰度的像素个数
          }

          for(i=0;i<greyscale;i++)
          {
          piexlpercent[i]=(1.0*piexlcount[i])/(1.0*piexlsum);//每级灰度的像素占总像素数比率
          }

          for(i=0;i<greyscale;i++)//阈值扫描
          {
          w0=w1=u0tmp=u1tmp=u0=u1=u=deltaTmp=0;
          for(j=0;j<greyscale;j++)
          {
          if(j<i)
          {
          w0+=piexlpercent[j];//前景像素占总像素比率
          u0tmp+=j*piexlpercent[j];//前景像素灰度平均值
          }
          else
          {
          w1+=piexlpercent[j];//背景像素占总像素比率
          u1tmp+=j*piexlpercent[j];//背景像素灰度平均值
          }
          }
          u0=u0tmp/w0;//前景像素灰度平均值
          u1=u1tmp/w1;//背景像素灰度平均值
          u=u0tmp+u1tmp;//所有像素灰度平均值
          deltaTmp=w0*pow((u0-u),2)+w1*pow((u1-u),2);//前景背景差距=w0(u0-u)^2+w1(u1-u)^2

          if(deltaTmp>deltaMax)//最大的deltaMax时，前景背景差异最大
          {
          deltaMax=deltaTmp;
          thresh_value=i;
          }
          }

          for (y=0;y<height;y++)
          {
          for (x=0;x<width;x++)
          {
          if(raw_data[y*scanline+x]<thresh_value)
          out_data[y*scanline+x]=0;
          else
          out_data[y*scanline+x]=255;
          }
          }

          memcpy(raw_data,out_data,360000);
          Save_File(OSTUBINARY->index,height,width);
          #else

          #endif
          return 0;
          }
		  ]]></Property>
        <Property name="Description">大津法最优二值化</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.AntiColor,ControlTactic,反转颜色,色彩">
      <BasicProperty>
        <Property name="ModuleName">ANTICOLOR</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">反转颜色</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 反转颜色函数
uint8 ANTICOLORControl(ANTICOLORStruct *ANTICOLOR)
{
#ifdef CASS_MV_PC_VERSION
	int x,y,sum;
    int width,height,scanline;

	width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

	for (y=0 ;y<height;y++)
    {
		for (x=0;x<width;x++)
          {
          raw_data[y*scanline+x]=255-raw_data[y*scanline+x];
          }
          }
          Save_File(ANTICOLOR->index,height,width);
          #else

          #endif
          return 0;
          }
       ]]> </Property>
        <Property name="Description">反转颜色</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.GrayScaleStretch,ControlTactic,灰度拉伸,色彩">
      <BasicProperty>
        <Property name="ModuleName">GRAYSCALESTRETCH</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">灰度拉伸</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="原灰度范围下界" varname="left_gray_in" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">50</Property>
        <Property name="原灰度范围上界" varname="left_gray_out" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="目的灰度范围下界" varname="right_gray_in" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">20</Property>
        <Property name="目的灰度范围上界" varname="right_gray_out" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">200</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		//灰度拉伸函数
uint8 GRAYSCALESTRETCHControl(GRAYSCALESTRETCHStruct*GRAYSCALESTRETCH)
{
#ifdef CASS_MV_PC_VERSION
	int x,y,sum;
    int width,height,scanline;
	unsigned char map[256]={0};
	double dTemp;
	
	width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

	for(x=0;x<256;x++)
	{
		if ( x < GRAYSCALESTRETCH->left_gray_in)
		{
			if ( fabs(GRAYSCALESTRETCH->left_gray_in - 0) > 0.0001 )
				dTemp = (float)GRAYSCALESTRETCH->left_gray_out / (float)GRAYSCALESTRETCH->left_gray_in * x;
			else
				dTemp = 0;
		}
		else if ( x <= GRAYSCALESTRETCH->right_gray_in )
		{
			if ( fabs(GRAYSCALESTRETCH->right_gray_in - GRAYSCALESTRETCH->left_gray_in) > 0.0001 )
				dTemp = (float)(GRAYSCALESTRETCH->right_gray_out - GRAYSCALESTRETCH->left_gray_out) / (float)(GRAYSCALESTRETCH->right_gray_in - GRAYSCALESTRETCH->left_gray_in) * (x - GRAYSCALESTRETCH->left_gray_in) + GRAYSCALESTRETCH->left_gray_out;
			else
				dTemp = x;
		}
		else
		{
			if ( fabs(GRAYSCALESTRETCH->right_gray_out - 255) > 0.0001 )
          dTemp = (float)(255 - GRAYSCALESTRETCH->right_gray_out) / (float)(255 - GRAYSCALESTRETCH->right_gray_in) * (x - GRAYSCALESTRETCH->right_gray_in) + GRAYSCALESTRETCH->right_gray_out;
          else
          dTemp = 255;
          }
          //map[x] = int(dTemp + 0.5);
          map[x] = (int)dTemp;
          }

          for (y=0 ;y<height;y++)
         {
		    for (x=0;x<width;x++)
           {
             out_data[y*scanline+x]=map[raw_data[y*scanline+x]];
           }
         }

          memcpy(raw_data,out_data,360000);
          Save_File(GRAYSCALESTRETCH->index,height,width);
          #else

          #endif
          return 0;
          }
       ]]> </Property>
        <Property name="Description">GRAYSCALESTRETCH</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.HiagramEqualization,ControlTactic,直方图均衡化,色彩">
      <BasicProperty>
        <Property name="ModuleName">HIAGRAM</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">直方图均衡化</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
          // 直方图均衡化函数
          uint8 HIAGRAMControl(HIAGRAMStruct *HIAGRAM)
          {
          #ifdef CASS_MV_PC_VERSION
          int x,y,scanline;
          int width,height,max,min;
          float p[256]={0},c[256]={0},count=0;
          int n[256]={0};

          width=bmpinfoarray[18]+bmpinfoarray[19]*256;
          height=bmpinfoarray[22]+bmpinfoarray[23]*256;

          if(width%4)
          scanline=(width*8+31)/32*4;
          else
          scanline=width;

          for (y=0;y<height;y++)
          {
          for (x=0;x<width;x++)
          {
          n[raw_data[y*scanline+x]]++;
          count++;
          }
          }
          for(x=0;x<256;x++)
          {
          p[x]=(float)n[x]/(float)(width*height);
          }

          for(x=0;x<256;x++)
          {
          for(y=0;y<=x;y++)
          {
          c[x]+=p[y];
          }
          }

          max=min=raw_data[0];
          for(y=0;y<height;y++)
          {
          for(x=0;x<width;x++)
          {
          if(max<raw_data[y*scanline+x])
          {
          max=raw_data[y*scanline+x];
          }
          else if(min>raw_data[y*scanline+x])
          {
          min=raw_data[y*scanline+x];
          }
          }
          }

          for(y=0;y<height;y++)
          {
          for(x=0;x<width;x++)
          {
          out_data[y*scanline+x]=c[raw_data[y*scanline+x]]*(max-min)+min;
          }
          }

          memcpy(raw_data,out_data,360000);
          Save_File(HIAGRAM->index,height,width);
          #else

          #endif
          return 0;
          }
        ]]></Property>
        <Property name="Description">HiagramEqualization</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="形态学">
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Denoising,ControlTactic,去噪,形态学">
      <BasicProperty>
        <Property name="ModuleName">DENOSING</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">去噪</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="去噪大小" varname="noise_size" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">1</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 去噪函数
uint8 DENOSINGControl(DENOSINGStruct *DENOSING)
{
#ifdef CASS_MV_PC_VERSION
	int x,y,sum,m,n;
    int width,height,scanline;
	int v[9];

	width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

	for (y=0 ;y<height;y++)
    {
		for (x=0;x<width;x++)
		{
			if(y==0||y==height-1)
				out_data[y*scanline+x]=raw_data[y*scanline+x];
			else if(x==0||x==width-1)
				out_data[y*scanline+x]=raw_data[y*scanline+x];
			else
			{
				if(raw_data[y*scanline+x]==0)
				{
					for( m = y-1; m<y+2; m++)
					{
						for( n = x-1;n<x+2; n++ )
						{
							if( raw_data[y*scanline+x]==0)
							{  
							   sum++;
							}
						}
					}                             //sum记录黑点的个数
					if(sum < 5 )
          raw_data[y*scanline+x]=255;
          }
          }
          }
          }
          Save_File(6, height,width);
          Save_File(DENOSING->index,height,width);
          #else

          #endif
          return 0;
          }
        ]]></Property>
        <Property name="Description">去噪</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.ZhangParallelFastThinning,ControlTactic,细化,形态学">
      <BasicProperty>
        <Property name="ModuleName">ZHANGTHIN</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">细化</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		
          // 细化函数
          uint8 ZHANGTHINControl(ZHANGTHINStruct *ZHANGTHIN)
          {
          #ifdef CASS_MV_PC_VERSION
          int neighbor[8];
          int x,y,i,k,np,sp;
          int width,height,scanline;
          int markNum=0;
          int loop=1;


          width=bmpinfoarray[18]+bmpinfoarray[19]*256;
          height=bmpinfoarray[22]+bmpinfoarray[23]*256;

          if(width%4)
          scanline=(width*8+31)/32*4;
          else
          scanline=width;

          while(loop)
          {
          loop=0;

          markNum=0;
          for(y=1;y<height-1;y++)
       {
           for(x=1;x<width-1;x++)
           {
              if(raw_data[y*scanline+x]==0 ) continue;
 
              neighbor[0]= raw_data[y*scanline+x+1] ;
              neighbor[1]= raw_data[(y-1)*scanline+x+1];
              neighbor[2]= raw_data[(y-1)*scanline+x];
              neighbor[3]= raw_data[(y-1)*scanline+x-1];
              neighbor[4]= raw_data[y*scanline+x-1];
              neighbor[5]= raw_data[(y+1)*scanline+x-1];
              neighbor[6]= raw_data[(y+1)*scanline+x];
              neighbor[7]= raw_data[(y+1)*scanline+x+1];
 
              np=(neighbor[0]+neighbor[1]+neighbor[2]+neighbor[3]+neighbor[4]+neighbor[5]+neighbor[6]+neighbor[7])/255;
              if(np<2 || np>6) continue;
 
              sp=0;
              for(i=1;i<8;i++)
              {
                  if(neighbor[i]-neighbor[i-1]==255)
                     sp++;
              }
              if(neighbor[0]-neighbor[7]==255)
                  sp++;            
              if(sp!=1) continue;
 
              if(neighbor[2]&neighbor[0]&neighbor[6]!=0)
                  continue;
              if(neighbor[0]&neighbor[6]&neighbor[4]!=0)
                  continue;

              out_data[y*scanline+x]=1;   
              markNum++;
              loop=1;
           }
       }

       if(markNum>0)
       {
           for(y=0;y<height;y++)
           {
              for(x=0;x<width;x++)
              {
                  if(out_data[y*scanline+x]==1)
                  {
                     raw_data[y*scanline+x]=0;
                  }
              }
           }
       }
      
        markNum=0;
       for(y=1;y<height-1;y++)
       {
           for(x=1;x<width-1;x++)
           {
              if(raw_data[y*scanline+x]==0 ) continue;
 
              neighbor[0]= raw_data[y*scanline+x+1] ;
              neighbor[1]= raw_data[(y-1)*scanline+x+1];
              neighbor[2]= raw_data[(y-1)*scanline+x];
              neighbor[3]= raw_data[(y-1)*scanline+x-1];
              neighbor[4]= raw_data[y*scanline+x-1];
              neighbor[5]= raw_data[(y+1)*scanline+x-1];
              neighbor[6]= raw_data[(y+1)*scanline+x];
              neighbor[7]= raw_data[(y+1)*scanline+x+1];
 
              np=(neighbor[0]+neighbor[1]+neighbor[2]+neighbor[3]+neighbor[4]+neighbor[5]+neighbor[6]+neighbor[7])/255;
              if(np<2 || np>6) continue;
 
              sp=0;
              for(i=1;i<8;i++)
              {
                  if(neighbor[i]-neighbor[i-1]==255)
                     sp++;
              }
              if(neighbor[0]-neighbor[7]==255)
                  sp++;
              if(sp!=1) continue;
 
              if(neighbor[2]&neighbor[0]&neighbor[4]!=0)
                  continue;
              if(neighbor[2]&neighbor[6]&neighbor[4]!=0)
                  continue;
 
             out_data[y*scanline+x]=1;   
              markNum++;
              loop=1;
           }
       }
 
        if(markNum>0)
       {
           for(y=0;y<height;y++)
           {
              for(x=0;x<width;x++)
          {
          if(out_data[y*scanline+x]==1)
          {
          raw_data[y*scanline+x]=0;
          }
          }
          }
          }

          }
          Save_File(ZHANGTHIN->index,height,width);
          #else

          #endif
          return 0;
          }
       ]]> </Property>
        <Property name="Description">Zhang并行快速细化算法/ZhangParallelFastThinning</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Dialate,ControlTactic,膨胀,形态学">
      <BasicProperty>
        <Property name="ModuleName">DIALATE</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">膨胀</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="膨胀强度" varname="length" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">3</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
          // 膨胀函数
          uint8 DIALATEControl(DIALATEStruct *DIALATE)
          {
          #ifdef CASS_MV_PC_VERSION
          int scanline,k,i,j;
          int flag;
          unsigned char pix[5];

          int width=bmpinfoarray[18]+bmpinfoarray[19]*255;
          int height=bmpinfoarray[22]+bmpinfoarray[23]*255;

          if(width%4)
          scanline=(width*8+31)/32*4;
          else
          scanline=width;

          for(i=1;i<height-1;i++)                                     
          {
          for(j=1;j<width-1;j++)
          {
          flag=1;
          pix[0]=raw_data[i*scanline+j];
          pix[1]=raw_data[i*scanline+j-2];
          pix[2]=raw_data[i*scanline+j-1];
          pix[3]=raw_data[i*scanline+j+1];
          pix[4]=raw_data[i*scanline+j];

          for(k=0;k<5;k++)
          {
          if((pix[0]==255)||(pix[k]==255))
          {
          flag=0;
          break;
          }
          if(flag==0)
          {
          break;
          }
          }
          if(flag==0)
          out_data[i*scanline+j]=0;
          else
          out_data[i*scanline+j]=255;
          }
          }
          memcpy(raw_data,out_data,360000);
          Save_File(DIALATE->index,height,width);
          #else
          u8 k;
          u16 i,j;
          u8 flag;
          u8 pix[5];

          for(i=0;i<cass_mv_boarder_width;i++)//没考虑边缘
          {
          for(j=0;j<cass_mv_boarder_width;j++)
          {
          flag=1;
          pix[0]=out_data[i*cass_mv_boarder_width+j];
          pix[1]=out_data[i*cass_mv_boarder_width+j-2];
          pix[2]=out_data[i*cass_mv_boarder_width+j-1];
          pix[3]=out_data[i*cass_mv_boarder_width+j+1];
          pix[4]=out_data[i*cass_mv_boarder_width+j];

          for(k=0;k<5;k++)
          {
          if((pix[0]==255)||(pix[k]==255))
          {
          flag=0;
          break;
          }
          if(flag==0)
          {
          break;
          }
          }
          if(flag==0)
          temp_data[i*cass_mv_boarder_width+j]=0;
          else
          temp_data[i*cass_mv_boarder_width+j]=255;
          }
          }
          memcpy(out_data,temp_data,cass_mv_boarder_width*cass_mv_boarder_height);
          #endif
          return 0;
          }
        ]]></Property>
        <Property name="Description">膨胀</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Erode,ControlTactic,腐蚀,形态学">
      <BasicProperty>
        <Property name="ModuleName">ERODE</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">腐蚀</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="腐蚀强度" varname="length" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">3</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
        
uint8 ERODEControl(ERODEStruct *ERODE)
{
#ifdef CASS_MV_PC_VERSION
	int scanline,k,i,j;
	int flag;
    	unsigned char pix[5];
	
	 int width=bmpinfoarray[18]+bmpinfoarray[19]*255;
	 int height=bmpinfoarray[22]+bmpinfoarray[23]*255;
	
	if(width%4)
		scanline=(width*8+31)/32*4;
	else
		scanline=width;
	
	for(i=1;i<height-1;i++)                                          //edge problem...
    	{
        	for(j=1;j<width-1;j++)
		{
			flag=1;
			pix[0]=raw_data[i*scanline+j];
			pix[1]=raw_data[i*scanline+j-2];
			pix[2]=raw_data[i*scanline+j-1];
			pix[3]=raw_data[i*scanline+j+1];
			pix[4]=raw_data[i*scanline+j];
                   
			for(k=0;k<5;k++)
			{
				if((pix[0]==255)||(pix[k]==255))
				{
					flag=0;
					break;
				}
				if(flag==0)
				{
					break;
				}
			}
			if(flag==0)
				out_data[i*scanline+j]=255;		
			else	
				out_data[i*scanline+j]=0;			
		}
	}
 	memcpy(raw_data,out_data,360000);
	Save_File(ERODE->index,height,width);
#else
    u8 k;
	u16 i,j;
	u8 flag;
  u8 pix[5];

	for(i=0;i<cass_mv_boarder_width;i++)//没考虑边缘                                     
  {
		for(j=0;j<cass_mv_boarder_width;j++)
		{
			flag=1;
			pix[0]=out_data[i*cass_mv_boarder_width+j];
			pix[1]=out_data[i*cass_mv_boarder_width+j-2];
			pix[2]=out_data[i*cass_mv_boarder_width+j-1];
			pix[3]=out_data[i*cass_mv_boarder_width+j+1];
			pix[4]=out_data[i*cass_mv_boarder_width+j];
                   
			for(k=0;k<5;k++)
			{
				if((pix[0]==255)||(pix[k]==255))
				{
					flag=0;
					break;
				}
				if(flag==0)
				{
					break;
				}
			}
			if(flag==0)
				temp_data[i*cass_mv_boarder_width+j]=255;		
			else	
				temp_data[i*cass_mv_boarder_width+j]=0;			
		}
	}
	memcpy(out_data,temp_data,cass_mv_boarder_width*cass_mv_boarder_height);//注意边缘处理，无边缘情况。copy数据过去会错位
#endif
    return 1;	
}
     ]]> </Property>
        <Property name="Description">腐蚀处理</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.OpenOperation,ControlTactic,开操作,形态学">
      <BasicProperty>
        <Property name="ModuleName">OPENOPERATION</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">开操作</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="开强度" varname="length" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">3</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 开操作函数
uint8 OPENOPERATIONControl(OPENOPERATIONStruct *OPENOPERATION)
{
#ifdef CASS_MV_PC_VERSION
	
#else

#endif
          return 0;
}       
     ]]>   </Property>
        <Property name="Description">先腐蚀再膨胀</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.CloseOperation,ControlTactic,闭操作,形态学">
      <BasicProperty>
        <Property name="ModuleName">CLOSEOPERATION</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">闭操作</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="闭强度" varname="length" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">3</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 闭操作函数
uint8 CLOSEOPERATIONControl(CLOSEOPERATIONStruct *CLOSEOPERATION)
{
#ifdef CASS_MV_PC_VERSION
	
#else

#endif
          return 0;
}       
      ]]>  </Property>
        <Property name="Description">先膨胀再腐蚀</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="轮廓检测">
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Canny,ControlTactic,卡尼边缘检测,轮廓检测">
      <BasicProperty>
        <Property name="ModuleName">CANNY</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">卡尼边缘检测</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="低阈值" varname="low_threshold" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">30</Property>
        <Property name="高阈值" varname="high_threshold" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">70</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 卡尼边缘检测函数
uint8 CANNYControl(CANNYStruct *CANNY)
{
#ifdef CASS_MV_PC_VERSION
	
#else

#endif
          return 0;
}       
   ]]>     </Property>
        <Property name="Description">卡尼边缘检测</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.HoughLines,ControlTactic,霍夫直线检测,轮廓检测">
      <BasicProperty>
        <Property name="ModuleName">HOUGHLINES</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">霍夫直线检测</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 霍夫直线检测函数
uint8 HOUGHLINESControl(HOUGHLINESStruct *HOUGHLINES)
{
#ifdef CASS_MV_PC_VERSION
	
#else

#endif
          return 0;
}       
      ]]>  </Property>
        <Property name="Description">霍夫直线检测</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Hollowed,ControlTactic,掏空,轮廓检测">
      <BasicProperty>
        <Property name="ModuleName">HOLLOWED</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">掏空</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 掏空函数
uint8 HOLLOWEDControl(HOLLOWEDStruct *HOLLOWED)
{
#ifdef CASS_MV_PC_VERSION
	int x,y,sum;
    int width,height,scanline;
	int v[9];

	width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

	for (y=0 ;y<height;y++)
    {
		for (x=0;x<width;x++)
          {
          if(y==0||y==height-1)
          out_data[y*scanline+x]=raw_data[y*scanline+x];
          else if(x==0||x==width-1)
          out_data[y*scanline+x]=raw_data[y*scanline+x];
          else
          {
          if(raw_data[y*scanline+x]==0)
          {
          v[0] = raw_data[(y-1)*scanline+x-1];
          v[1] = raw_data[(y-1)*scanline+x];
          v[2] = raw_data[(y-1)*scanline+x+1];
          v[3] = raw_data[y*scanline+x-1];
          v[4] = raw_data[y*scanline+x];
          v[5] = raw_data[y*scanline+x+1];
          v[6] = raw_data[(y+1)*scanline+x-1];
          v[7] = raw_data[(y+1)*scanline+x];
          v[8] = raw_data[(y+1)*scanline+x+1];

          if(v[0]+v[1]+v[2]+v[3]+v[5]+v[6]+v[7]+v[8]==0)
          out_data[y*scanline+x]=255;
          }
          }
          }
          }
          memcpy(raw_data,out_data,360000);
          Save_File(HOLLOWED->index,height,width);
          #else

          #endif
          return 0;
          }
       ]]> </Property>
        <Property name="Description">掏空</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="特征点检测">
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.Harris,ControlTactic,哈里斯角点,特征点检测">
      <BasicProperty>
        <Property name="ModuleName">HARRIS</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">0</Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">哈里斯角点</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="低阈值" varname="low_threshold" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">30</Property>
        <Property name="高阈值" varname="high_threshold" type="System.Single" visible="yes" exp="" optype="" opvalue="" opnode="" relate="">70</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		// 哈里斯角点函数
uint8 HARRISControl(HARRISStruct *HARRIS)
{
#ifdef CASS_MV_PC_VERSION
	
#else

#endif
          return 0;
}       
       ]]> </Property>
        <Property name="Description">哈里斯角点</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="数值计算">
    <FDToolBoxItem Type="ControlTactic.GraphicsControl.CenterOfGravity,ControlTactic,区域重心,数值计算">
      <BasicProperty>
        <Property name="ModuleName">CENTEROFGRAVITY</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Output</Property>
        <Property name="InputName">
          <InputValue name="Input">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">
        </Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo"><![CDATA[
		//区域重心函数
uint8 CENTEROFGRAVITYControl(CENTEROFGRAVITYStruct *CENTEROFGRAVITY)
{
#ifdef CASS_MV_PC_VERSION
	int x,y,sum;
    int width,height,scanline;
	double s00=0,s10=0,s01=0;//0阶矩和1阶矩
	int Center_x=0,Center_y=0;//重心坐标

	width=bmpinfoarray[18]+bmpinfoarray[19]*256;
    height=bmpinfoarray[22]+bmpinfoarray[23]*256;

    if(width%4)
		scanline=(width*8+31)/32*4;
    else
		scanline=width;

	for (y=0 ;y<height;y++)
    {
		for (x=0;x<width;x++)
          {
          s00+=raw_data[y*scanline+x];
          s10+=x*raw_data[y*scanline+x];
          s01+=y*raw_data[y*scanline+x];
          }
          }

          Center_x=(s10/s00+0.5);
          Center_y=(s01/s00+0.5);
          raw_data[(Center_y-1)*scanline+Center_x-1]=128;
          raw_data[(Center_y-1)*scanline+Center_x]=128;
          raw_data[(Center_y-1)*scanline+Center_x+1]=128;
          raw_data[Center_y*scanline+Center_x-1]=128;
          raw_data[Center_y*scanline+Center_x]=128;
          raw_data[Center_y*scanline+Center_x+1]=128;
          raw_data[(Center_y+1)*scanline+Center_x-1]=128;
          raw_data[(Center_y+1)*scanline+Center_x]=128;
          raw_data[(Center_y+1)*scanline+Center_x+1]=128;
          Save_File(CENTEROFGRAVITY->index,height,width);
          #else

          #endif
          return 0;
          }
      ]]>  </Property>
        <Property name="Description">CenterOfGravity</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
</configuration>