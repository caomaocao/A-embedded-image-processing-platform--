<configuration>
  <Category DisplayName="变量">
    <FDToolBoxItem Type="ControlTactic.Constant,ControlTactic,常数,变量">
      <BasicProperty>
        <Property name="ModuleColor">255,238,232,170</Property>
        <Property name="ModuleSort">常数</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo">// 常量输入
uint8 CONControl(fp32 a)
{
    Push(&amp;paramStack,a);
	return 1;    
}</Property>
        <Property name="Description">指令名：ＣＯＮ

该块输出一个常数，可以作为其他功能块的输入。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.SystemConstant,ControlTactic,系统变量,变量">
      <BasicProperty>
        <Property name="ModuleColor">255,238,232,170</Property>
        <Property name="ModuleSort">系统变量</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo">
        </Property>
        <Property name="Description">指令名：ＳＹＳＶＡＲ

一些特殊的变量，可以作为其它运算的输入。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.InputValue,ControlTactic,输入变量,变量">
      <BasicProperty>
        <Property name="ModuleColor">255,238,232,170</Property>
        <Property name="ModuleSort">输入变量</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo">// 输入
uint8 LDControl(void *a)
{
    Push(&amp;paramStack,*((fp32 *)a));
	return 1;
}</Property>
        <Property name="Description">指令名：ＬＤ

该功能块可以引用控制点中没有作为输入输出脚的参数，如PID控制功能中的比例。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.OutputValue,ControlTactic,输出变量,变量">
      <BasicProperty>
        <Property name="ModuleColor">255,238,232,170</Property>
        <Property name="ModuleSort">输出变量</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo">// 输出
uint8 STControl(void *a)
{
    Pop(&amp;paramStack,a);
	return 1;
}</Property>
        <Property name="Description">指令名：ＳＴ

该变量可以对控制点中的参数进行赋值。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="数学运算">
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,加法,数学运算">
      <BasicProperty>
        <Property name="ModuleName">ADD</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">加法</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 加法函数
uint8 ADDControl(ADDStruct *ADD)
{
    fp32 en;
    fp32 add1;
    fp32 add2;
    fp32 result;

    result = 0;
    // 弹出后倒着赋值
    Pop(&amp;paramStack,&amp;add2);
    Pop(&amp;paramStack,&amp;add1);
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {
        result = add1 + add2;
		ADD-&gt;fLastVal = result;
    }
	else
	{// 保持上次的值
		result = ADD-&gt;fLastVal;
	}   
    Push(&amp;paramStack,result);
    return 1;    
}</Property>
        <Property name="Description">指令名：ＡＤＤ

把两个操作数相加。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,减法,数学运算">
      <BasicProperty>
        <Property name="ModuleName">SUB</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">减法</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 减法函数
uint8 SUBControl(SUBStruct *SUB)
{
    fp32 en;
    fp32 sub1;
    fp32 sub2;
    fp32 result;
    
    result = 0;    
    Pop(&amp;paramStack,&amp;sub2);
    Pop(&amp;paramStack,&amp;sub1);
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {
        result = sub1 - sub2;
		SUB-&gt;fLastVal = result;
    }
	else
	{// 保持上次的值
		result = SUB-&gt;fLastVal;
	}    
    Push(&amp;paramStack,result);
	return 1;               
}</Property>
        <Property name="Description">指令名：ＳＵＢ

把两个操作数相减。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,乘法,数学运算">
      <BasicProperty>
        <Property name="ModuleName">MUL</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">乘法</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 乘法
uint8 MULControl(MULStruct *MUL)
{
    fp32 en;
    fp32 mul1;
    fp32 mul2;
    fp32 result;
    
    result = 0;    
    Pop(&amp;paramStack,&amp;mul2);
    Pop(&amp;paramStack,&amp;mul1);
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {
        result = mul1 * mul2;
		MUL-&gt;fLastVal = result;
    }
	else
	{// 保持上次的值
		result = MUL-&gt;fLastVal;
	}   
    Push(&amp;paramStack,result);
	return 1;
}</Property>
        <Property name="Description">指令名：ＭＵＬ

把两个操作数相乘。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,除法,数学运算">
      <BasicProperty>
        <Property name="ModuleName">DIV</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">1</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">除法</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 除法
uint8 DIVControl(DIVStruct *DIV)
{
    fp32 en;
    fp32 div1;
    fp32 div2;
    fp32 result;
    
    result = 0;    
    Pop(&amp;paramStack,&amp;div2);
    Pop(&amp;paramStack,&amp;div1);
    Pop(&amp;paramStack,&amp;en);
	
    if(en != 0)
    {
    	if(div2 == 0)
			{
				ClearStack(&amp;paramStack);
				return 0;
			}
        result = div1 / div2;
		DIV-&gt;fLastVal = result;
    }
	else
	{// 保持上次的值
		result = DIV-&gt;fLastVal;
	}   
    Push(&amp;paramStack,result);
	return 1;
}</Property>
        <Property name="Description">指令名：ＤＩＶ

把两个操作数相除。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,乘幂,数学运算">
      <BasicProperty>
        <Property name="ModuleName">POWER</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">乘幂</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 乘幂
uint8 POWERControl(POWERStruct *POWER)
{
    fp32 en;
    fp32 pow1;
    fp32 pow2;
    fp32 result;
    
    result = 0;    
    Pop(&amp;paramStack,&amp;pow2);
    Pop(&amp;paramStack,&amp;pow1);
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {
        result = pow(pow1,pow2);
		POWER-&gt;fLastVal = result;
    }
	else
	{
		result = POWER-&gt;fLastVal;
	}   
    Push(&amp;paramStack,result);
	return 1;
}</Property>
        <Property name="Description">指令名：ＰＯＷＥＲ

IN0为底数，IN1为指数，进行乘幂运算。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,求余,数学运算">
      <BasicProperty>
        <Property name="ModuleName">MOD</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV,QUAT</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">1</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">求余</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值商" varname="fLastValPV" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的值余数" varname="fLastValQuat" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 求余 32位整数处理转成浮点型
uint8 MODControl(MODStruct *MOD)
{
    fp32 mod1;  // 被除数
    fp32 mod2;  // 除数
    fp32 en;
    fp32 pv;   // 余数
    fp32 quat;   // 商 
     
    pv = 0;
    quat = 0;   
    Pop(&amp;paramStack,&amp;mod2);
    Pop(&amp;paramStack,&amp;mod1);
    Pop(&amp;paramStack,&amp;en);

	
    if(en != 0)
    {
    	if(mod2 == 0)
			{
				ClearStack(&amp;paramStack);
				return 0;
			}
        pv = floor(mod1 / mod2); // 截取商
        quat = mod1 - pv * mod2; // 得到余数
		MOD-&gt;fLastValPV = pv;
		MOD-&gt;fLastValQuat = quat;
    }
	else
	{
		pv = MOD-&gt;fLastValPV ;
		quat = MOD-&gt;fLastValQuat;
	}

    Push(&amp;paramStack,quat);
    Push(&amp;paramStack,pv);
	return 1;
}</Property>
        <Property name="Description">指令名：ＭＯＤ

把两个操作数求余。如果输入In2等于0，则输出为无效，后续计算将不会计算。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,绝对值,数学运算">
      <BasicProperty>
        <Property name="ModuleName">ABS</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">绝对值</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 绝对值
uint8 ABSControl(ABSStruct *ABS)
{
    fp32 en;
    fp32 abs1;
    fp32 result;

    result = 0;

    Pop(&amp;paramStack,&amp;abs1);
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {
        result = fabs(abs1);
		ABS-&gt;fLastVal = result;
    }
	else
	{
		result = ABS-&gt;fLastVal;
	}
    Push(&amp;paramStack,result);
	return 1;
}</Property>
        <Property name="Description">指令名：ＡＢＳ

求输入的绝对值。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,反余弦,数学运算">
      <BasicProperty>
        <Property name="ModuleName">ACOS</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">反余弦</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 反余弦
uint8 ACOSControl(ACOSStruct *ACOS)
{
    fp32 en;
    fp32 acos1;
    fp32 result;

    result = 0;

    Pop(&amp;paramStack,&amp;acos1);
    Pop(&amp;paramStack,&amp;en);	

    if(en != 0)
    {
		if(acos1 &lt; -1 || acos1 &gt; 1)
		{
			ClearStack(&amp;paramStack);
			return 0;
		}
        result = acos(acos1);
    	ACOS-&gt;fLastVal = result;
    }
	else
	{
		result = ACOS-&gt;fLastVal;
	}
    Push(&amp;paramStack,result);
	return 1;
}</Property>
        <Property name="Description">指令名：ＡＣＯＳ

输入的反余弦。如果输入小于-1或大于1，则输出为无效，后续计算将不会计算。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,反正弦,数学运算">
      <BasicProperty>
        <Property name="ModuleName">ASIN</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">反正弦</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 反正弦
uint8 ASINControl(ASINStruct *ASIN)
{
    fp32 en;
    fp32 asin1;
    fp32 result;

    result = 0;

    Pop(&amp;paramStack,&amp;asin1);
    Pop(&amp;paramStack,&amp;en);

    if(en != 0)
    {
		if(asin1 &lt; -1 || asin1 &gt; 1)
		{// 使能才判断
			ClearStack(&amp;paramStack);
			return 0;
		}
        result = asin(asin1);
    	ASIN-&gt;fLastVal = result;
    }
	else
	{
		result = ASIN-&gt;fLastVal;
	}
    Push(&amp;paramStack,result);
	return 1;
}</Property>
        <Property name="Description">指令名：ＡＳＩＮ

输入的反正弦。如果输入小于-1或大于1，则输出为无效，后续计算将不会计算。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,反正切,数学运算">
      <BasicProperty>
        <Property name="ModuleName">ATAN</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">反正切</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 反正切
uint8 ATANControl(ATANStruct *ATAN)
{
    fp32 en;
    fp32 atan1;
    fp32 result;

    result = 0;

    Pop(&amp;paramStack,&amp;atan1);
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {
        result = atan(atan1);
    	ATAN-&gt;fLastVal = result;
    }
	else
	{
		result = ATAN-&gt;fLastVal;
	}
    Push(&amp;paramStack,result);
	return 1;
}</Property>
        <Property name="Description">指令名：ＡＳＩＮ

输入的反正切。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,余弦,数学运算">
      <BasicProperty>
        <Property name="ModuleName">COS</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">余弦</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 余弦
uint8 COSControl(COSStruct *COS)
{
    fp32 en;
    fp32 cos1;
    fp32 result;

    result = 0;

    Pop(&amp;paramStack,&amp;cos1);
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {
        result = cos(cos1);
    	COS-&gt;fLastVal = result;
    }
	else
	{
		result = COS-&gt;fLastVal;
	}
    Push(&amp;paramStack,result);
	return 1;
}</Property>
        <Property name="Description">指令名：ＣＯＳ

输入的余弦。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,正弦,数学运算">
      <BasicProperty>
        <Property name="ModuleName">SIN</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">正弦</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 正弦
uint8 SINControl(SINStruct *SIN)
{
    fp32 en;
    fp32 sin1;
    fp32 result;

    result = 0;

    Pop(&amp;paramStack,&amp;sin1);
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {
        result = sin(sin1);
   		SIN-&gt;fLastVal = result;
    }
	else
	{
		result = SIN-&gt;fLastVal;
	}
    Push(&amp;paramStack,result);
	return 1;
} </Property>
        <Property name="Description">指令名：ＳＩＮ

输入的正弦。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,正切,数学运算">
      <BasicProperty>
        <Property name="ModuleName">TAN</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">正切</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 正切
uint8 TANControl(TANStruct *TAN)
{
    fp32 en;
    fp32 tan1;
    fp32 result;

    result = 0;

    Pop(&amp;paramStack,&amp;tan1);
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {
        result = tan(tan1);
    	TAN-&gt;fLastVal = result;
    }
	else
	{
		result = TAN-&gt;fLastVal;
	}
    Push(&amp;paramStack,result);
	return 1;
}</Property>
        <Property name="Description">指令名：ＴＡＮ

输入的正切。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,指数,数学运算">
      <BasicProperty>
        <Property name="ModuleName">EXP</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">指数</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 指数
uint8 EXPControl(EXPStruct *EXP)
{
    fp32 en;
    fp32 exp1;
    fp32 result;

    result = 0;

    Pop(&amp;paramStack,&amp;exp1);
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {
        result = exp(exp1);
    	EXP-&gt;fLastVal = result;
    }
	else
	{
		result = EXP-&gt;fLastVal;
	}
    Push(&amp;paramStack,result);
	return 1;
}</Property>
        <Property name="Description">指令名：ＥＸＰ

输入的以e为底的幂。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,常用对数,数学运算">
      <BasicProperty>
        <Property name="ModuleName">LG</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN">1</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">常用对数</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 常用对数
uint8 LGControl(LGStruct *LG)
{
    fp32 en;
    fp32 lg1;
    fp32 result;

    result = 0;

    Pop(&amp;paramStack,&amp;lg1);
    Pop(&amp;paramStack,&amp;en);
	
    if(en != 0)
    {
		if(lg1 &lt;= 0)
		{
			ClearStack(&amp;paramStack);
			return 0;
		}

        result = log10(lg1);
    	LG-&gt;fLastVal = result;
    }
	else
	{
		result = LG-&gt;fLastVal;
	}
    Push(&amp;paramStack,result);
	return 1;
}</Property>
        <Property name="Description">指令名：ＬＧ

输入的以10为底的常用对数。如果输入小于或等于0，则输出为无效，后续计算将不会计算。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,自然对数,数学运算">
      <BasicProperty>
        <Property name="ModuleName">LN</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN">1</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">自然对数</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 自然对数
uint8 LNControl(LNStruct *LN)
{
    fp32 en;
    fp32 ln1;
    fp32 result;

    result = 0;

    Pop(&amp;paramStack,&amp;ln1);
    Pop(&amp;paramStack,&amp;en);	

    if(en != 0)
    {
		if(ln1 &lt;= 0)
		{
			ClearStack(&amp;paramStack);
			return 0;
		}
        result = log(ln1);
    	LN-&gt;fLastVal = result;
    }
	else
	{
		result = LN-&gt;fLastVal;
	}
    Push(&amp;paramStack,result);
	return 1;
}</Property>
        <Property name="Description">指令名：ＬＮ

求自然对数。如果输入小于或等于0，则输出为无效，后续计算将不会计算。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,平方根,数学运算">
      <BasicProperty>
        <Property name="ModuleName">SQRT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN">1</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">平方根</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 平方根
uint8 SQRTControl(SQRTStruct *SQRT)
{
    fp32 en;
    fp32 sqrt1;
    fp32 result;

    result = 0;

    Pop(&amp;paramStack,&amp;sqrt1);
    Pop(&amp;paramStack,&amp;en);
	
    if(en != 0)
    {
		if(sqrt1 &lt; 0)
		{
			ClearStack(&amp;paramStack);
			return 0;
		}
        result = sqrt(sqrt1);
    	SQRT-&gt;fLastVal = result;
    }
	else
	{
		result = SQRT-&gt;fLastVal;
	}
    Push(&amp;paramStack,result);
	return 1;
}</Property>
        <Property name="Description">指令名：ＳＱＲＴ

输入的平方根，如果输入小于0，则输出为无效，后续计算将不会计算。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,取整,数学运算">
      <BasicProperty>
        <Property name="ModuleName">TRUNC</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,255,255,255</Property>
        <Property name="ModuleSort">取整</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 取整
uint8 TRUNCControl(TRUNCStruct *TRUNC)
{
    fp32 en;
    fp32 trunc1;
    fp32 result;

    result = 0;

    Pop(&amp;paramStack,&amp;trunc1);
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {
        result = floor(trunc1);
    	TRUNC-&gt;fLastVal = result;
    }
	else
	{
		result = TRUNC-&gt;fLastVal;
	}
    Push(&amp;paramStack,result);
	return 1;
}    </Property>
        <Property name="Description">指令名：ＴＲＵＮＣ

得到小于或等于输入的一个最大整数。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="逻辑功能">
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,逻辑与,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">AND</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0xffffff</InputValue>
          <InputValue name="IN1">0xffffff</InputValue>
          <InputValue name="IN2">0xffffff</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">逻辑与</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="运算类型" varname="type" type="MyEnum" visible="yes" exp="0：位 1：字节 2：字 3：双字" optype="值优化" opvalue="" opnode="" relate="">位,字节,字,双字</Property>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 逻辑与
uint8 ANDControl(ANDStruct *AND)
{
     fp32 a,b,c,en;	 
	 uint32 ulA,ulB,ulC;
 
     Pop(&amp;paramStack,&amp;a);
     Pop(&amp;paramStack,&amp;b);
     Pop(&amp;paramStack,&amp;c);
     Pop(&amp;paramStack,&amp;en);
     if(en != 0)
     {
	 	ulA = (uint32)a;
		ulB = (uint32)b;
		ulC = (uint32)c;
        switch(AND-&gt;type)
        {
			#ifdef AND_type_0
            case 0:
            // 位处理
                ulA = ulA &amp; 0x1;
                ulB = ulB &amp; 0x1;
                ulC = ulC &amp; 0x1;
                break;
			#endif
			#ifdef AND_type_1      
            case 1:
            // 字节处理
                ulA = ulA &amp; 0xff;
                ulB = ulB &amp; 0xff;
                ulC = ulC &amp; 0xff;
                break;
			#endif
			#ifdef AND_type_2
            case 2:
            // 字处理
                ulA = ulA &amp; 0xffff;
                ulB = ulB &amp; 0xffff;
                ulC = ulC &amp; 0xffff;
                break;
			#endif
			#ifdef AND_type_3
            default:
            // 双字处理                         
                break;
			#endif            
        }
        AND-&gt;fLastVal = ulA &amp; ulB &amp; ulC;    	
    }	
    
    Push(&amp;paramStack,AND-&gt;fLastVal);
	return 1;     
}</Property>
        <Property name="Description">指令名：ＡＮＤ

求三个输入的相与的结果。根据选择类型的不同，可以是逻辑
与，字节与，字与，双字与。如果输入悬空，则该输入缺省是1
（或0xFF，0xFFFF，0xFFFFFFFF）。 </Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,逻辑或,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">OR</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">0</InputValue>
          <InputValue name="IN2">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">逻辑或</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="运算类型" varname="type" type="MyEnum" visible="yes" exp="0：位 1：字节 2：字 3：双字" optype="值优化" opvalue="" opnode="" relate="">位,字节,字,双字</Property>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 逻辑或
uint8 ORControl(ORStruct *OR)
{
     fp32 a,b,c,en;
     uint32 ulA,ulB,ulC;   

     Pop(&amp;paramStack,&amp;a);
     Pop(&amp;paramStack,&amp;b);
     Pop(&amp;paramStack,&amp;c);
     Pop(&amp;paramStack,&amp;en);
     if(en != 0)
     {
     	ulA = (uint32)a;
		ulB = (uint32)b;
		ulC = (uint32)c;
        switch(OR-&gt;type)
         {
			#ifdef OR_type_0
            case 0:
            // 位处理
                ulA = ulA &amp; 0x1;
                ulB = ulB &amp; 0x1;
                ulC = ulC &amp; 0x1;
                break;
			#endif
			#ifdef OR_type_1     
            case 1:
            // 字节处理
                ulA = ulA &amp; 0xff;
                ulB = ulB &amp; 0xff;
                ulC = ulC &amp; 0xff;
                break;
			#endif
			#ifdef OR_type_2
            case 2:
            // 字处理
                ulA = ulA &amp; 0xffff;
                ulB = ulB &amp; 0xffff;
                ulC = ulC &amp; 0xffff;
                break;
			#endif
			#ifdef OR_type_3
            default:
            // 双字处理                         
                break;
			#endif               
        }
        OR-&gt;fLastVal = ulA | ulB | ulC;    	
    }	
    Push(&amp;paramStack,OR-&gt;fLastVal);
	return 1;
     
}</Property>
        <Property name="Description">指令名：ＯＲ

求三个输入的相或的结果。根据选择类型的不同，可以是逻辑
或，字节或，字或，双字或。如果输入悬空，则该输入缺省是
0。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,逻辑非,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">NOT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">逻辑非</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="运算类型" varname="type" type="MyEnum" visible="yes" exp="0：位 1：字节 2：字 3：双字" optype="值优化" opvalue="" opnode="" relate="">位,字节,字,双字</Property>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 逻辑非
uint8 NOTControl(NOTStruct *NOT)
{
     fp32 a,en;
     uint32 ulA;
        
     Pop(&amp;paramStack,&amp;a);
     Pop(&amp;paramStack,&amp;en);       
     if(en != 0)
     {
     	ulA = (uint32)a;
		ulA = ~ulA;   
        switch(NOT-&gt;type)
         {
		 	#ifdef NOT_type_0
            case 0:
            // 位处理
                ulA &amp;=  0x1;				                        
                break;
			#endif
			#ifdef NOT_type_1      
            case 1:
            // 字节处理
                ulA &amp;=  0xff;                                
                break;
			#endif
			#ifdef NOT_type_2
            case 2:
            // 字处理
                ulA &amp;=  0xffff;                                   
                break;
			#endif
			#ifdef NOT_type_3
            default:
            // 双字处理                                                
                break; 
			#endif           
        }
    	NOT-&gt;fLastVal = ulA;
    }
   Push(&amp;paramStack,NOT-&gt;fLastVal);
	return 1;         
} </Property>
        <Property name="Description">指令名：ＮＯＴ

求输入取非的结果。根据选择类型的不同，可以是逻辑非，字
节非，字非，双字非。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,逻辑异或,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">XOR</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">逻辑异或</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="运算类型" varname="type" type="MyEnum" visible="yes" exp="0：位 1：字节 2：字 3：双字" optype="值优化" opvalue="" opnode="" relate="">位,字节,字,双字</Property>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 逻辑异或
uint8 XORControl(XORStruct *XOR)
{
     fp32 a,b,en;
     uint32 ulA,ulB;

     Pop(&amp;paramStack,&amp;a);
     Pop(&amp;paramStack,&amp;b);
     Pop(&amp;paramStack,&amp;en);
     if(en != 0)
     {
     	ulA = (uint32)a;
		ulB = (uint32)b;   
         switch(XOR-&gt;type)
         {
		 	#ifdef XOR_type_0 
            case 0:
            // 位处理
                ulA = ulA &amp; 0x1;
                ulB = ulB &amp; 0x1;
                break;
			#endif
			#ifdef XOR_type_1      
            case 1:
            // 字节处理
                ulA = ulA &amp; 0xff;
                ulB = ulB &amp; 0xff;
                break;
			#endif
			#ifdef XOR_type_2
            case 2:
            // 字处理
                ulA = ulA &amp; 0xffff;
                ulB = ulB &amp; 0xffff;
                break;
			#endif
			#ifdef XOR_type_3
            default:
            // 双字处理                         
                break; 
			#endif             
        }
        XOR-&gt;fLastVal = ulA ^ ulB;    	
    }

    Push(&amp;paramStack,XOR-&gt;fLastVal);
	return 1;         
} </Property>
        <Property name="Description">指令名：ＸＯＲ

求两个输入的异或的结果。根据选择类型的不同，可以是逻辑
异或，字节异或，字异或，双字异或。如果输入悬空，则该输
入缺省是0。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,逻辑与非,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">NAND</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0xffffff</InputValue>
          <InputValue name="IN1">0xffffff</InputValue>
          <InputValue name="IN2">0xffffff</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">逻辑与非</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="运算类型" varname="type" type="MyEnum" visible="yes" exp="0：位 1：字节 2：字 3：双字" optype="值优化" opvalue="" opnode="" relate="">位,字节,字,双字</Property>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 逻辑与非
uint8 NANDControl(NANDStruct *NAND)
{
     fp32 a,b,c,en;
     uint32 ulA,ulB,ulC;   

     Pop(&amp;paramStack,&amp;a);
     Pop(&amp;paramStack,&amp;b);
     Pop(&amp;paramStack,&amp;c);
     Pop(&amp;paramStack,&amp;en);
     if(en != 0)
     {
     	ulA = (uint32)a;
		ulB = (uint32)b;
		ulC = (uint32)c;
		ulA = ~(ulA &amp; ulB &amp; ulC); 
        switch(NAND-&gt;type)
         {
		 	#ifdef 	NAND_type_0
            case 0:
            // 位处理                
				NAND-&gt;fLastVal = ulA &amp; 0x1;
                break;
			#endif
			#ifdef 	NAND_type_1     
            case 1:
            // 字节处理
                NAND-&gt;fLastVal = ulA &amp; 0xff;
                break;
			#endif
			#ifdef 	NAND_type_2
            case 2:
            // 字处理
                NAND-&gt;fLastVal = ulA &amp; 0xffff;
                break;
			#endif
			#ifdef 	NAND_type_3
            default:
            // 双字处理                         
                break;
			#endif               
        }            	
    }	
    Push(&amp;paramStack,NAND-&gt;fLastVal);
	return 1;        
} </Property>
        <Property name="Description">指令名：ＮＡＮＤ

求三个输入的相与后非的结果。根据选择类型的不同，可以是
逻辑与非，字节与非，字与非，双字与非。如果输入悬空，则
该输入缺省是1（或0xFF，0xFFFF，0xFFFFFFFF）。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,逻辑或非,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">NOR</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">0</InputValue>
          <InputValue name="IN2">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">逻辑或非</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="运算类型" varname="type" type="MyEnum" visible="yes" exp="0：位 1：字节 2：字 3：双字" optype="值优化" opvalue="" opnode="" relate="">位,字节,字,双字</Property>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 逻辑或非
uint8 NORControl(NORStruct *NOR)
{
     fp32 a,b,c,en;
     uint32 ulA,ulB,ulC;   

     Pop(&amp;paramStack,&amp;a);
     Pop(&amp;paramStack,&amp;b);
     Pop(&amp;paramStack,&amp;c);
     Pop(&amp;paramStack,&amp;en);
     if(en != 0)
     {
     	ulA = (uint32)a;
		ulB = (uint32)b;
		ulC = (uint32)c;
		ulA = ~(ulA | ulB | ulC); 
        switch(NOR-&gt;type)
         {
		 	#ifdef NOR_type_0
            case 0:
            // 位处理
                NOR-&gt;fLastVal = ulA &amp; 0x1;
                break;
			#endif
			#ifdef NOR_type_1      
            case 1:
            // 字节处理
                NOR-&gt;fLastVal = ulA &amp; 0xff;
                break;
			#endif
			#ifdef NOR_type_2 
            case 2:
            // 字处理
                NOR-&gt;fLastVal = ulA &amp; 0xffff;
                break;
			#endif
			#ifdef NOR_type_3 
            default:
            // 双字处理                         
                break;
			#endif              
        }           	
    }	
    Push(&amp;paramStack,NOR-&gt;fLastVal);
	return 1;  
}</Property>
        <Property name="Description">指令名：ＮＯＲ

求三个输入的相或后非的结果。根据选择类型的不同，可以是
逻辑与非，字节与非，字与非，双字与非。如果输入悬空，则
该输入缺省是0。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,两输入ON有效或门,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">QOR2</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">0</InputValue>
          <InputValue name="IN2">0</InputValue>
          <InputValue name="IN3">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">两输入ON有效或门</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 两输入ON有效或门
uint8 QOR2Control(QOR2Struct *QOR2)
{
     fp32 a,b,c,d,en;
     uint8 count;

     Pop(&amp;paramStack,&amp;a);
     Pop(&amp;paramStack,&amp;b);
     Pop(&amp;paramStack,&amp;c);
     Pop(&amp;paramStack,&amp;d);
     Pop(&amp;paramStack,&amp;en);
     if(en != 0)
     {
        count = 0;
        if(a != 0)
            count++;
        if(b != 0)
            count++;
        if(c != 0)
            count++;
        if(d != 0)
            count++;

        if(count &gt;= 2)
            QOR2-&gt;fLastVal = 1;
        else
            QOR2-&gt;fLastVal = 0;
    }

     Push(&amp;paramStack,QOR2-&gt;fLastVal); 
	 return 1;       
}</Property>
        <Property name="Description">指令名：ＱＯＲ２

在四个输入中至少有两个输入是非0，输出是1，否则输出0。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,三输入ON有效或门,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">QOR3</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">0</InputValue>
          <InputValue name="IN2">0</InputValue>
          <InputValue name="IN3">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">三输入ON有效或门</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 三输入ON有效或门
uint8 QOR3Control(QOR3Struct *QOR3)
{
     fp32 a,b,c,d,en;
     uint8 count;
        
     Pop(&amp;paramStack,&amp;a);
     Pop(&amp;paramStack,&amp;b);
     Pop(&amp;paramStack,&amp;c);
     Pop(&amp;paramStack,&amp;d);
     Pop(&amp;paramStack,&amp;en);

     if(en != 0)
     {
        count = 0;
        if(a != 0)
           count++;
        if(b != 0)
           count++;
        if(c != 0)
           count++;
        if(d != 0)
           count++;
        if(count &gt;= 3)
            QOR3-&gt;fLastVal = 1;
        else
            QOR3-&gt;fLastVal = 0;
    }
	
     Push(&amp;paramStack,QOR3-&gt;fLastVal);  
	 return 1;      
}</Property>
        <Property name="Description">指令名：ＱＯＲ３

在四个输入中至少有三个输入是非0，输出是1，否则输出0。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,三输入不一致,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">DISP3</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">0</InputValue>
          <InputValue name="IN2">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">三输入不一致</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="运算类型" varname="type" type="MyEnum" visible="yes" exp="0：位 1：字节 2：字 3：双字" optype="" opvalue="" opnode="" relate="">位,字节,字,双字</Property>
        <Property name="上次的输出" varname="lastValue" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 三输入不一致
uint8 DISP3Control(DISP3Struct *DISP3)
{
	 fp32 a,b,c,en;	       
	    
	 Pop(&amp;paramStack,&amp;a);
	 Pop(&amp;paramStack,&amp;b);
	 Pop(&amp;paramStack,&amp;c);
	 Pop(&amp;paramStack,&amp;en);

    if(en != 0)
    {
        if(a != b &amp;&amp; a != c &amp;&amp; b!= c)
         {
            DISP3-&gt;lastValue = 1;   // 不相同为1
         }
         else
         {
            DISP3-&gt;lastValue = 0;   // 相同为0
         }       
     } 
     
     Push(&amp;paramStack,DISP3-&gt;lastValue);
	 return 1;
}</Property>
        <Property name="Description">指令名：ＤＩＳＰ３

该算法可有3个输入，1个输出。若在延时时间过后3个输入不一
致，那么输出OUT被设置为1，持续一个周期，否则为0。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,开关,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">SWIT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">0</InputValue>
          <InputValue name="SW">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">开关</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="运算类型" varname="type" type="MyEnum" visible="yes" exp="0：位 1：字节 2：字 3：双字" optype="值优化" opvalue="" opnode="" relate="">位,字节,字,双字</Property>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 开关
uint8 SWITControl(SWITStruct *SWIT)
{
     fp32 a,b,c,d,en;
	 uint32 ulA,ulB;   
     Pop(&amp;paramStack,&amp;c);  // SW
     Pop(&amp;paramStack,&amp;b);  // 输入1
     Pop(&amp;paramStack,&amp;a);  // 输入0
     Pop(&amp;paramStack,&amp;en);  // SW

     d = 0;
     if(en != 0)
     {
	 	ulA = (uint32)a;
		ulB = (uint32)b;   
        switch(SWIT-&gt;type)
         {
		 	#ifdef SWIT_type_0
            case 0:
            // 位处理
                ulA &amp;=  0x1;
                ulB &amp;=  0x1;                        
                break;
			#endif
			#ifdef SWIT_type_1     
            case 1:
            // 字节处理
                ulA &amp;=  0xff;
                ulB &amp;=  0xff;                                
                break;
			#endif
			#ifdef SWIT_type_2
            case 2:
            // 字处理
                ulA &amp;=  0xffff;
                ulB &amp;=  0xffff;                                    
                break;
			#endif
			#ifdef SWIT_type_3
            default:
            // 双字处理                                                  
                break;
			#endif 
        }// switch
        switch((uint8)c)
        {                
            case 1:
            // sw为1时,输入1        
                SWIT-&gt;fLastVal = ulB;          
                break;  
            default:// sw为其它时,输入0 
				SWIT-&gt;fLastVal = ulA;
                break;
        }
    }	
        
    Push(&amp;paramStack,SWIT-&gt;fLastVal);
	return 1;         
} </Property>
        <Property name="Description">指令名：ＳＷＩＴ

如果SW为1，则输出为输入IN1，否则输出为输入IN0。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,定长度脉冲,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">PULSE</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">定长度脉冲</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="脉冲宽度" varname="cycle" type="System.Int32" visible="yes" exp="定长脉冲宽度，以毫秒为单位。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="上次控制的时间" varname="lastTimeRec" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的输入" varname="lastInValue" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的输出" varname="lastOutValue" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 定长脉冲 
uint8 PULSEControl(PULSEStruct *PULSE)
{
     fp32 a,en;
	 uint32 timerInterval;  // 时间跨度
	 // 时间处理
	 if(timerCount &lt; PULSE-&gt;lastTimeRec)
	 {
	 	  timerInterval = 0xffffffff - PULSE-&gt;lastTimeRec + timerCount;
	 }
	 else
	 {
	 	  timerInterval = timerCount - PULSE-&gt;lastTimeRec;
	 }

     Pop(&amp;paramStack,&amp;a);  // 当前值
     Pop(&amp;paramStack,&amp;en);

	 if(en != 0)
	 {     
		if(PULSE-&gt;lastOutValue == 1)
		{// 已产生高电平
			if(timerInterval &gt;= PULSE-&gt;cycle)
	         {// 脉冲宽度到
			 	 PULSE-&gt;lastOutValue = 0; // 至少持续一个执行周期
			 }
		}
		else
		{
			 if(PULSE-&gt;lastInValue == 0 &amp;&amp; a != 0)
	         {// 上升沿
			 	 PULSE-&gt;lastOutValue = 1;
				 PULSE-&gt;lastTimeRec = timerCount;
			 }		 
		}
	 }     
     PULSE-&gt;lastInValue = a; // 记录上次输入值
	 Push(&amp;paramStack,PULSE-&gt;lastOutValue);
	 return 1;      
}</Property>
        <Property name="Description">指令名：ＰＵＬＳＥ

该逻辑算法用于在IN输入从OFF变成ON状态时，在输出端提供一
个固定长度的脉冲输出。输出脉冲的宽度由参数脉冲宽度决
定，如果脉冲宽度小或等于一个执行周期，宽度就等于一个执
行周期。如果一个脉冲还没完成，另一个输出脉冲不能被产
生。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,最大时限脉冲,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">MAXPL</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">最大时限脉冲</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="脉冲宽度" varname="cycle" type="System.Int32" visible="yes" exp="最大时限脉冲宽度，以毫秒为单位。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="上次控制的时间" varname="lastTimeRec" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的输入" varname="lastInValue" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的输出" varname="lastOutValue" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 最大脉冲
uint8 MAXPLControl(MAXPLStruct *MAXPL)
{
     fp32 a,en;
	 uint32 timerInterval;  // 时间跨度
	 // 时间处理
	 if(timerCount &lt; MAXPL-&gt;lastTimeRec)
	 {
	 	  timerInterval = 0xffffffff - MAXPL-&gt;lastTimeRec + timerCount;
	 }
	 else
	 {
	 	  timerInterval = timerCount - MAXPL-&gt;lastTimeRec;
	 }

     Pop(&amp;paramStack,&amp;a);  // 输入值
     Pop(&amp;paramStack,&amp;en);

    if(en != 0)
    {
        if(MAXPL-&gt;lastOutValue != 0)
        {// 产生脉冲
            if((timerInterval &gt;= MAXPL-&gt;cycle) || a == 0)
            {// 时间到或输入为0,输出为0
                MAXPL-&gt;lastOutValue = 0;
            }            			
        }
		else
		{// 没产生脉冲则一直检测
			if(MAXPL-&gt;lastInValue == 0 &amp;&amp; a != 0)
	        {// 上升沿
	            MAXPL-&gt;lastOutValue = 1;   // 产生脉冲
	            MAXPL-&gt;lastTimeRec = timerCount;                
	        }
		}
        MAXPL-&gt;lastInValue = a; // 记录上次输入值
    }	
     
     Push(&amp;paramStack,MAXPL-&gt;lastOutValue);
	 return 1;
                 
}</Property>
        <Property name="Description">指令名：ＭＡＸＰＬ

该逻辑算法当IN输入从OFF变成ON状态时，用于在输出端给出一
脉冲输出。若输入的ON状态大于脉冲宽度，输出脉冲就会中
止。由参数脉冲宽度决定最大输出脉冲宽度。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,最小时限脉冲,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">MINPL</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">最小时限脉冲</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="脉冲宽度" varname="cycle" type="System.Int32" visible="yes" exp="最小时限脉冲宽度，以毫秒为单位。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="上次控制的时间" varname="lastTimeRec" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的输入" varname="lastInValue" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的输出" varname="lastOutValue" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 最小脉冲
uint8 MINPLControl(MINPLStruct *MINPL)
{
     fp32 a,d,en;
	 uint32 timerInterval;  // 时间跨度
	 // 时间处理
	 if(timerCount &lt; MINPL-&gt;lastTimeRec)
	 {
	 	  timerInterval = 0xffffffff - MINPL-&gt;lastTimeRec + timerCount;
	 }
	 else
	 {
	 	  timerInterval = timerCount - MINPL-&gt;lastTimeRec;
	 }

     Pop(&amp;paramStack,&amp;a);  // 当前值
     Pop(&amp;paramStack,&amp;en);  // 当前值

    if(en != 0)
    {
        if(MINPL-&gt;lastOutValue != 0)
        {// 产生脉冲
            if(timerInterval &gt;= MINPL-&gt;cycle &amp;&amp; a == 0)
            {// 输入为0并且宽度到
                MINPL-&gt;lastOutValue = 0;
            }          
        }
		else
		{
			if(MINPL-&gt;lastInValue == 0 &amp;&amp; a != 0)
	        {
			 	MINPL-&gt;lastOutValue = 1;
				MINPL-&gt;lastTimeRec = timerCount; 
			}
		}
        MINPL-&gt;lastInValue = a; // 记录上次输入值                         
     }
     Push(&amp;paramStack, MINPL-&gt;lastOutValue);
	 return 1;   
}</Property>
        <Property name="Description">指令名：ＭＩＮＰＬ

该逻辑算法在当IN输入OFF变成ON状态时，用于在输出产生一个
脉冲，若IN的ON状态小于脉冲宽度，那么输出脉冲就扩展到定
时间隔结束时，参数脉冲宽度规定最小输出脉冲宽度。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,等于比较,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">EQU</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">等于比较</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 等于比较
uint8 EQUControl(EQUStruct *EQU)
{
    fp32 a;
    fp32 b;
    fp32 en;    
    Pop(&amp;paramStack,&amp;b);   // IN1
    Pop(&amp;paramStack,&amp;a);   // IN0
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {
        if(a == b)
        {
            EQU-&gt;fLastVal = 1;
        }
        else
        {
            EQU-&gt;fLastVal = 0;
        }
    }	
    Push(&amp;paramStack,EQU-&gt;fLastVal);
	return 1;
}</Property>
        <Property name="Description">指令名：ＥＱＵ

如果（IN0-IN1）的绝对值等于0，那么OUT=ON ，否则OUT=OFF,
即判断IN0和IN1是否相等。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,不等于比较,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">UEQU</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">不等于比较</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 不等于比较
uint8 UEQUControl(UEQUStruct *UEQU)
{
    fp32 a;
    fp32 b;
    fp32 en;    
    Pop(&amp;paramStack,&amp;b);   // IN1
    Pop(&amp;paramStack,&amp;a);   // IN0
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {
        if(a != b)
        {
            UEQU-&gt;fLastVal = 1;
        }
        else
        {
            UEQU-&gt;fLastVal = 0;
        }
    }	
    Push(&amp;paramStack,UEQU-&gt;fLastVal);
	return 1;
}</Property>
        <Property name="Description">指令名：ＵＥＱＵ

如果（IN0-IN1）的绝对值不等于0，那么OUT=ON； 否则
OUT=OFF。即判断IN0和IN1是否不相等。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,大于比较,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">GT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">大于比较</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 大于比较
uint8 GTControl(GTStruct *GT)
{
    fp32 a;
    fp32 b;
    fp32 en;    
    Pop(&amp;paramStack,&amp;b);
    Pop(&amp;paramStack,&amp;a);
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {
        if(a &gt; b)
        {
            GT-&gt;fLastVal = 1;
        }
        else
        {
            GT-&gt;fLastVal = 0;
        }
    }

    Push(&amp;paramStack,GT-&gt;fLastVal);
	return 1;
}</Property>
        <Property name="Description">指令名：ＧＴ

如果（IN0&gt;IN1）那么OUT=ON ；否则，如果（IN0&lt;=IN1），那
么OUT=OFF。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,小于比较,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">LT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">小于比较</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 小于比较
uint8 LTControl(LTStruct *LT)
{
    fp32 a;
    fp32 b;
    fp32 en;    
    Pop(&amp;paramStack,&amp;b);
    Pop(&amp;paramStack,&amp;a);
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {
        if(a &lt; b)
        {
            LT-&gt;fLastVal = 1;
        }
        else
        {
            LT-&gt;fLastVal = 0;
        }
    }	
    Push(&amp;paramStack,LT-&gt;fLastVal);
	return 1;
}</Property>
        <Property name="Description">指令名：ＬＴ

如果（IN0&lt;IN1）那么OUT=ON；否则，如果（IN0&gt;=IN1），那么
OUT=OFF。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,延时,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">DELAY</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">延时</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="延时时间" varname="cycle" type="System.Int32" visible="yes" exp="延时时间长度，以毫秒为单位。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="上次控制的时间" varname="lastTimeRec" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的输出" varname="lastOutValue" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// DELAY,时间没到一直保持上次的值,到点后才等于输入值
uint8 DELAYControl(DELAYStruct *DELAY)
{
    fp32 a,en;
	uint32 timerInterval;  // 时间跨度
	 // 时间处理
	 if(timerCount &lt; DELAY-&gt;lastTimeRec)
	 {
	 	  timerInterval = 0xffffffff - DELAY-&gt;lastTimeRec + timerCount;
	 }
	 else
	 {
	 	  timerInterval = timerCount - DELAY-&gt;lastTimeRec;
	 }

    Pop(&amp;paramStack,&amp;a);
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {
        if(timerInterval &gt;= DELAY-&gt;cycle)
        {// 到点
            DELAY-&gt;lastOutValue = a;
            DELAY-&gt;lastTimeRec = timerCount;    
        }        
    }

    Push(&amp;paramStack,DELAY-&gt;lastOutValue); 
	return 1; 
}</Property>
        <Property name="Description">指令名：ＤＥＬＡＹ

把输入信号IN延时一个指定时间，如果在延时时间内改变，则
以最后一次改变有效。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,ON延时,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">ONDLY</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">ON延时</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="延时时间" varname="cycle" type="System.Int32" visible="yes" exp="ON延时时间长度，以毫秒为单位。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="上次控制的时间" varname="lastTimeRec" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的输出" varname="lastOutValue" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="OFF-&gt;ON标志" varname="onSign" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的输入" varname="lastInValue" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// ON延时,OFF-&gt;ON延时保持,其它情况输出等于输入
uint8 ONDLYControl(ONDLYStruct *ONDLY)
{
    fp32 in,en;
	uint32 timerInterval;  // 时间跨度
	 // 时间处理
	 if(timerCount &lt; ONDLY-&gt;lastTimeRec)
	 {
	 	  timerInterval = 0xffffffff - ONDLY-&gt;lastTimeRec + timerCount;
	 }
	 else
	 {
	 	  timerInterval = timerCount - ONDLY-&gt;lastTimeRec;
	 }

    Pop(&amp;paramStack,&amp;in);
    Pop(&amp;paramStack,&amp;en);

    if(en != 0)
    {
        // 是否开启定时器
        if(ONDLY-&gt;onSign == 0)
        {// 没开时
            if(ONDLY-&gt;lastInValue == 0 &amp;&amp; in == 1)
            {// OFF-&gt;ON
                ONDLY-&gt;onSign = 1;
                ONDLY-&gt;lastTimeRec = timerCount;  // 开始计时       
            }
        }
        else
        {// 开启时
            if(timerInterval &gt;= ONDLY-&gt;cycle)
            {// 时间延时到
                ONDLY-&gt;onSign = 0;  // 开启关闭
				ONDLY-&gt;lastOutValue = in;
            }
        }       
        // 保存上次的输入值
        ONDLY-&gt;lastInValue = in;
    }
    Push(&amp;paramStack,ONDLY-&gt;lastOutValue);
	return 1;
}</Property>
        <Property name="Description">指令名：ＯＮＤＬＹ

该逻辑算法用于当输入信号从OFF变成ON状态时，把IN端的输入
信号延时。当输入状态从OFF变成ON时，启动一个内部定时器递
减由参数延迟时间所规定的延时时间，定时时间到时，再次对
IN输入监视，如果它仍为ON，那么OUT输出就为ON。当输入状态
变到OFF时，OUT输出立即置成OFF，定时器关闭。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,OFF延时,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">OFFDLY</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">OFF延时</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="延时时间" varname="cycle" type="System.Int32" visible="yes" exp="OFF延时时间长度，以毫秒为单位。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="上次控制的时间" varname="lastTimeRec" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的输出" varname="lastOutValue" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="ON-&gt;OFF标志" varname="offSign" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的输出" varname="lastInValue" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// OFF延时,ON-&gt;OFF延时保持,其它情况输出等于输入
uint8 OFFDLYControl(OFFDLYStruct *OFFDLY)
{
    fp32 in,en;
	uint32 timerInterval;  // 时间跨度
	 // 时间处理
	 if(timerCount &lt; OFFDLY-&gt;lastTimeRec)
	 {
	 	  timerInterval = 0xffffffff - OFFDLY-&gt;lastTimeRec + timerCount;
	 }
	 else
	 {
	 	  timerInterval = timerCount - OFFDLY-&gt;lastTimeRec;
	 }

    Pop(&amp;paramStack,&amp;in);
    Pop(&amp;paramStack,&amp;en);

    if(en != 0)
    {
        // 是否开启定时器
        if(OFFDLY-&gt;offSign == 0)
        {// 没开时
            if(OFFDLY-&gt;lastInValue == 1 &amp;&amp; in == 0)
            {// ON-&gt;OFF
                OFFDLY-&gt;offSign = 1;
                OFFDLY-&gt;lastTimeRec = timerCount;  // 开始计时      
            }
        }
        else
        {// 开启时
            if(timerInterval &gt;= OFFDLY-&gt;cycle)
            {// 时间延时到
                OFFDLY-&gt;offSign = 0;  // 开启关闭
				OFFDLY-&gt;lastOutValue = in;
            }
        }       
        // 保存
        OFFDLY-&gt;lastInValue = in;
    }
    Push(&amp;paramStack,OFFDLY-&gt;lastOutValue);
	return 1;
}</Property>
        <Property name="Description">指令名：ＯＦＦＤＬＹ

该算法用于输入信号从ON变成OFF状态时把IN端的输入信号延
时。当输入状态从ON变成OFF时，启动一个内部定时器递减由参
数延迟时间所规定的延时时间。当定时时间到时，再次监视IN
输入，如果它仍为OFF，则OUT输出置成OFF，当输入状态变成ON
时，OUT输出立即置成ON，并且定时器关闭。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,看门狗,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">WTDOG</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">看门狗</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="复位时间" varname="cycle" type="System.Int32" visible="yes" exp="看门狗延迟时间，以毫秒为单位。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="上次控制的时间" varname="lastTimeRec" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的输入" varname="lastInValue" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="是否触发" varname="isTrigger" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// WTDOG 周期之内触发了输出0,到点时还没触发输出1
uint8 WTDOGControl(WTDOGStruct *WTDOG)
{
    fp32 in,en;
	uint32 timerInterval;  // 时间跨度
	 // 时间处理
	 if(timerCount &lt; WTDOG-&gt;lastTimeRec)
	 {
	 	  timerInterval = 0xffffffff - WTDOG-&gt;lastTimeRec + timerCount;
	 }
	 else
	 {
	 	  timerInterval = timerCount - WTDOG-&gt;lastTimeRec;
	 }

    Pop(&amp;paramStack,&amp;in);
    Pop(&amp;paramStack,&amp;en);

    if(en != 0)
    {           
        if(timerInterval &lt;= WTDOG-&gt;cycle)
        {// 时间之内
            if(WTDOG-&gt;isTrigger == 0)
            {// 没触发过判断触发
                if(WTDOG-&gt;lastInValue == 0 &amp;&amp; in == 1)
                {// 触发也就是喂狗了,就也不用复位了
                    WTDOG-&gt;fLastVal = 0;
                    WTDOG-&gt;isTrigger = 1;   
                }
            }           
        }
        else
        {// 时间到点,重新计时           
            if(WTDOG-&gt;isTrigger == 0)
            {// 到点还没触发
                WTDOG-&gt;fLastVal = 1;
            }
            // 重新计时
            WTDOG-&gt;lastTimeRec = timerCount;
			WTDOG-&gt;isTrigger = 0;// 清除触发
        }
    }
    Push(&amp;paramStack,WTDOG-&gt;fLastVal);
	return 1;
}</Property>
        <Property name="Description">指令名：ＷＴＤＯＧ

输入端IN在给定时间之内如果没有得到触发（由0向1跳变），
输出端OUT则变成高电平1，否则OUT为电平0。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,RS触发器,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">RS</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="R">0</InputValue>
          <InputValue name="S">0</InputValue>
          <InputValue name="SW">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">RS触发器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的输出" varname="lastValue" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// RS触发器
uint8 RSControl(RSStruct *RS)
{
    fp32 r;
    fp32 s,en;
    fp32 sw;
    Pop(&amp;paramStack,&amp;sw);
    Pop(&amp;paramStack,&amp;s);
    Pop(&amp;paramStack,&amp;r);   
    Pop(&amp;paramStack,&amp;en);
    if(en != 0)
    {   
        if(r == 0 &amp;&amp; s == 1)
        {
             RS-&gt;lastValue = 0;
        }
        else if(r == 1 &amp;&amp; s == 1)
        {
             RS-&gt;lastValue = sw;
        }
        else if(r == 1 &amp;&amp; s == 0)
        {
             RS-&gt;lastValue = 1;
        }        
    }	   
    Push(&amp;paramStack,RS-&gt;lastValue);
	return 1;
}</Property>
        <Property name="Description">指令名：ＲＳ

该算法具有三个输入，当S端和R端同时为ON时，输出等于第三端输入SW，真值表如下：
R	S	SW	输出	
OFF	ON	无关	OFF	
ON	ON	无关	SW	
ON	OFF	无关	ON	
OFF	OFF	无关	保持</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,变化检测,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">CHDCT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
          <InputValue name="IN1">0</InputValue>
          <InputValue name="IN2">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">变化检测</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="上次的输入1" varname="lastIn1" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的输入2" varname="lastIn2" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的输入3" varname="lastIn3" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的值" varname="fLastVal" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 变化检测
uint8 CHDCTControl(CHDCTStruct *CHDCT)
{
     fp32 fIn1,fIn2,fIn3,fEn;
	 uint32 timerInterval;  // 时间跨度	

     Pop(&amp;paramStack,&amp;fIn3);
     Pop(&amp;paramStack,&amp;fIn2);
     Pop(&amp;paramStack,&amp;fIn1);
     Pop(&amp;paramStack,&amp;fEn);

     if(fEn != 0)
     {
         if((CHDCT-&gt;lastIn1 != fIn1) || (CHDCT-&gt;lastIn2 != fIn2) || (CHDCT-&gt;lastIn3 != fIn3))		 
		 {
		 	CHDCT-&gt;fLastVal = 1;
		 }
		 else
		 {
		 	CHDCT-&gt;fLastVal = 0;
		 }    
     }
	 
     Push(&amp;paramStack,CHDCT-&gt;fLastVal);
	 return 1;
}</Property>
        <Property name="Description">指令名：ＣＨＤＣＴ

如果三个输入中的任何一个跟上一个周期不一致，输出
高电平，持续一个周期。如果任何一个输入悬空，则结果与该
输入无关。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Modules,ControlTactic,选通器,逻辑功能">
      <BasicProperty>
        <Property name="ModuleName">SELECT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">CH0,CH1,CH2,CH3,CH4,CH5,CH6,CH7</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="IN0">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,0,255,255</Property>
        <Property name="ModuleSort">选通器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="通道1低限选通" varname="cIsMin1" type="System.Boolean" visible="yes" exp="通道1低限是否有效。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="通道1高限选通" varname="cIsMax1" type="System.Boolean" visible="yes" exp="通道1高限是否有效。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="通道1低限" varname="fMin1" type="System.Single" visible="yes" exp="通道1低限值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="通道1高限" varname="fMax1" type="System.Single" visible="yes" exp="通道1高限值。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="通道2低限选通" varname="cIsMin2" type="System.Boolean" visible="yes" exp="通道2低限是否有效。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="通道2高限选通" varname="cIsMax2" type="System.Boolean" visible="yes" exp="通道2高限是否有效。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="通道2低限" varname="fMin2" type="System.Single" visible="yes" exp="通道2低限值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="通道2高限" varname="fMax2" type="System.Single" visible="yes" exp="通道2高限值。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="通道3低限选通" varname="cIsMin3" type="System.Boolean" visible="yes" exp="通道3低限是否有效。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="通道3高限选通" varname="cIsMax3" type="System.Boolean" visible="yes" exp="通道3高限是否有效。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="通道3低限" varname="fMin3" type="System.Single" visible="yes" exp="通道3低限值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="通道3高限" varname="fMax3" type="System.Single" visible="yes" exp="通道3高限值。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="通道4低限选通" varname="cIsMin4" type="System.Boolean" visible="yes" exp="通道4低限是否有效。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="通道4高限选通" varname="cIsMax4" type="System.Boolean" visible="yes" exp="通道4高限是否有效。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="通道4低限" varname="fMin4" type="System.Single" visible="yes" exp="通道4低限值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="通道4高限" varname="fMax4" type="System.Single" visible="yes" exp="通道4高限值。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="通道5低限选通" varname="cIsMin5" type="System.Boolean" visible="yes" exp="通道5低限是否有效。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="通道5高限选通" varname="cIsMax5" type="System.Boolean" visible="yes" exp="通道5高限是否有效。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="通道5低限" varname="fMin5" type="System.Single" visible="yes" exp="通道5低限值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="通道5高限" varname="fMax5" type="System.Single" visible="yes" exp="通道5高限值。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="通道6低限选通" varname="cIsMin6" type="System.Boolean" visible="yes" exp="通道6低限是否有效。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="通道6高限选通" varname="cIsMax6" type="System.Boolean" visible="yes" exp="通道6高限是否有效。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="通道6低限" varname="fMin6" type="System.Single" visible="yes" exp="通道6低限值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="通道6高限" varname="fMax6" type="System.Single" visible="yes" exp="通道6高限值。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="通道7低限选通" varname="cIsMin7" type="System.Boolean" visible="yes" exp="通道7低限是否有效。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="通道7高限选通" varname="cIsMax7" type="System.Boolean" visible="yes" exp="通道7高限是否有效。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="通道7低限" varname="fMin7" type="System.Single" visible="yes" exp="通道7低限值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="通道7高限" varname="fMax7" type="System.Single" visible="yes" exp="通道7高限值。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="通道8低限选通" varname="cIsMin8" type="System.Boolean" visible="yes" exp="通道8低限是否有效。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="通道8高限选通" varname="cIsMax8" type="System.Boolean" visible="yes" exp="通道8高限是否有效。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="通道8低限" varname="fMin8" type="System.Single" visible="yes" exp="通道8低限值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="通道8高限" varname="fMax8" type="System.Single" visible="yes" exp="通道8高限值。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="上次的值" varname="fLastVal1" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的值" varname="fLastVal2" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的值" varname="fLastVal3" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的值" varname="fLastVal4" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的值" varname="fLastVal5" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的值" varname="fLastVal6" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的值" varname="fLastVal7" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的值" varname="fLastVal8" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 选择是否在范围内,是返回1,不是返回0
fp32 SELECTisIN(uint8 cMin,uint8 cMax,fp32 fMin,fp32 fMax,fp32 fIn)
{
      // 根据是否起作用,上下限可分为四种情况
     if(cMin == 1 &amp;&amp; cMax == 1)
     {// 都起作用
         if(fMin &lt; fIn &amp;&amp; fMax &gt; fIn)
         {
            return 1;
         }
         else
         {
            return 0;
         }       
     }
     else if(cMin == 1 &amp;&amp; cMax == 0)
     {// 只有下限起作用
         if(fMin &lt; fIn)
         {
            return 1;
         }
         else
         {
            return 0;
         }
     }
     else if(cMin == 0 &amp;&amp; cMax == 1)
     {// 只有上限起作用
         if(fMax &gt; fIn)
         {
            return 1;
         }
         else
         {
            return 0;
         }
     }
     else 
     {// 都不起作用
          return 1;
     }
      
}
// 选通器
uint8 SELECTControl(SELECTStruct *SELECT)
{
     fp32 fIn,fEn;

     Pop(&amp;paramStack,&amp;fIn);
     Pop(&amp;paramStack,&amp;fEn);

     if(fEn != 0)
     {
         SELECT-&gt;fLastVal1 = SELECTisIN(SELECT-&gt;cIsMin1,SELECT-&gt;cIsMax1,SELECT-&gt;fMin1,SELECT-&gt;fMax1,fIn);
		 
		 SELECT-&gt;fLastVal2 = SELECTisIN(SELECT-&gt;cIsMin2,SELECT-&gt;cIsMax2,SELECT-&gt;fMin2,SELECT-&gt;fMax2,fIn);
         
         SELECT-&gt;fLastVal3 = SELECTisIN(SELECT-&gt;cIsMin3,SELECT-&gt;cIsMax3,SELECT-&gt;fMin1,SELECT-&gt;fMax3,fIn);
         
         SELECT-&gt;fLastVal4 = SELECTisIN(SELECT-&gt;cIsMin4,SELECT-&gt;cIsMax4,SELECT-&gt;fMin4,SELECT-&gt;fMax4,fIn);
         
         SELECT-&gt;fLastVal5 = SELECTisIN(SELECT-&gt;cIsMin5,SELECT-&gt;cIsMax5,SELECT-&gt;fMin5,SELECT-&gt;fMax5,fIn);
         
         SELECT-&gt;fLastVal6 = SELECTisIN(SELECT-&gt;cIsMin6,SELECT-&gt;cIsMax6,SELECT-&gt;fMin6,SELECT-&gt;fMax6,fIn);
        
         SELECT-&gt;fLastVal7 = SELECTisIN(SELECT-&gt;cIsMin7,SELECT-&gt;cIsMax7,SELECT-&gt;fMin7,SELECT-&gt;fMax7,fIn);
         
         SELECT-&gt;fLastVal8 = SELECTisIN(SELECT-&gt;cIsMin8,SELECT-&gt;cIsMax8,SELECT-&gt;fMin8,SELECT-&gt;fMax8,fIn);
         
     }
	 Push(&amp;paramStack,SELECT-&gt;fLastVal1);
	 Push(&amp;paramStack,SELECT-&gt;fLastVal2); 
	 Push(&amp;paramStack,SELECT-&gt;fLastVal3); 
	 Push(&amp;paramStack,SELECT-&gt;fLastVal4); 
	 Push(&amp;paramStack,SELECT-&gt;fLastVal5); 
	 Push(&amp;paramStack,SELECT-&gt;fLastVal6); 
	 Push(&amp;paramStack,SELECT-&gt;fLastVal7); 
	 Push(&amp;paramStack,SELECT-&gt;fLastVal8);
	 return 1;	      
}</Property>
        <Property name="Description">指令名：ＳＥＬＥＣＴ

选通器是针对不同的输入产生不同的输出。它最多可以
输出8个通道，每一个通道都有低限、高限。当输入在通道n低
限和高限的范围内时，通道n会产生一个高电平的输出。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="程序控制">
    <FDToolBoxItem Type="ControlTactic.JMP,ControlTactic,跳转,程序控制">
      <BasicProperty>
        <Property name="ModuleColor">
        </Property>
        <Property name="ModuleSort">跳转</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo">// 跳转
uint8 JMPControl(uint8 (*ptFun(void)))
{
     fp32 fIn;

     Pop(&amp;paramStack,&amp;fIn);
	 
	 if(fIn != 0)
	 {
	 	 (*ptFun)();
	 }
	 return 1;   
}</Property>
        <Property name="Description">指令名：ＪＭＰ

跳转到指定的功能块执行。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.JMP,ControlTactic,调用,程序控制">
      <BasicProperty>
        <Property name="ModuleColor">
        </Property>
        <Property name="ModuleSort">调用</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo">// 调用
uint8 CALLControl(uint8 (*ptFun(void)))
{
     fp32 fIn;

     Pop(&amp;paramStack,&amp;fIn);
	 
	 if(fIn != 0)
	 {
	 	 (*ptFun)();
	 }
	 return 1;   
}</Property>
        <Property name="Description">指令名：ＣＡＬＬ

调用指定的子策略。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.JMP,ControlTactic,返回,程序控制">
      <BasicProperty>
        <Property name="ModuleColor">
        </Property>
        <Property name="ModuleSort">返回</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo">// 返回
uint8 RETControl()
{
     fp32 fIn;

     Pop(&amp;paramStack,&amp;fIn);
	 if(fIn == 0)// 这里取反,因为外面还要取反
	 	return 1;
	 else
	 	return 0;    
}</Property>
        <Property name="Description">指令名：ＲＥＴ

返回</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Label,ControlTactic,注释,程序控制">
      <BasicProperty>
        <Property name="ModuleColor">
        </Property>
        <Property name="ModuleSort">注释</Property>
      </BasicProperty>
      <FunctionProperty />
      <OtherInfo>
        <Property name="CodeInfo">
        </Property>
        <Property name="Description">注释</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="算法支撑">
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,模拟输入,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">AI</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">RAW</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">模拟输入</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="测量值" varname="fPV" type="System.Single" visible="yes" exp="经过变换后的值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="设定值" varname="fSV" type="System.Single" visible="yes" exp="设定值，根据它可以产生偏差报警。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="原始值" varname="fRawVal" type="System.Single" visible="yes" exp="原始测量数据。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="是否进行量程转换" varname="isChange" type="System.Boolean" visible="yes" exp="是否进行工程单位转换。" optype="值优化" opvalue="" opnode="" relate="">false</Property>
        <Property name="工程单位低限" varname="fPVMin" type="System.Single" visible="yes" exp="变换值的低限。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="工程单位高限" varname="fPVMax" type="System.Single" visible="yes" exp="变换值的高限。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="原始数据低限" varname="fRawMin" type="System.Single" visible="yes" exp="输入的低限。" optype="特定值优化" opvalue="fRawMax" opnode="" relate="">0</Property>
        <Property name="原始数据高限" varname="fRawMax" type="System.Single" visible="yes" exp="输入的低限。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="报警低限" varname="fWarnL" type="System.Single" visible="yes" exp="变换值的低限报警值。" optype="" opvalue="" opnode="" relate="">10</Property>
        <Property name="发生低限报警" varname="isWarnL" type="System.Boolean" visible="yes" exp="变换值的低限报警标识。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="报警低低限" varname="fWarnLL" type="System.Single" visible="yes" exp="变换值的低低限报警值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="发生低低限报警" varname="isWarnLL" type="System.Boolean" visible="yes" exp="变换值的低低限报警标识。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="报警高限" varname="fWarnH" type="System.Single" visible="yes" exp="变换值的高限报警值。" optype="" opvalue="" opnode="" relate="">90</Property>
        <Property name="发生高限报警" varname="isWarnH" type="System.Boolean" visible="yes" exp="变换值的高限报警标识。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="报警高高限" varname="fWarnHH" type="System.Single" visible="yes" exp="变换值的高高限报警值。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="发生高高限报警" varname="isWarnHH" type="System.Boolean" visible="yes" exp="变换值的高高限报警标识。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="变化率" varname="fRation" type="System.Single" visible="yes" exp="以秒为单位的变化率，每个执行周期计算一次。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="发生变化率报警" varname="isRationWarn" type="System.Boolean" visible="yes" exp="变化率的报警标识。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="偏差" varname="fBias" type="System.Single" visible="yes" exp="偏差绝对值的高限。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="发生偏差报警" varname="isBiasWarn" type="System.Boolean" visible="yes" exp="偏差的报警标识。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="采样周期" varname="ulCycle" type="System.Int32" visible="yes" exp="控制回路的周期。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 模拟量输入
uint8 AIControl(AIStruct *AI)
{
    fp32 fRation,fBias,fTs,fPV; // 变化率,偏差
    Pop(&amp;paramStack,&amp;(AI-&gt;fRawVal));
    
	#ifdef AI_ulCycle_0
	if(AI-&gt;ulCycle == 0)
		AI-&gt;ulCycle = 1000;
	#endif	
	fTs = AI-&gt;ulCycle / (fp32)1000;
    AI-&gt;fRawVal = AI-&gt;fRawVal &lt; AI-&gt;fRawMin ? AI-&gt;fRawMin : AI-&gt;fRawVal;
	AI-&gt;fRawVal = AI-&gt;fRawVal &gt; AI-&gt;fRawMax ? AI-&gt;fRawMax : AI-&gt;fRawVal;
	#if defined AI_isChange_1 &amp;&amp; defined AI_fRawMin_NOTfRawMax
    if((AI-&gt;isChange != 0) &amp;&amp; (AI-&gt;fRawMin - AI-&gt;fRawMax != 0))	 
    {// 转换 最值不正确		
        fPV = ((AI-&gt;fRawVal - AI-&gt;fRawMin) / (AI-&gt;fRawMax - AI-&gt;fRawMin)) * 
        (AI-&gt;fPVMax - AI-&gt;fPVMin) + AI-&gt;fPVMin;        
    }
	#endif
	#if defined AI_isChange_0 || defined AI_fRawMin_fRawMax
    if(AI-&gt;isChange == 0 || AI-&gt;fRawMin == AI-&gt;fRawMax)
    {// 不转换      
        fPV = AI-&gt;fRawVal;      
    }
	#endif
	fPV = fPV &gt; AI-&gt;fPVMax ? AI-&gt;fPVMax : fPV;
	fPV = fPV &lt; AI-&gt;fPVMin ? AI-&gt;fPVMin : fPV; 
	// 低低限
	if(fPV &lt; AI-&gt;fWarnLL)       
        AI-&gt;isWarnLL = 1;       
    else
        AI-&gt;isWarnLL = 0;
    // 低限
    if(fPV &lt; AI-&gt;fWarnL)        
        AI-&gt;isWarnL = 1;        
    else
        AI-&gt;isWarnL = 0;
    // 高高限
    if(fPV &gt; AI-&gt;fWarnHH)       
        AI-&gt;isWarnHH = 1;       
    else
        AI-&gt;isWarnHH = 0;
    // 高限
    if(fPV &gt; AI-&gt;fWarnH)        
        AI-&gt;isWarnH = 1;        
    else
        AI-&gt;isWarnH = 0;
    // 变化率
    fRation = (fabs(fPV - AI-&gt;fPV)) / fTs;
    if(fRation &gt; AI-&gt;fRation)
         AI-&gt;isRationWarn = 1;
    else
         AI-&gt;isRationWarn = 0;
    // 偏差
    fBias = fabs(fPV - AI-&gt;fSV);
    if(fBias &gt; AI-&gt;fBias)
         AI-&gt;isBiasWarn = 1;
    else
         AI-&gt;isBiasWarn = 0;
    AI-&gt;fPV = fPV;

    Push(&amp;paramStack,fPV);
	return 1;
}</Property>
        <Property name="Description">指令名：ＡＩ

将原始测量数据IN作为裸数据进行量程变换处理后的结果输
出。输入处理的依据就是该算法的一些参数预定义值。同时这
里还进行报警处理。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,模拟输出,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">AO</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">OP</Property>
        <Property name="InputName">PV</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">模拟输出</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输出值" varname="fPV" type="System.Single" visible="yes" exp="经过变换后的值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="设定值" varname="fSV" type="System.Single" visible="yes" exp="设定值，根据它可以产生偏差报警。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="原始值" varname="fRawVal" type="System.Single" visible="yes" exp="原始测量数据。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="是否进行量程转换" varname="isChange" type="System.Boolean" visible="yes" exp="原始测量数据。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="工程单位低限" varname="fPVMin" type="System.Single" visible="yes" exp="变换值的低限。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="工程单位高限" varname="fPVMax" type="System.Single" visible="yes" exp="变换值的高限。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="原始数据低限" varname="fRawMin" type="System.Single" visible="yes" exp="输入的低限。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="原始数据高限" varname="fRawMax" type="System.Single" visible="yes" exp="输入的高限。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="报警低限" varname="fWarnL" type="System.Single" visible="yes" exp="变换值的低限报警值。" optype="" opvalue="" opnode="" relate="">10</Property>
        <Property name="发生低限报警" varname="isWarnL" type="System.Boolean" visible="yes" exp="变换值的低限报警标识。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="报警低低限" varname="fWarnLL" type="System.Single" visible="yes" exp="变换值的低低限报警值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="发生低低限报警" varname="isWarnLL" type="System.Boolean" visible="yes" exp="变换值的低低限报警标识。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="报警高限" varname="fWarnH" type="System.Single" visible="yes" exp="变换值的高限报警值。" optype="" opvalue="" opnode="" relate="">90</Property>
        <Property name="发生高限报警" varname="isWarnH" type="System.Boolean" visible="yes" exp="变换值的高限报警标识。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="报警高高限" varname="fWarnHH" type="System.Single" visible="yes" exp="变换值的高高限报警值。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="发生高高限报警" varname="isWarnHH" type="System.Boolean" visible="yes" exp="变换值的高高限报警标识。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="变化率" varname="fRation" type="System.Single" visible="yes" exp="以秒为单位的变化率，每个执行周期计算一次。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="发生变化率报警" varname="isRationWarn" type="System.Boolean" visible="yes" exp="变化率的报警标识。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="偏差" varname="fBias" type="System.Single" visible="yes" exp="偏差绝对值的高限。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="发生偏差报警" varname="isBiasWarn" type="System.Boolean" visible="yes" exp="偏差的报警标识。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="采样周期" varname="ulCycle" type="System.Int32" visible="yes" exp="控制回路的周期。" optype="" opvalue="" opnode="" relate="">1000</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 模拟量输出
uint8 AOControl(AOStruct *AO)
{
    fp32 fRation,fBias,fTs,fPV; // 变化率,偏差
    Pop(&amp;paramStack,&amp;(AO-&gt;fRawVal));
    
	#ifdef AO_ulCycle_0
	if(AO-&gt;ulCycle == 0)
		AO-&gt;ulCycle = 1000;
	#endif	
	fTs = AO-&gt;ulCycle / (fp32)1000;
    AO-&gt;fRawVal = AO-&gt;fRawVal &lt; AO-&gt;fRawMin ? AO-&gt;fRawMin : AO-&gt;fRawVal;
	AO-&gt;fRawVal = AO-&gt;fRawVal &gt; AO-&gt;fRawMax ? AO-&gt;fRawMax : AO-&gt;fRawVal;
	#if defined AO_isChange_1 &amp;&amp; defined AO_fRawMin_NOTfRawMax 
    if((AO-&gt;isChange != 0) &amp;&amp; (AO-&gt;fRawMin - AO-&gt;fRawMax != 0))	 
    {// 转换 最值不正确		
        fPV = ((AO-&gt;fRawVal - AO-&gt;fRawMin) / (AO-&gt;fRawMax - AO-&gt;fRawMin)) * 
        (AO-&gt;fPVMax - AO-&gt;fPVMin) + AO-&gt;fPVMin;        
    }
	#endif
	#if defined AO_isChange_0 || defined AO_fRawMin_fRawMax
    if(AO-&gt;isChange == 0 || AO-&gt;fRawMin == AO-&gt;fRawMax)
    {// 不转换      
        fPV = AO-&gt;fRawVal;      
    }
	#endif
	fPV = fPV &gt; AO-&gt;fPVMax ? AO-&gt;fPVMax : fPV;
	fPV = fPV &lt; AO-&gt;fPVMin ? AO-&gt;fPVMin : fPV; 
	// 低低限
	if(fPV &lt; AO-&gt;fWarnLL)       
        AO-&gt;isWarnLL = 1;       
    else
        AO-&gt;isWarnLL = 0;
    // 低限
    if(fPV &lt; AO-&gt;fWarnL)        
        AO-&gt;isWarnL = 1;        
    else
        AO-&gt;isWarnL = 0;
    // 高高限
    if(fPV &gt; AO-&gt;fWarnHH)       
        AO-&gt;isWarnHH = 1;       
    else
        AO-&gt;isWarnHH = 0;
    // 高限
    if(fPV &gt; AO-&gt;fWarnH)        
        AO-&gt;isWarnH = 1;        
    else
        AO-&gt;isWarnH = 0;
    // 变化率
    fRation = (fabs(fPV - AO-&gt;fPV)) / fTs;
    if(fRation &gt; AO-&gt;fRation)
         AO-&gt;isRationWarn = 1;
    else
         AO-&gt;isRationWarn = 0;
    // 偏差
    fBias = fabs(fPV - AO-&gt;fSV);
    if(fBias &gt; AO-&gt;fBias)
         AO-&gt;isBiasWarn = 1;
    else
         AO-&gt;isBiasWarn = 0;
    AO-&gt;fPV = fPV;

    Push(&amp;paramStack,fPV);
	return 1;
}</Property>
        <Property name="Description">指令名：ＡＯ

模拟输出是把输出进行转换成给定范围的数值。同时进行报警
处理。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,数字输入,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">DI</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">RAW</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">数字输入</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输出值" varname="cPV" type="MyEnum" visible="yes" exp="数字点处理后的结果。" optype="" opvalue="" opnode="" relate="">0,1</Property>
        <Property name="正/反动作" varname="isInvert" type="MyEnum" visible="yes" exp="表示该变量是否进行变换，如果是正动作，则测量值与原始测量值相同，如果是反动作，则测量值与原始测量值相反。" optype="值优化" opvalue="" opnode="" relate="">正动作,反动作</Property>
        <Property name="正常值" varname="cNormalVal" type="MyEnum" visible="yes" exp="正常测量值的数值1或0。" optype="" opvalue="" opnode="" relate="">0,1</Property>
        <Property name="报警值" varname="isWarn" type="MyEnum" visible="yes" exp="如果测量值不是正常值，则输出true(1)，否则输出fasle(0)。" optype="" opvalue="" opnode="" relate="">0,1</Property>
        <Property name="原始值" varname="cRawVal" type="MyEnum" visible="yes" exp="从现场采集的原始数据0或1。如果出现其它值，则认为是1。" optype="" opvalue="" opnode="" relate="">0,1</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 数字输入
uint8 DIControl(DIStruct* DI)
{   
	fp32 fIn; 
    Pop(&amp;paramStack,&amp;fIn);
	DI-&gt;cRawVal = fIn;
	#ifdef DI_isInvert_1
    if(DI-&gt;isInvert != 0)
    {// 反动作
        if(DI-&gt;cRawVal == 0)
            DI-&gt;cPV = 1;
        else
            DI-&gt;cPV = 0;
    }
	#endif
	#ifdef DI_isInvert_0
    if(DI-&gt;isInvert == 0)
        DI-&gt;cPV = DI-&gt;cRawVal;
	#endif
    // 报警
    if(DI-&gt;cPV != DI-&gt;cNormalVal)
        DI-&gt;isWarn = 1;
    Push(&amp;paramStack,DI-&gt;cPV);
	return 1;
}</Property>
        <Property name="Description">指令名：ＤＩ

数字输入点是连接在IO设备上的数字输入点进行处理的功能模
块，也可以作为内部数字中间点使用。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,数字输出,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">DO</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">OP</Property>
        <Property name="InputName">PV</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">数字输出</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输出" varname="cPV" type="MyEnum" visible="yes" exp="数字点处理后的结果。" optype="" opvalue="" opnode="" relate="">0,1</Property>
        <Property name="正/反动作" varname="isInvert" type="MyEnum" visible="yes" exp="表示该变量是否进行变换，如果是正动作，则测量值与原始测量值相同，如果是反动作，则测量值与原始测量值相反。" optype="值优化" opvalue="" opnode="" relate="">正动作,反动作</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 数字输出
uint8 DOControl(DOStruct* DO)
{
    fp32 fPV;
        
    Pop(&amp;paramStack,&amp;fPV);

	#ifdef DO_isInvert_1
    if(DO-&gt;isInvert != 0)
    {// 反动作
        if((uint8)fPV == 0)
            DO-&gt;cPV = 1;
        else
            DO-&gt;cPV = 0;
    }
	#endif
	#ifdef DO_isInvert_0
    if(DO-&gt;isInvert == 0)
        DO-&gt;cPV = (uint8)fPV;
	#endif

    Push(&amp;paramStack,DO-&gt;cPV);
	return 1;
}</Property>
        <Property name="Description">指令名：ＤＯ

数字输出点是连接在IO设备上的数字输出点进行处理的功能模
块，也可以作为内部数字中间点使用，它是计算后进行数字输
出的控制点。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,脉冲输入,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">PI</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">RAW</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">脉冲输入</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="工程单位转换因子" varname="fC1" type="System.Single" visible="yes" exp="工程单位转换参数，没有量纲。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="仪表系数" varname="fC2" type="System.Single" visible="yes" exp="每个工程单位的脉冲数，如对于某个质量流量计可能是每公斤脉冲数，如果仪表厂商提供每个脉冲工程单位计数系数K，如每个脉冲0．05公斤，则C2是K的倒数，即C2 = 1/K，如上例中C2 = 20。" optype="特定值优化" opvalue="0" opnode="" relate="">0</Property>
        <Property name="基本时间单位" varname="ucTBase" type="MyEnum" visible="yes" exp="时间转换系数，0表示秒，1表示分钟，2表示小时。" optype="值优化" opvalue="" opnode="" relate="">秒,分钟,小时</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 脉冲输入点
uint8 PIControl(PIStruct * PI)
{
    fp32 fIn;// 输入值
	fp32 fPV;// 输出值
	uint16 timeBase;

	#ifdef PI_fC2_0
	if(PI-&gt;fC2 == 0)
	{
		PI-&gt;fC2 = 1;
	}
	#endif

    Pop(&amp;paramStack,&amp;fIn);
	switch(PI-&gt;ucTBase)
	{
		#ifdef PI_ucTBase_1
		case 1:
			timeBase = 60;
			break;
		#endif
		#ifdef PI_ucTBase_2
		case 2:
			timeBase = 3600;
			break;
		#endif
		#ifdef PI_ucTBase_0
		default:
			timeBase = 1;
			break;
		#endif
	}
	fPV = PI-&gt;fC1 * timeBase * fIn / PI-&gt;fC2;
	Push(&amp;paramStack,fPV);
	return 1;
}</Property>
        <Property name="Description">指令名：ＰＩ

从现场读取各种信号，如涡轮型流量计，正位移量仪等，并把
输入信号转换成工程单位的流量信号或其他信号。该输入是现
场输入各种累计信号，为32位整数信号。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,纯滞后补偿器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">SMITH</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">IN</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">纯滞后补偿器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="时间常数T1" varname="ulT1" type="System.Int32" visible="yes" exp="被控对象的时间常数1。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
        <Property name="时间常数T2" varname="ulT2" type="System.Int32" visible="yes" exp="被控对象的时间常数2。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="滞后时间" varname="ulLagT" type="System.Int32" visible="yes" exp="被控对象的滞后时间。" optype="" opvalue="" opnode="" relate="">10000</Property>
        <Property name="补偿比例" varname="fK" type="System.Single" visible="yes" exp="补偿比例。" optype="" opvalue="" opnode="" relate="">1</Property>
        <Property name="采集周期" varname="ulTs" type="System.Int32" visible="yes" exp="控制回路的周期，以毫秒为单位。不能等于0，如果等于0，则使用缺省值1000毫秒。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
        <Property name="输入" varname="fPV" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上上次输出" varname="fMV_1" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次输出" varname="fMV" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输入队列" varname="queueIn" type="queue" visible="no" exp="" optype="" opvalue="" opnode="" relate="">NULL</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// SMITH补偿
uint8 SMITHControl(SMITHStruct *SMITH)
{
    uint32 qLength;  // 输出队列元素个数
    uint32 historyInNum;  // 输出必须保存的历史个数
    fp32 fPV_N_1; // 前第N-1个输入

    fp32 fMV;   // 输出
    fp32 temp,a,b,c;  // 计算二阶时的临时变量
    fp32 ulT1,ulT2,ulTs;
    fp32 fK;
    fp32 fPV_1;	// 上次输入
	fp32 fPV;  // 输入
    fp32 fMV_1;
    fp32 fMV_2;
	
	Pop(&amp;paramStack,&amp;fPV);

	#ifdef SMITH_ulT1_NOT0
	if(SMITH-&gt;ulT1 == 0)
    {// 至少为一阶对象,当为0时,用默认值1000
        SMITH-&gt;ulT1 = 1000;
    }
	#endif
	/*if(SMITH-&gt;ulT2 &lt;= 0)
    {// 至少为一阶对象,当为0时,用默认值1000
        SMITH-&gt;ulT2 = 1000;
    }*/
	#ifdef SMITH_ulTs_NOT0
    if(SMITH-&gt;ulTs == 0)
    {// 采样周期,当为0时,用默认值1000
        SMITH-&gt;ulTs = 1000;
    }
	#endif 
    // 读取参数
    ulT1 = (SMITH-&gt;ulT1 / (fp32)1000);
    ulT2 = (SMITH-&gt;ulT2 / (fp32)1000);
    ulTs = (SMITH-&gt;ulTs / (fp32)1000);
    fK = SMITH-&gt;fK;
    fMV_1 = SMITH-&gt;fMV;
    fMV_2 = SMITH-&gt;fMV_1;
    fPV_1 = SMITH-&gt;fPV;    
    
    // 输出队列处理
    if(SMITH-&gt;queueIn == NULL)
    {// 队列不存在时,初始化队列
        InitQueue(&amp;SMITH-&gt;queueIn);
    }
    qLength = QueueLength(SMITH-&gt;queueIn);

    historyInNum = (uint32)(SMITH-&gt;ulLagT / SMITH-&gt;ulTs);
    while(historyInNum &gt; qLength)
    {// 当队列个数不满时
        EnQueue(&amp;SMITH-&gt;queueIn,0);// 插入0
        qLength++;
    }
    while(historyInNum &lt; qLength)
    {// 当队列个数超出时
        DeQueue(&amp;SMITH-&gt;queueIn,&amp;fPV_N_1);// 删除最原始的数据
        qLength--;
    }

    DeQueue(&amp;SMITH-&gt;queueIn,&amp;fPV_N_1); // 取出第N个元素进行计算
    // 一阶算法不对,全采用二阶的好了
    /*if(ulT2 == 0)
    {// 当被控对象为一阶时
        
        fMV = (ulT1 / (ulT1 + ulTs)) * fMV_1 - (fK * (ulTs / (ulT1 + ulTs))) * (fPV_1 - fPV_N_1);               
            
        // 保存
        SMITH-&gt;fMV = fMV;   // 输出
        SMITH-&gt;fPV = fPV; // 输入
        EnQueue(&amp;SMITH-&gt;queueIn,fPV); // 输入队列
    }
    else
    {// 被控对象为二阶  */
        temp = (ulT1 * ulT2) + ulTs * (ulT1 + ulT2) + ulTs * ulTs;
        a = (2 * ulT1 * ulT2 + ulTs * (ulT1 + ulT2)) / temp;
        b = (ulT1 *ulT2) / temp;
        c = (fK * ulTs * ulTs) / temp;          
        
        fMV = a * fMV_1 - b * fMV_2 + c * (fPV_1 - fPV_N_1);
        // 保存
        SMITH-&gt;fMV = fMV;   // 输出
        SMITH-&gt;fMV_1 = fMV_1;
        SMITH-&gt;fPV = fPV; // 输入
        EnQueue(&amp;SMITH-&gt;queueIn,fPV); // 输入队列
    //}
	Push(&amp;paramStack,fMV);
	return 1;

}</Property>
        <Property name="Description">指令名：ＳＭＩＴＨ

在工业控制中，不少对象往往具有纯滞后的性质，它会导致控
制作用不及时，引起系统超调和振荡。因此可以用Smith预测器
来补偿。</Property>
        <Property name="OptimizeInfo">OPTIMISE_QUEUE</Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,滤波,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">FILT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">IN</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">滤波</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="滤波时间常数" varname="ulTF" type="System.Int32" visible="yes" exp="滤波时间，以毫秒为单位。如果滤波时间常数是0，则使用缺省值1。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
        <Property name="采样周期" varname="ulTs" type="System.Int32" visible="yes" exp="控制回路的周期，以毫秒为单位。不能等于0，如果等于0，则使用缺省值1000毫秒。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
        <Property name="上次的输出" varname="fLastPV" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 滤波
uint8 FILTControl(FILTStruct *FILT)
{
     fp32 fIn;
     fp32 fOut;
     fp32 fDelta;

	 #ifdef FILT_ulTs_0
     if(FILT-&gt;ulTs == 0)
     {
        FILT-&gt;ulTs = 1000;
     }
     #endif
     #ifdef FILT_ulTF_0
	 if(FILT-&gt;ulTF == 0)
     {
        FILT-&gt;ulTF = 1000;
     }
     #endif
    Pop(&amp;paramStack,&amp;fIn);
    fDelta = exp(-FILT-&gt;ulTs / FILT-&gt;ulTF);
    FILT-&gt;fLastPV = fDelta * FILT-&gt;fLastPV + (1 - fDelta) * fIn;
    Push(&amp;paramStack,FILT-&gt;fLastPV);
	return 1;	     
}</Property>
        <Property name="Description">指令名：ＦＩＬＴ

在有些时候要求输入量不能突变，如PID的设定值，出现阶跃变
化时，为了防止出现过大的变化，往往加一个前置滤波器，而
是具有一定惯性延迟的缓变量。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,一阶传递函数,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">TRANS</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">IN</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">一阶传递函数</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="参数A" varname="A" type="System.Single" visible="yes" exp="参数A。" optype="特定值优化" opvalue="0" opnode="" relate="">0</Property>
        <Property name="参数B" varname="B" type="System.Single" visible="yes" exp="参数B。" optype="特定值优化" opvalue="0" opnode="" relate="">10</Property>
        <Property name="参数C" varname="C" type="System.Single" visible="yes" exp="参数C。" optype="" opvalue="" opnode="" relate="">1</Property>
        <Property name="参数D" varname="D" type="System.Single" visible="yes" exp="参数D。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="采样周期" varname="Ts" type="System.Int32" visible="yes" exp="控制回路的周期，以毫秒为单位。不能等于0，如果等于0，则使用缺省值1000毫秒。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
        <Property name="中间临时变量" varname="Xk" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次输入" varname="Uk" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 一阶传递函数
uint8 TRANSControl(TRANSStruct *TRANS)
{   
    fp32 A,B,C,D,E,F,G,H,L,P;
    fp32 Uk,Uk_1,Xk,Xk_1,Yk;
	fp32 T;
	
	#ifdef TRANS_Ts_0
	if(TRANS-&gt;Ts == 0)
    {
        TRANS-&gt;Ts = 1000;
    }
    #endif
     
    T = TRANS-&gt;Ts / (fp32)1000;
   
    Pop(&amp;paramStack,&amp;Uk);
    A = TRANS-&gt;A;B = TRANS-&gt;B;C = TRANS-&gt;C;D = TRANS-&gt;D;
    Xk = TRANS-&gt;Xk;Uk_1 = TRANS-&gt;Uk;
    
	#if defined TRANS_A_0 &amp;&amp; defined TRANS_B_0    
    if(A == 0 &amp;&amp; B == 0)
    {
        B = 1;
    }
	#endif

	#if defined TRANS_A_NOT0 &amp;&amp; defined TRANS_B_0    
    if(A != 0 &amp;&amp; B == 0)
    {
        E = F = G = H = 0;
        L = (C+D/T)/A;
        P = -D/A*T;
    }
	#endif
	#if defined TRANS_A_0 &amp;&amp; defined TRANS_B_NOT0
    if(A == 0 &amp;&amp; B != 0)
    {
        E = 1;
        F = 0.5*C*T/B;
        G = F;
        H = 1;
        L = D/B;
        P = 0;
    }
	#endif
	#if defined TRANS_A_NOT0 &amp;&amp; defined TRANS_B_NOT0
    if(A != 0 &amp;&amp; B!= 0)
    {
        E = exp(-A*T/B);
        F = (D/B-C/A)*((1-E)*B/(A*T)-1);
        G = (D/B-C/A)*(1+(E-1)*(1+B/(A*T)));
        H =  1;
        L = D/B;
        P = 0;
    }
	#endif

    Xk_1 = E*Xk + F*Uk + G*Uk_1;
    Yk   = H*Xk_1 + L*Uk + P*Uk_1;

    // 保存
    TRANS-&gt;Uk = Uk;
    TRANS-&gt;Xk = Xk_1; 

    Push(&amp;paramStack,Yk);
	return 1;    
}</Property>
        <Property name="Description">指令名：ＴＲＡＮＳ

该点是计算一个一阶传递函数Y(s)/ U(s) = (C+Ds)/(A+Bs)。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,比较器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">COMPARE</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">RESULT,GT,EQ,LT</Property>
        <Property name="InputName">IN0,IN1</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">比较器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="比较结果" varname="fResult" type="System.Single" visible="yes" exp="两个输入的差值IN0-IN1。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="大于" varname="isGT" type="System.Boolean" visible="yes" exp="如果PV&gt;0，则为真，如果PV &lt; - DEADBAND，则为假，否则保持不变。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="小于" varname="isLT" type="System.Boolean" visible="yes" exp="如果PV&lt;0，则为真，如果PV&gt;= 0，则输出为假。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="等于" varname="isEQ" type="System.Boolean" visible="yes" exp="如果PV的绝对值小于死区DEADBAND，则输出真，否则输出假。" optype="" opvalue="" opnode="" relate="">false</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 比较器
uint8 COMPAREControl(COMPAREStruct *COMPARE)
{
    fp32 fIn1,fIn2;
    fp32 fResult,fGT,fEQ,fLT;

    Pop(&amp;paramStack,&amp;fIn2);
    Pop(&amp;paramStack,&amp;fIn1);

    fResult = fIn1 - fIn2;
    fGT = 0;
    fEQ = 0;
    fLT = 0;
    if(fResult == 0)
    {
        fEQ = 1;
    }
    else if(fResult &gt; 0)
    {
        fGT = 1;
    }
    else
    {
        fLT = 1;
    }

    Push(&amp;paramStack,fResult);
    Push(&amp;paramStack,fGT);
    Push(&amp;paramStack,fEQ);
    Push(&amp;paramStack,fLT);

	// 保存值
	COMPARE-&gt;fResult = fResult;
	COMPARE-&gt;isGT = (uint8)fGT;
	COMPARE-&gt;isEQ = (uint8)fEQ;
	COMPARE-&gt;isLT = (uint8)fLT;
	return 1;
}</Property>
        <Property name="Description">指令名：ＣＯＭＰＡＲＥ

两个操作数之间的比较，含死区。输入为两个操作数IN0,IN1。
输出四个，包括比较的差值IN0-IN1，是否大于，是否等于，是
否小于。  </Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,计时器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">TIM</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">FIN,TIM</Property>
        <Property name="InputName">
          <InputValue name="EN">1</InputValue>
          <InputValue name="RST">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">计时器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="计时值" varname="ulTimer" type="System.Int32" visible="yes" exp="计时器当前的计时值，以毫秒为单位。计时器的计时值是随时间的推移而增加的。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="预设值" varname="ulSetTimer" type="System.Int32" visible="yes" exp="计时预先设定值，如果计时值达到或超过预设 值，则计时完成输出高电平（逻辑1，true），否则，输出低电平（逻辑0，false）。" optype="" opvalue="" opnode="" relate="">10000</Property>
        <Property name="计时完成" varname="ucIsFinish" type="System.Boolean" visible="yes" exp="参见预设值。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="自动复位" varname="ucAutoReset" type="System.Boolean" visible="yes" exp="如果该参数置成非0（高电平），则计时完成 " optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="上次记录的时间" varname="ulLastTimeRec" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 计时器点
uint8 TIMControl(TIMStruct *TIM)
{
    fp32 fIn,fReset;
    uint32 timerInterval;  // 时间跨度	 
	 // 时间处理
	 if(timerCount &lt; TIM-&gt;ulLastTimeRec)
	 {
	 	  timerInterval = 0xffffffff - TIM-&gt;ulLastTimeRec + timerCount;
	 }
	 else
	 {
	 	  timerInterval = timerCount - TIM-&gt;ulLastTimeRec;
	 }

	Pop(&amp;paramStack,&amp;fReset);
    Pop(&amp;paramStack,&amp;fIn);    

    if(fIn != 0)
    {// 输入为0, 不启动定时器				
		if((fReset == 1) || ((TIM-&gt;ucAutoReset == 1) &amp;&amp; (TIM-&gt;ucIsFinish == 1)))
		{// 输入复位		
			TIM-&gt;ucIsFinish = 0;
		}		
		TIM-&gt;ulTimer = timerInterval;		
		if(TIM-&gt;ulTimer &gt;= TIM-&gt;ulSetTimer)
		{// 时间到点
		    TIM-&gt;ucIsFinish = 1;
			TIM-&gt;ulLastTimeRec = timerCount;
		}
	}
    Push(&amp;paramStack,TIM-&gt;ucIsFinish);
    Push(&amp;paramStack,TIM-&gt;ulTimer);
	return 1;
}</Property>
        <Property name="Description">指令名：ＴＩＭ

在给定的时间产生一个高电平。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,计数器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">CNT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">FIN,CNT</Property>
        <Property name="InputName">
          <InputValue name="IN">1</InputValue>
          <InputValue name="RST">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">计数器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="计数值" varname="ulCount" type="System.Int32" visible="yes" exp="计数器当前的计数值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="预设值" varname="ulSetValue" type="System.Int32" visible="yes" exp="计数预先设定值，如果计数值达到或超过预设 值，则计数完成输出高电平（逻辑1，true），否则，输出低电平（逻辑0，false）。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="计数类型" varname="ucType" type="MyEnum" visible="yes" exp="0：上升沿触发　1：下降沿触发　2：高电平触发　3：低电平触发。如果是其他值，缺省是0" optype="值优化" opvalue="" opnode="" relate="">上升沿触发,下降沿触发,高电平触发,低电平触发</Property>
        <Property name="计数完成" varname="ucIsComplete" type="System.Boolean" visible="yes" exp="参见预设值。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="自动复位" varname="ucIsAutoReset" type="System.Boolean" visible="yes" exp="如果该参数置成非0（高电平），则计数完成 " optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="上次的输入值" varname="fLastInValue" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 计数器点
uint8 CNTControl(CNTStruct *CNT)
{
    fp32 fIn;
    fp32 fInReset;

	Pop(&amp;paramStack,&amp;fInReset);
    Pop(&amp;paramStack,&amp;fIn);
    
	if((CNT-&gt;ucIsAutoReset != 0 &amp;&amp; CNT-&gt;ucIsComplete != 0) || (fInReset != 0))
    {// 自动复位并计数完成 	输入复位信号        
         CNT-&gt;ulCount = 0;
         CNT-&gt;ucIsComplete = 0;	        
    }

	switch(CNT-&gt;ucType)
	{
		#ifdef CNT_ucType_1		    
	    case 1:
	    {// 下降沿			
	        if(CNT-&gt;fLastInValue == 1 &amp;&amp; 
	        fIn == 0)
	        {
	            CNT-&gt;ulCount++;    
	        }			
			break;
			
	    }
		#endif
		#ifdef CNT_ucType_2
	    case 2:
	    {// 高电平
	        if(fIn == 1)
	        {
	            CNT-&gt;ulCount++;    
	        }
			break;
	    }
		#endif
		#ifdef CNT_ucType_3
	    case 3:
	    {// 低电平
	        if(fIn == 0)
	        {
	            CNT-&gt;ulCount++;    
	        }
			break;
	    }
		#endif
		#ifdef CNT_ucType_0
		default:
	    {// 上升沿
	        if(CNT-&gt;fLastInValue == 0 &amp;&amp; 
	        fIn == 1)
	        {
	            CNT-&gt;ulCount++;    
	        }
			break;
	    }
		#endif
	 }
    if(CNT-&gt;ulCount &gt;= CNT-&gt;ulSetValue)
    {// 到达设定值
        CNT-&gt;ucIsComplete = 1; // 计数完成
    }
    
    CNT-&gt;fLastInValue = fIn;     // 记录每回的输入值,为下次作为上次值
    Push(&amp;paramStack,CNT-&gt;ucIsComplete);  // 输出是否完成
    Push(&amp;paramStack,CNT-&gt;ulCount);       // 输出计数值
	return 1;
}</Property>
        <Property name="Description">指令名：ＣＮＴ

对输入信号进行计数，计数值逐渐增加。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,累计器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">TOT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">FIN,TOT</Property>
        <Property name="InputName">PV,RST</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">累计器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="累计值" varname="accValue" type="System.Single" visible="yes" exp="累计器当前的计时值，累计器的累计值是随时间的推移而增加的。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="预设值" varname="setValue" type="System.Single" visible="yes" exp="累计预先设定值，如果累计值达到或超过预设 值，则累计完成输出高电平（逻辑1，true），否则，输出低电平（逻辑0，false）。" optype="" opvalue="" opnode="" relate="">100000</Property>
        <Property name="时间基数(秒)" varname="TBase" type="System.Int32" visible="yes" exp="表示速度的时间基准，以秒为单位，如一小时是3600。如果时间基为0，则会使用缺省值3600。" optype="特定值优化" opvalue="0" opnode="" relate="">3600</Property>
        <Property name="是否累计" varname="isTot" type="System.Boolean" visible="yes" exp="控制累计器是否进行累计。" optype="" opvalue="" opnode="" relate="">true</Property>
        <Property name="累计完成" varname="isComplete" type="System.Boolean" visible="yes" exp="参见预设值。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="自动复位" varname="isAuto" type="System.Boolean" visible="yes" exp="如果该参数置成非0（高电平），则计时完成 " optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="小信号切除" varname="valveValue" type="System.Single" visible="yes" exp="为了避免在阀门已经关闭的情况下，由于现场的干扰信号而进行累计。这时可以设定一个值，指定当小于某一个值时，累计点不进行累计。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次采集的时间" varname="lastTimeRec" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 累计器
uint8 TOTControl(TOTStruct *TOT)
{
     fp32 fIn,fRst;	 
	 uint32 timerInterval;  // 时间跨度
	 // 时间处理
	 if(timerCount &lt; TOT-&gt;lastTimeRec)
	 {
	 	  timerInterval = 0xffffffff - TOT-&gt;lastTimeRec + timerCount;
	 }
	 else
	 {
	 	  timerInterval = timerCount - TOT-&gt;lastTimeRec;
	 }
     
     Pop(&amp;paramStack,&amp;fRst);
	 Pop(&amp;paramStack,&amp;fIn);    

     if((TOT-&gt;isAuto != 0 &amp;&amp; TOT-&gt;isComplete != 0) || (fRst == 1))
     {// 自动复位并完成 输入复位信号         
          TOT-&gt;accValue = 0;
          TOT-&gt;isComplete = 0;               
     }

     if((TOT-&gt;isTot == 1) &amp;&amp; (fIn &gt; TOT-&gt;valveValue))
     {// 计数要求符合
	    #ifdef TOT_TBase_0
        if(TOT-&gt;TBase == 0)
        {
            TOT-&gt;TBase = 3600;
        }
		#endif

        // 以秒为单位
        TOT-&gt;accValue += (fIn*(timerInterval/(fp32)1000))/TOT-&gt;TBase;
		TOT-&gt;lastTimeRec = timerCount; // 累计了才进行计时
        if(TOT-&gt;accValue &gt;= TOT-&gt;setValue)
        {
            TOT-&gt;isComplete = 1;
        }
     }
     Push(&amp;paramStack,TOT-&gt;isComplete);
     Push(&amp;paramStack,TOT-&gt;accValue);
	 return 1;
}</Property>
        <Property name="Description">指令名：ＴＯＴ

对瞬时量输入按时间标度进行累加，也就是说，对输入信号进
行时间积分。典型的应用场合是流量累计，可以统计某一个时
间段的累计值。 </Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,温压补偿器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">FLCP</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">F,G,P,T,X,Q</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">温压补偿器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="补偿类型" varname="ucType" type="MyEnum" visible="yes" exp="不同的补偿类型适合于不同的公式，详见说明书。" optype="值优化" opvalue="" opnode="" relate="">液体,气体、蒸汽,气体、蒸汽(比重),气体和蒸汽体积流量,蒸汽</Property>
        <Property name="设计比重" varname="fRG" type="System.Single" visible="yes" exp="设计比重或参考分子量，用同测量或计算的比重或分子量相同的单位表示（缺省值=1.0）。" optype="" opvalue="" opnode="" relate="">1</Property>
        <Property name="设计压力" varname="fRP" type="System.Single" visible="yes" exp="设计压力，换算成绝对值（缺省值=1.0）。" optype="" opvalue="" opnode="" relate="">1</Property>
        <Property name="设计蒸汽参数因子" varname="fRQ" type="System.Single" visible="yes" exp="设计蒸汽参数因子，用同测量的实际蒸汽参数因子相同的单位表示（缺省值=1.0）。" optype="" opvalue="" opnode="" relate="">1</Property>
        <Property name="设计温度" varname="fRT" type="System.Single" visible="yes" exp="设计温度，换算成绝对值（缺省值=1.0）。" optype="" opvalue="" opnode="" relate="">1</Property>
        <Property name="表压转换系数" varname="fP0" type="System.Single" visible="yes" exp="表压转换成为绝对压力的因子，典型为14.696Psia(美制)或101.325Kpa(SI)，输入该数的绝对值，缺省值=101.325，如果所测的压力已经是一个绝对压力，则输入为零。" optype="" opvalue="" opnode="" relate="">101.325</Property>
        <Property name="温度转换系数" varname="fT0" type="System.Single" visible="yes" exp="转换华氏或摄氏温度为绝对温度的系数。典型的459.69F(美制)或273.150C(SI)(当以T0为单位输入某一值时，则使用该数的绝对温度)，缺省值=273.15，如果所测的温度已经是一个绝对温度，则输入零。" optype="" opvalue="" opnode="" relate="">273.15</Property>
        <Property name="设计蒸汽系数" varname="fRX" type="System.Single" visible="yes" exp="蒸汽压缩系数，以同测量的实际蒸汽压缩系数相同的工程单位表示。 " optype="" opvalue="" opnode="" relate="">1</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 温压补偿器
uint8 FLCPControl(FLCPStruct *FLCP)
{
    fp32 fIn,fG,fP,fT,fX,fQ;
    fp32 fCompterm,fOut;
	fp32 temp,temp1,temp2;

    Pop(&amp;paramStack,&amp;fQ);
	Pop(&amp;paramStack,&amp;fX);
	Pop(&amp;paramStack,&amp;fT);
	Pop(&amp;paramStack,&amp;fP);
	Pop(&amp;paramStack,&amp;fG);
	Pop(&amp;paramStack,&amp;fIn);
	fCompterm = 0;
    switch(FLCP-&gt;ucType)
    {
		#ifdef FLCP_ucType_0
        case 0:// 液体			 
			if(FLCP-&gt;fRG != 0)
			{			
				temp = fG/FLCP-&gt;fRG;
				if(temp &gt;= 0)					 
            		fCompterm = sqrt(temp);
			}
            break;
		#endif
		#ifdef FLCP_ucType_1
        case 1:// 气体与蒸汽
			if(FLCP-&gt;fRP != 0 &amp;&amp; (fT + FLCP-&gt;fT0) != 0)
			{				
				temp1 = (FLCP-&gt;fP0 + fP) / FLCP-&gt;fRP;
				temp2 = FLCP-&gt;fRT / (fT + FLCP-&gt;fT0);
				if(temp1 &gt;= 0 || temp2 &gt;= 0)					
            		fCompterm = sqrt(temp1) * sqrt(temp2);
			}
            break;
		#endif
		#ifdef FLCP_ucType_2
        case 2:// 气体与蒸汽(比重)
			temp1 = (FLCP-&gt;fP0 + fP) * FLCP-&gt;fRT * fG;
			temp2 = FLCP-&gt;fRP * (fT + FLCP-&gt;fT0) * FLCP-&gt;fRG;
			if(temp2 != 0)
			{				
				temp = temp1 / temp2;
				if(temp &gt;= 0)				
            		fCompterm = sqrt(temp);
			}
            break;
		#endif
		#ifdef FLCP_ucType_3
        case 3:// 气体和蒸汽体积流量
			temp1 = (FLCP-&gt;fP0 + fP) * FLCP-&gt;fRT * FLCP-&gt;fRG;
			temp2 = FLCP-&gt;fRP * (fT + FLCP-&gt;fT0) * fG;
			if(temp2 != 0)
			{				
            	temp = temp1 / temp2;
				if(temp &gt;= 0)					
            		fCompterm = sqrt(temp);
			}
            break;
		#endif
		#ifdef FLCP_ucType_4
        default:// 蒸汽
			temp1 = (FLCP-&gt;fP0 + fP) * FLCP-&gt;fRT * fX * FLCP-&gt;fRQ;
			temp2 = FLCP-&gt;fRP * (fT +FLCP-&gt; fT0) * FLCP-&gt; fRX * fQ;
			if(temp2 != 0)
			{				
            	temp = temp1 / temp2;
				if(temp &gt;= 0)					
            		fCompterm = sqrt(temp);
			}            
            break;
		#endif        
    }
    fOut = fIn * fCompterm;

    Push(&amp;paramStack,fOut);
	return 1;
}</Property>
        <Property name="Description">指令名：ＦＬＣＰ

本算法用温度、压力、比重或分子量的变化对流量测量进行补
偿。测量的流量可以是气体、蒸汽或液体流量。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,通用线性化器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">GLIN</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">IN</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">通用线性化器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输入最小值" varname="fInMin" type="System.Single" visible="yes" exp="输入最小值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输入最大值" varname="fInMax" type="System.Single" visible="yes" exp="输入最大值。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出最小值" varname="fOutMin" type="System.Single" visible="yes" exp="输出最小值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输出最大值" varname="fOutMax" type="System.Single" visible="yes" exp="输出最大值。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="第1点输入" varname="pt[0].x" type="System.Single" visible="yes" exp="构成对应关系的第1个点的输入。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="第1点输出" varname="pt[0].y" type="System.Single" visible="yes" exp="构成对应关系的第1个点的输出。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="第2点输入" varname="pt[1].x" type="System.Single" visible="yes" exp="构成对应关系的第2个点的输入。" optype="" opvalue="" opnode="" relate="">1</Property>
        <Property name="第2点输出" varname="pt[1].y" type="System.Single" visible="yes" exp="构成对应关系的第2个点的输出。" optype="" opvalue="" opnode="" relate="">1</Property>
        <Property name="第3点输入" varname="pt[2].x" type="System.Single" visible="yes" exp="构成对应关系的第3个点的输入。" optype="" opvalue="" opnode="" relate="">2</Property>
        <Property name="第3点输出" varname="pt[2].y" type="System.Single" visible="yes" exp="构成对应关系的第3个点的输出。" optype="" opvalue="" opnode="" relate="">2</Property>
        <Property name="第4点输入" varname="pt[3].x" type="System.Single" visible="yes" exp="构成对应关系的第4个点的输入。" optype="" opvalue="" opnode="" relate="">3</Property>
        <Property name="第4点输出" varname="pt[3].y" type="System.Single" visible="yes" exp="构成对应关系的第4个点的输出。" optype="" opvalue="" opnode="" relate="">3</Property>
        <Property name="第5点输入" varname="pt[4].x" type="System.Single" visible="yes" exp="构成对应关系的第5个点的输入。" optype="" opvalue="" opnode="" relate="">4</Property>
        <Property name="第5点输出" varname="pt[4].y" type="System.Single" visible="yes" exp="构成对应关系的第5个点的输出。" optype="" opvalue="" opnode="" relate="">4</Property>
        <Property name="第6点输入" varname="pt[5].x" type="System.Single" visible="yes" exp="构成对应关系的第6个点的输入。" optype="" opvalue="" opnode="" relate="">5</Property>
        <Property name="第6点输出" varname="pt[5].y" type="System.Single" visible="yes" exp="构成对应关系的第6个点的输出。" optype="" opvalue="" opnode="" relate="">5</Property>
        <Property name="第7点输入" varname="pt[6].x" type="System.Single" visible="yes" exp="构成对应关系的第7个点的输入。" optype="" opvalue="" opnode="" relate="">6</Property>
        <Property name="第7点输出" varname="pt[6].y" type="System.Single" visible="yes" exp="构成对应关系的第7个点的输出。" optype="" opvalue="" opnode="" relate="">6</Property>
        <Property name="第8点输入" varname="pt[7].x" type="System.Single" visible="yes" exp="构成对应关系的第8个点的输入。" optype="" opvalue="" opnode="" relate="">7</Property>
        <Property name="第8点输出" varname="pt[7].y" type="System.Single" visible="yes" exp="构成对应关系的第8个点的输出。" optype="" opvalue="" opnode="" relate="">7</Property>
        <Property name="第9点输入" varname="pt[8].x" type="System.Single" visible="yes" exp="构成对应关系的第9个点的输入。" optype="" opvalue="" opnode="" relate="">8</Property>
        <Property name="第9点输出" varname="pt[8].y" type="System.Single" visible="yes" exp="构成对应关系的第9个点的输出。" optype="" opvalue="" opnode="" relate="">8</Property>
        <Property name="第10点输入" varname="pt[9].x" type="System.Single" visible="yes" exp="构成对应关系的第10个点的输入。" optype="" opvalue="" opnode="" relate="">9</Property>
        <Property name="第10点输出" varname="pt[9].y" type="System.Single" visible="yes" exp="构成对应关系的第10个点的输出。" optype="" opvalue="" opnode="" relate="">9</Property>
        <Property name="第11点输入" varname="pt[10].x" type="System.Single" visible="yes" exp="构成对应关系的第11个点的输入。" optype="" opvalue="" opnode="" relate="">10</Property>
        <Property name="第11点输出" varname="pt[10].y" type="System.Single" visible="yes" exp="构成对应关系的第11个点的输出。" optype="" opvalue="" opnode="" relate="">10</Property>
        <Property name="第12点输入" varname="pt[11].x" type="System.Single" visible="yes" exp="构成对应关系的第12个点的输入。" optype="" opvalue="" opnode="" relate="">11</Property>
        <Property name="第12点输出" varname="pt[11].y" type="System.Single" visible="yes" exp="构成对应关系的第12个点的输出。" optype="" opvalue="" opnode="" relate="">11</Property>
        <Property name="有效点的个数" varname="effNum" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">3</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 线性化函数
fp32 Linearize(PointStruct pt1,PointStruct pt2,fp32 x)
{
    fp32 fOut;
    fOut = (pt2.y - pt1.y) * (x - pt1.x) / (pt2.x - pt1.x) + pt1.y;
    return fOut;
}
// 通用线性化点
uint8 GLINControl(GLINStruct *GLIN)
{
     fp32 fIn;
     fp32 fOut;
     uint8 i;
     PointStruct ptStart,ptEnd;

     Pop(&amp;paramStack,&amp;fIn);

     if(fIn &lt; GLIN-&gt;fInMin ||
        fIn &gt; GLIN-&gt;fInMax)
    {// 在最值之外,等于输入
        fOut = fIn;
    }
    else if(fIn == GLIN-&gt;fInMin)
    {// 等于最小值
        fOut = GLIN-&gt;fOutMin;
    }
    else if(fIn == GLIN-&gt;fInMax)
    {// 等于最大值
        fOut = GLIN-&gt;fOutMax;
    }   
    else
    {
        ptStart.x = GLIN-&gt;fInMin;
        ptStart.y = GLIN-&gt;fOutMin;
        ptEnd.x = GLIN-&gt;fInMax;
        ptEnd.y = GLIN-&gt;fOutMax;
        if(GLIN-&gt;effNum &gt; 0)
        {// 有有效点时
            for(i = 0;i &lt; GLIN-&gt;effNum;i++)
            {
                 if(fIn == GLIN-&gt;pt[i].x)
                 {// 等于输入值
                     fOut = GLIN-&gt;pt[i].y;
                     break;
                 }
                 else 
                 {
                    if(i == 0)
                    {// 第一个点特殊处理
                        if(fIn &gt; ptStart.x &amp;&amp; 
                        fIn &lt; GLIN-&gt;pt[i].x)
                        {// 在第0个与第1个点之间 
                            fOut = Linearize(ptStart,GLIN-&gt;pt[i],fIn);
                            break;
                        }
                    }
                    else if(GLIN-&gt;effNum - 1 &gt; i)
                    {// 如还存在下一个结点
                          if(fIn &gt; GLIN-&gt;pt[i].x &amp;&amp; fIn &lt; GLIN-&gt;pt[i+1].x)
                          {
                             fOut = Linearize(GLIN-&gt;pt[i],GLIN-&gt;pt[i+1],fIn);
                             break;
                          }
                    }
                    else
                    {// 最后一个点
                        if(fIn &gt; GLIN-&gt;pt[i].x &amp;&amp; 
                            fIn &lt; ptEnd.x)
                        { 
                            fOut = Linearize(GLIN-&gt;pt[i],ptEnd,fIn);
                            break;
                        }
                    }
                 }// 不等于输入值                
            }// for 
        }// 有有效点
        else
        {// 无有效点
            fOut = Linearize(ptStart,ptEnd,fIn);
        }

    }// else

    Push(&amp;paramStack,fOut);
	return 1;
}</Property>
        <Property name="Description">指令名：ＧＬＩＮ

本算法的一个典型应用就是为非线性传感器提供线性化的PV数
据；它也可以用于表征单一变量的函数，比如，热量转移与流
速的关系，或者效率作为载荷的函数。当输入与输出的关系由
经验决定时，这种算法尤其有用。 </Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,线性变换器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">LICH</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">IN</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">线性变换器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="比例系数" varname="fCoeffient" type="System.Single" visible="yes" exp="比例系数。" optype="" opvalue="" opnode="" relate="">1</Property>
        <Property name="偏差" varname="fBias" type="System.Single" visible="yes" exp="偏差。" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 线性变换器
uint8 LICHControl(LICHStruct *LICH)
{
     fp32 fIn;
     fp32 fOut;

     Pop(&amp;paramStack,&amp;fIn);

     fOut = fIn * LICH-&gt;fCoeffient + LICH-&gt;fBias;
     
     Push(&amp;paramStack,fOut);
	 return 1;
}</Property>
        <Property name="Description">指令名：ＬＩＣＨ

该点提供线性变换功能。公式：输出 = 输入 * 比例系数 + 偏差。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,限值器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">LIMIT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">IN</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">限值器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="低限" varname="fMin" type="System.Single" visible="yes" exp="限值的低限。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="高限" varname="fMax" type="System.Single" visible="yes" exp="限值的高限。" optype="" opvalue="" opnode="" relate="">100</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 限值器
uint8 LIMITControl(LIMITStruct *LIMIT)
{
     fp32 fIn;  // 输入

     Pop(&amp;paramStack,&amp;fIn);
     if(fIn &lt; LIMIT-&gt;fMin)
     {// 小于低限,等于低限
        fIn = LIMIT-&gt;fMin;
     }
     if(fIn &gt; LIMIT-&gt;fMax)
     {// 大于高限,等于高限
        fIn = LIMIT-&gt;fMax;
     }

     Push(&amp;paramStack,fIn);
	 return 1;
}</Property>
        <Property name="Description">指令名：ＬＩＭＩＴ

把输出限制在某一个范围之内。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,比例器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">PERCENT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">IN</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">比例器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="低限" varname="fMin" type="System.Single" visible="yes" exp="比例的低限。" optype="特定值优化" opvalue="fMax" opnode="" relate="&gt;=">0</Property>
        <Property name="高限" varname="fMax" type="System.Single" visible="yes" exp="比例的高限。" optype="" opvalue="" opnode="" relate="">100</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 比例器
uint8 PERCENTControl(PERCENTStruct *PERCENT)
{
    fp32 fIn;  // 输入
    fp32 fOut;

    Pop(&amp;paramStack,&amp;fIn);
    #ifdef PERCENT_fMin_GEfMax
	if(PERCENT-&gt;fMin &gt;= PERCENT-&gt;fMax)
	{
		PERCENT-&gt;fMax = PERCENT-&gt;fMin + 100;
	}
	#endif
    fOut = (fIn - PERCENT-&gt;fMin) / (PERCENT-&gt;fMax - PERCENT-&gt;fMin) * 100;
    Push(&amp;paramStack,fOut);
	return 1;
}</Property>
        <Property name="Description">指令名：ＰＥＴＣＥＮＴ

求输入在某一个范围的百分比。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,比值控制器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">RATION</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">OP</Property>
        <Property name="InputName">SV</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">比值控制器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输出值" varname="fMV" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输入低限" varname="fInMin" type="System.Single" visible="yes" exp="输入的最小值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输入高限" varname="fInMax" type="System.Single" visible="yes" exp="输入的最大值。如果最大值小于最小值，则取最小值。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出低限" varname="fOutMin" type="System.Single" visible="yes" exp="输出的最小值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输出高限" varname="fOutMax" type="System.Single" visible="yes" exp="输出的最大值。如果最大值小于最小值，则取最小值。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="比值设定" varname="fRation" type="System.Single" visible="yes" exp="比值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="爬坡常数" varname="fClimbCon" type="System.Single" visible="yes" exp="为了防止输出突变，让输出缓慢变换。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="偏差" varname="fBias" type="System.Single" visible="yes" exp="内部偏置。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="手动/自动" varname="ucCtrlMod" type="MyEnum" visible="yes" exp="自动/手动设定，如果是0表示手动，非0表示自动。" optype="值优化" opvalue="" opnode="" relate="">手动,自动</Property>
        <Property name="输入值" varname="fPV" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 比值控制器
uint8 RATIONControl(RATIONStruct *RATION)
{
    fp32 fPV,fMV,fDeltaMV,fRation;      

    Pop(&amp;paramStack,&amp;fPV);
    #ifdef RATION_ucCtrlMod_0
    if(RATION-&gt;ucCtrlMod == 0)
    {// 自动
		// 比值处理
		fRation = RATION-&gt;fRation;
		if(RATION-&gt;fPV != 0)
		{
			fRation = (RATION-&gt;fMV - RATION-&gt;fBias) / RATION-&gt;fPV;
			if(fabs((fRation - RATION-&gt;fRation)) &gt; RATION-&gt;fClimbCon)
			{// 当手动切换到自动,进行爬坡控制 
				if(fRation &lt; RATION-&gt;fRation)
				{
					fRation += RATION-&gt;fClimbCon;	
				}
				else
				{
					fRation -= RATION-&gt;fClimbCon;
				}
			}
			else
			{
				fRation = RATION-&gt;fRation;	
			}			
		}
				
        // 输入值处理
        fPV = fPV &gt; RATION-&gt;fInMax ? RATION-&gt;fInMax : fPV;
        fPV = fPV &lt; RATION-&gt;fInMin ? RATION-&gt;fInMin : fPV;
		
        // 计算输出
        fMV = fPV * fRation + RATION-&gt;fBias;                  
    }
    #endif
    #ifdef RATION_ucCtrlMod_1
    if(RATION-&gt;ucCtrlMod == 0)
    {// 手动
        fMV = RATION-&gt;fMV;
		fPV = RATION-&gt;fPV;
    }
    #endif
    // 输出值处理
    fMV = (fMV &gt; RATION-&gt;fOutMax) ? RATION-&gt;fOutMax : fMV;
    fMV = (fMV &lt; RATION-&gt;fOutMin) ? RATION-&gt;fOutMin : fMV;

	// 保存
	RATION-&gt;fMV = fMV;
	RATION-&gt;fPV = fPV;

    Push(&amp;paramStack,fMV);
  	return 1;
}</Property>
        <Property name="Description">指令名：ＲＡＴＩＯＮ

比值控制点用于二个变量按照预先设定的比值进行比值控制。
它根据输入和比值计算出输出。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.ADControl,ControlTactic,斜坡控制器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">RAMP</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">NULL</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">斜坡控制器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输出值" varname="fMV" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="手动/自动" varname="ctrlMod" type="MyEnum" visible="yes" exp="0表示手动，非0表示自动。" optype="值优化" opvalue="" opnode="" relate="">手动,自动</Property>
        <Property name="手动时计时方式" varname="manStyle" type="MyEnum" visible="yes" exp="手动时回路计时方式。0表示手动时停止计时，非0表示手动时继续计时。" optype="值优化" opvalue="" opnode="defined RAMP_manStyle_1" relate="">手动时停止计时,手动时继续计时</Property>
        <Property name="终止时控制方式" varname="terminateStyle" type="MyEnum" visible="yes" exp="终止时控制方式，0表示一个时间段完成后重新开始计时，开始新一轮的控制。非0表示时间段完成后停止控制，输出是控制终值。" optype="" opvalue="" opnode="" relate="">停止控制,重新开始控制</Property>
        <Property name="初值" varname="initOutValue" type="System.Single" visible="yes" exp="开始控制的输出值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="终值" varname="endOutValue" type="System.Single" visible="yes" exp="最后一个点的输出值" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间01" varname="time[0]" type="System.Int32" visible="yes" exp="第1个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出01" varname="outValue[0]" type="System.Single" visible="yes" exp="第1个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间02" varname="time[1]" type="System.Int32" visible="yes" exp="第2个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出02" varname="outValue[1]" type="System.Single" visible="yes" exp="第2个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间03" varname="time[2]" type="System.Int32" visible="yes" exp="第3个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出03" varname="outValue[2]" type="System.Single" visible="yes" exp="第3个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间04" varname="time[3]" type="System.Int32" visible="yes" exp="第4个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出04" varname="outValue[3]" type="System.Single" visible="yes" exp="第4个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间05" varname="time[4]" type="System.Int32" visible="yes" exp="第5个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出05" varname="outValue[4]" type="System.Single" visible="yes" exp="第5个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间06" varname="time[5]" type="System.Int32" visible="yes" exp="第6个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出06" varname="outValue[5]" type="System.Single" visible="yes" exp="第6个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间07" varname="time[6]" type="System.Int32" visible="yes" exp="第7个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出07" varname="outValue[6]" type="System.Single" visible="yes" exp="第7个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间08" varname="time[7]" type="System.Int32" visible="yes" exp="第8个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出08" varname="outValue[7]" type="System.Single" visible="yes" exp="第8个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间09" varname="time[8]" type="System.Int32" visible="yes" exp="第9个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出09" varname="outValue[8]" type="System.Single" visible="yes" exp="第9个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间10" varname="time[9]" type="System.Int32" visible="yes" exp="第10个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出10" varname="outValue[9]" type="System.Single" visible="yes" exp="第10个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间11" varname="time[10]" type="System.Int32" visible="yes" exp="第11个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出11" varname="outValue[10]" type="System.Single" visible="yes" exp="第11个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间12" varname="time[11]" type="System.Int32" visible="yes" exp="第12个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出12" varname="outValue[11]" type="System.Single" visible="yes" exp="第12个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间13" varname="time[12]" type="System.Int32" visible="yes" exp="第13个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出13" varname="outValue[12]" type="System.Single" visible="yes" exp="第13个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间14" varname="time[13]" type="System.Int32" visible="yes" exp="第14个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出14" varname="outValue[13]" type="System.Single" visible="yes" exp="第14个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间15" varname="time[14]" type="System.Int32" visible="yes" exp="第15个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出15" varname="outValue[14]" type="System.Single" visible="yes" exp="第15个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间16" varname="time[15]" type="System.Int32" visible="yes" exp="第16个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出16" varname="outValue[15]" type="System.Single" visible="yes" exp="第16个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间17" varname="time[16]" type="System.Int32" visible="yes" exp="第17个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出17" varname="outValue[16]" type="System.Single" visible="yes" exp="第17个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间18" varname="time[17]" type="System.Int32" visible="yes" exp="第18个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出18" varname="outValue[17]" type="System.Single" visible="yes" exp="第18个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间19" varname="time[18]" type="System.Int32" visible="yes" exp="第19个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出19" varname="outValue[18]" type="System.Single" visible="yes" exp="第19个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间20" varname="time[19]" type="System.Int32" visible="yes" exp="第20个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出20" varname="outValue[19]" type="System.Single" visible="yes" exp="第20个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间21" varname="time[20]" type="System.Int32" visible="yes" exp="第21个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出21" varname="outValue[20]" type="System.Single" visible="yes" exp="第21个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间22" varname="time[21]" type="System.Int32" visible="yes" exp="第22个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出22" varname="outValue[21]" type="System.Single" visible="yes" exp="第22个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间23" varname="time[22]" type="System.Int32" visible="yes" exp="第23个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出23" varname="outValue[22]" type="System.Single" visible="yes" exp="第23个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="时间24" varname="time[23]" type="System.Int32" visible="yes" exp="第24个时间点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出24" varname="outValue[23]" type="System.Single" visible="yes" exp="第24个输出点。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出段数" varname="outNum" type="System.Byte" visible="yes" exp="总共有多少个控制段，有效范围0~25。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="控制时间" varname="controlTime" type="System.Int32" visible="yes" exp="总的控制时间，最长控制时间是1193小时，即49天，以毫秒为单位。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="上次控制的时间" varname="lastTimeRec" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="有效段数" varname="sectionNum" type="System.Byte" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 斜坡控制点
uint8 RAMPControl(RAMPStruct *RAMP)
{
     uint32 deltaTime;
     uint8 i;
     fp32 fMV;
		
	 #ifdef RAMP_ctrlMod_0	 			 
     if(RAMP-&gt;ctrlMod == 0)
     {// 自动
	     // 时间处理
		 if(timerCount &lt; RAMP-&gt;lastTimeRec)
		 {
		 	  deltaTime = 0xffffffff - RAMP-&gt;lastTimeRec + timerCount;
		 }
		 else
		 {
		 	  deltaTime = timerCount - RAMP-&gt;lastTimeRec;
		 }
         // 要进行入每一点,只能将时间设为长些
        if(deltaTime &lt; RAMP-&gt;time[0])
        {// 初始情况
             fMV = RAMP-&gt;initOutValue;
         }
         else if(deltaTime &gt;= RAMP-&gt;controlTime)
         {// 控制时间到点
            fMV = RAMP-&gt;endOutValue; // 终止方式非0时,不再控制
            if(RAMP-&gt;terminateStyle == 0)
            {// 重新计时
                RAMP-&gt;lastTimeRec = timerCount;
            }           
         }
         else if(deltaTime &gt;= RAMP-&gt;time[RAMP-&gt;sectionNum-1] &amp;&amp;
             deltaTime &lt; RAMP-&gt;controlTime)
         {// 最后一个点
             fMV = RAMP-&gt;outValue[RAMP-&gt;sectionNum-1];
         }
         else
         {// 中间点
             for(i = 0;i &lt; RAMP-&gt;sectionNum;i++)
             {
                 if(deltaTime &gt;= RAMP-&gt;time[i] &amp;&amp;
                    deltaTime &lt; RAMP-&gt;time[i+1])
                 {
                    fMV = RAMP-&gt;outValue[i];
                    break;
                 }
             }
         }
     }
	 #endif
	 #ifdef RAMP_ctrlMod_1
     if(RAMP-&gt;ctrlMod != 0)
     {// 手动
        fMV = RAMP-&gt;fMV;
		#ifdef RAMP_manStyle_0 
        if(RAMP-&gt;manStyle == 0)
        {// 时间停止
            RAMP-&gt;lastTimeRec = timerCount;
        }
		#endif
     }
	 #endif
     Push(&amp;paramStack,fMV);
	 return 1;
}</Property>
        <Property name="Description">指令名：ＲＡＭＰ

本算法一般用于设定值编程功能，它能产生多达12个交替的斜
坡和均值共24段。该算法的输出作为副回路的给定值。通常副
回路是一个PID算法的控制回路，根据斜坡和均值的周期来控制
过程变量。斜坡控制算法使用的PV值在正常情况下就PID控制回
路的PV值。斜坡控制主要用于锅炉和加热炉的自动温度循环控
制，也可以用于单元的自动启动和简单控制。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,开关控制器51,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">SW51</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">OP</Property>
        <Property name="InputName">PV0,PV1,PV2,PV3,PV4</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">开关控制器51</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输入选择" varname="ucSelect" type="MyEnum" visible="yes" exp="选择第几个输入，有效范围从0~4。0表示选择第一个输入，依次类推。如果大于4，则认为等于4。" optype="" opvalue="" opnode="" relate="">第一输入,第二输入,第三输入,第四输入,第五输入</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 开关控制器51点
uint8 SW51Control(SW51Struct *SW51)
{
     fp32 fIn0,fIn1,fIn2,fIn3,fIn4;
     fp32 fOut;

     Pop(&amp;paramStack,&amp;fIn4);
     Pop(&amp;paramStack,&amp;fIn3);
     Pop(&amp;paramStack,&amp;fIn2);
     Pop(&amp;paramStack,&amp;fIn1);
     Pop(&amp;paramStack,&amp;fIn0);

     switch(SW51-&gt;ucSelect)
     {
	 	#ifdef SW51_ucSelect_0
        case 0:
            fOut = fIn0;
            break;
		#endif
		#ifdef SW51_ucSelect_1
        case 1:
            fOut = fIn1;
            break;
		#endif
		#ifdef SW51_ucSelect_2
        case 2:
            fOut = fIn2;
            break;
		#endif
		#ifdef SW51_ucSelect_3
        case 3:
            fOut = fIn3;
            break;
		#endif
		#ifdef SW51_ucSelect_4
        default:
            fOut = fIn4;
            break;
		#endif
     }
     Push(&amp;paramStack,fOut);
	 return 1;
}</Property>
        <Property name="Description">指令名：ＳＷ５１

从5个输入中选择一个输出。如果被选择的输入没有连接输入，则输出为0。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,开关控制器13,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">SW13</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">OP0,OP1,OP2</Property>
        <Property name="InputName">IN0</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">开关控制器13</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输出选择" varname="ucSelect" type="MyEnum" visible="yes" exp="选择第几个输出，有效范围从0~2。0表示选择第一个输出，依次类推。如果大于2，则认为等于2。" optype="值优化" opvalue="" opnode="" relate="">第一输出,第二输出,第三输出</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 开关控制器13
uint8 SW13Control(SW13Struct *SW13)
{
     fp32 fIn,fOut1,fOut2,fOut3;

     Pop(&amp;paramStack,&amp;fIn);
     fOut1 = 0;
     fOut2 = 0;
     fOut3 = 0;
     switch(SW13-&gt;ucSelect)
     {
	 	#ifdef SW13_ucSelect_0
        case 0:
            fOut1 = fIn;
            break;
		#endif
		#ifdef SW13_ucSelect_1
        case 1:
            fOut2 = fIn;
            break;
		#endif
		#ifdef SW13_ucSelect_2
        default:
            fOut3 = fIn;
            break;
		#endif        
     }

     Push(&amp;paramStack,fOut1);
     Push(&amp;paramStack,fOut2);
     Push(&amp;paramStack,fOut3);
	 return 1;
}</Property>
        <Property name="Description">指令名：ＳＷ３１

从输入中选择向3个输出中的一个输出，没有被选择的输出端的输出使能端将无效。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,三者取中器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">SWMID</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">OP</Property>
        <Property name="InputName">
          <InputValue name="PV0">NULL</InputValue>
          <InputValue name="PV1">NULL</InputValue>
          <InputValue name="PV2">NULL</InputValue>
        </Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">三者取中器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="算式选择" varname="ucSelect" type="MyEnum" visible="yes" exp="详见说明书。" optype="" opvalue="" opnode="defined SWMID_ucEffNum_2 || defined SWMID_ucEffNum_3" relate="">高值,低值,均值</Property>
        <Property name="有效个数" varname="ucEffNum" type="System.Byte" visible="no" exp="" optype="值优化" opvalue="" opnode="" relate="">3</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 三者取中器
uint8 SWMIDControl(SWMIDStruct *SWMID)
{
      fp32 fIn1,fIn2,fIn3;
      fp32 fOut = 0;
	  
	  #ifdef SWMID_ucEffNum_1
      if(SWMID-&gt;ucEffNum == 1)
      {
         Pop(&amp;paramStack,&amp;fIn1);
         fOut = fIn1;        
      }
	  #endif
	  #ifdef SWMID_ucEffNum_2
      if(SWMID-&gt;ucEffNum == 2)
      {
         Pop(&amp;paramStack,&amp;fIn2);
         Pop(&amp;paramStack,&amp;fIn1);
         switch(SWMID-&gt;ucSelect)
         {
		 	#ifdef SWMID_ucSelect_0
            case 0:
                fOut = (fIn1 &gt; fIn2) ? fIn1 : fIn2;
                break;
			#endif
			#ifdef SWMID_ucSelect_1
            case 1:
                fOut = (fIn1 &lt; fIn2) ? fIn1 : fIn2;
                break;
			#endif
			#ifdef SWMID_ucSelect_2
            default:
                fOut = (fIn1 + fIn2) / 2;
                break;
			#endif            
         }
      }
	  #endif
	  #ifdef SWMID_ucEffNum_3
      if(SWMID-&gt;ucEffNum == 3)
      {
         Pop(&amp;paramStack,&amp;fIn3);
         Pop(&amp;paramStack,&amp;fIn2);
         Pop(&amp;paramStack,&amp;fIn1);
         if(fIn1 == fIn2 &amp;&amp; fIn2 == fIn3)
		 {// 三者相等
		 	fOut = fIn1;
		 }      
		 else if(fIn1 == fIn2)
		 {
		 	fOut = fIn1;
		 }
         else if(fIn2 == fIn3)
		 {
		 	fOut = fIn2;
		 }
		 else if(fIn1 == fIn3)
		 {
		 	fOut = fIn1;
		 }
		 else
		 {
		 	  if((fIn1 &gt; fIn2 &amp;&amp; fIn1 &lt; fIn3) || (fIn1 &gt; fIn3 &amp;&amp; fIn1 &lt; fIn2))
			  	fOut = fIn1;
			  else if((fIn2 &gt; fIn1 &amp;&amp; fIn2 &lt; fIn3) || (fIn2 &gt; fIn3 &amp;&amp; fIn2 &lt; fIn1))
			  	fOut = fIn2;
			  else 
			  	fOut = fIn3;	
		 }
      }
	  #endif
      Push(&amp;paramStack,fOut);
	  return 1;
}</Property>
        <Property name="Description">指令名：ＳＷＭＩＤ

在三个输入中选择中间的一个。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,高低选择器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">SWHL</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">OP</Property>
        <Property name="InputName">
          <InputValue name="PV0">NULL</InputValue>
          <InputValue name="PV1">NULL</InputValue>
          <InputValue name="PV2">NULL</InputValue>
          <InputValue name="PV3">NULL</InputValue>
          <InputValue name="PV4">NULL</InputValue>
          <InputValue name="PV5">NULL</InputValue>
        </Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">高低选择器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="算式选择" varname="ucSelect" type="MyEnum" visible="yes" exp="如果是0，则输出最大值，如果是1，则输出最小值，如果是2，则输出平均值。如果不在0~2范围内，则输出平均值。" optype="值优化" opvalue="" opnode="" relate="">高选,低选,均值</Property>
        <Property name="有效个数" varname="ucEffNum" type="System.Byte" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 高低选择器
uint8 SWHLControl(SWHLStruct *SWHL)
{
     fp32 *fIn;
     fp32 fOut;
     fp32 temp;
     uint8 i;

	 fIn = (fp32 *)malloc(sizeof(fp32) * SWHL-&gt;ucEffNum);
	 for(i = 0;i &lt; SWHL-&gt;ucEffNum;i++)
	 {// 至少会有一个,上位机处理
	 	 Pop(&amp;paramStack,&amp;fIn[i]);
	 }
	 
     switch(SWHL-&gt;ucSelect)
     {
	 	#ifdef SWHL_ucSelect_0
        case 0:// max
            temp = fIn[0];
            for(i = 1; i &lt; SWHL-&gt;ucEffNum;i++)
            {
                if(fIn[i] &gt; temp)
                {// 更大
                    temp = fIn[i];
                }
            }
            fOut = temp;    
            break;
		#endif
		#ifdef SWHL_ucSelect_1
        case 1: // Min
            temp = fIn[0];
            for(i = 1; i &lt; SWHL-&gt;ucEffNum;i++)
            {
                if(fIn[i] &lt; temp)
                {// 更小
                    temp = fIn[i];
                }
            }
            fOut = temp;    
            break;
		#endif
		#ifdef SWHL_ucSelect_2
        default: //avg
            temp = 0;
            for(i = 0;i &lt; SWHL-&gt;ucEffNum;i++)
            {
                temp += fIn[i];
            }
            fOut = temp / SWHL-&gt;ucEffNum;
            break;
		#endif        
     }
     Push(&amp;paramStack,fOut);
	 return 1;
}</Property>
        <Property name="Description">指令名：ＳＷＨＬ

在六个输入中选择最大，最小或取平均值。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,数字组合器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">DC</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">INST,DO0,DO1</Property>
        <Property name="InputName">OUTST,DI0,DI1</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">数字组合器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输入状态" varname="inputStatus" type="MyEnum" visible="yes" exp="见说明书输入表。" optype="" opvalue="" opnode="" relate="">第一有效态,第二有效态,爬行态,非法态</Property>
        <Property name="输出状态" varname="outputStatus" type="MyEnum" visible="yes" exp="见说明书输出表。" optype="" opvalue="" opnode="" relate="">第一有效态,第二有效态</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 数字组合点
uint8 DCControl(DCStruct *DC)
{
     fp32 fIn1,fIn2,fIn3; // 输出状态\输入点1\输入点2
     fp32 fOut1,fOut2,fOut3;  // 输入状态\输出点1\输出点2

     Pop(&amp;paramStack,&amp;fIn3);
     Pop(&amp;paramStack,&amp;fIn2);
     Pop(&amp;paramStack,&amp;fIn1);

     if(fIn1 == 0)
     {// 输出状态为第一有效态
        fOut2 = 0;
        fOut3 = 1;
     }
     else
     {// 输出状态为第二有效态
        fOut2 = 1;
        fOut3 = 0; 
     }

     if(fIn2 == 0 &amp;&amp; fIn3 == 0)
     {// 爬行状态
        fOut1 = 2;
     }
     else if(fIn2 == 0 &amp;&amp; fIn3 == 1)
     {// 第一有效态(开)
        fOut1 = 0;
     }
     else if(fIn2 == 1 &amp;&amp; fIn3 == 0)
     {// 第二有效态(关)
        fOut1 = 1;
     }
     else
     {// 非法状态
        fOut1 = 3;
     }

     Push(&amp;paramStack,fOut1);
     Push(&amp;paramStack,fOut2);
     Push(&amp;paramStack,fOut3);
      // 保存
	 DC-&gt;inputStatus = fOut1;
	 DC-&gt;outputStatus = fIn1;
	 return 1;
}</Property>
        <Property name="Description">指令名：ＤＣ

数字组合点是一个多输入/多输出点。它为离散型设备如：马
达，泵，电磁阀及（电动阀）等提供接口，数字组合点具有内
置结构，可用于处理连锁并能以组、细目的方式显示连锁状
态。此外，数字组合点也可同逻辑点和其它数字点一起使用，
以完成复杂的连锁方案。数字组合点要求：1）数据点的输入和
输出状态是相互独立的，可以按用户的应用要求进行组态。数
据点的输入和输出连在硬件的I/O点或布尔标志上。2）可以支
持具有两个状态的设备（电动阀、可逆马达等）。  </Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,偏差限值器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">BIASLMT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">IN</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">偏差限值器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="最大偏差" varname="fMaxBias" type="System.Single" visible="yes" exp="在指定的控制周期内的最大变化率。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="上次输出" varname="fLastOut" type="System.Single" visible="yes" exp="上一次计算时的输出。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="采样周期" varname="ulCycle" type="System.Int32" visible="yes" exp="控制回路的周期，以毫秒为单位。不能等于0，如果等于0，则使用缺省值1000毫秒。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
        <Property name="上次控制的时间" varname="ulLastTimeRec" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 偏差限值器
uint8 BIASLMTControl(BIASLMTStruct *BIASLMT)
{
      fp32 fIn;
      fp32 fFactualBias,fAllowedBias;// 实际偏差与允许的最大偏差
	  uint32 timerInterval;  // 时间跨度
	  fp32 fTimeInterval,fTs;
	  	  	  
	 // 时间处理
	 if(timerCount &lt; BIASLMT-&gt;ulLastTimeRec)
	 {
	 	  timerInterval = 0xffffffff - BIASLMT-&gt;ulLastTimeRec + timerCount;
	 }
	 else
	 {
	 	  timerInterval = timerCount - BIASLMT-&gt;ulLastTimeRec;
	 }
	 fTimeInterval = timerInterval / (fp32)1000;
      Pop(&amp;paramStack,&amp;fIn);
	  #ifdef BIASLMT_ulCycle_0
      if(BIASLMT-&gt;ulCycle == 0)
	  	BIASLMT-&gt;ulCycle = 1000;
	  #endif
	  fTs = BIASLMT-&gt;ulCycle / (fp32)1000;		  
	  fFactualBias = (fIn - BIASLMT-&gt;fLastOut) / fTimeInterval;
	  fAllowedBias = BIASLMT-&gt;fMaxBias * fTimeInterval / fTs;
	              
	  if(fabs(fFactualBias) &gt;  fAllowedBias)
	  {// 实际偏差大于允许偏差
	      if(fIn &gt; BIASLMT-&gt;fLastOut)
	      {// 输入大于上次输出
	            BIASLMT-&gt;fLastOut += fAllowedBias;
	      }
	      else
	      {
	            BIASLMT-&gt;fLastOut -= fAllowedBias;
	      }
	  }
	  else
	  {
	      BIASLMT-&gt;fLastOut = fIn;
	  }           
       BIASLMT-&gt;ulLastTimeRec = timerCount; // 更新时间
      Push(&amp;paramStack,BIASLMT-&gt;fLastOut);
	  return 1;      
}</Property>
        <Property name="Description">指令名：ＢＩＡＳＬＭＴ

为了防止输出突变，对输出在指0定周期之内的输出变化进行限制。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,变化率器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">CHRAT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">IN</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">变化率器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次输入" varname="fLastIn" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="采样周期" varname="ulCycle" type="System.Int32" visible="yes" exp="计算变化率的基本时间单位，以毫秒为单位。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 变化率器
uint8 CHRATControl(CHRATStruct *CHRAT)
{
     fp32 fIn,fOut;
	 fp32 fTs;

     Pop(&amp;paramStack,&amp;fIn);
	 #ifdef CHRAT_ulCycle_0
     if(CHRAT-&gt;ulCycle == 0)
	  	CHRAT-&gt;ulCycle = 1000;
	 #endif
	 fTs = CHRAT-&gt;ulCycle / (fp32)1000;
     fOut = (fIn - CHRAT-&gt;fLastIn) / fTs;     

     Push(&amp;paramStack,fOut);
	 return 1;
}</Property>
        <Property name="Description">指令名：ＣＨＲＡＴ

求输入变量在指定周期内的变化率。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,脉宽调制输出,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">PVM</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">IN0</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">脉宽调制输出</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输入" varname="fLastMV" type="System.Single" visible="yes" exp="输入的模拟量，必须在0~1之间，如果小于0，则按0处理，如果大于1，则按1处理。 " optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输出" varname="cPV" type="MyEnum" visible="yes" exp="计算后的数字数字，输出0或1。" optype="" opvalue="" opnode="" relate="">0/1</Property>
        <Property name="周期" varname="lCycle" type="System.Int32" visible="yes" exp="控制周期，以毫秒为单位。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
        <Property name="复位" varname="cReset" type="System.Boolean" visible="yes" exp="如果输入1，则重新开始一个新的周期。" optype="" opvalue="" opnode="" relate="">false</Property>
        <Property name="方式" varname="cStyle" type="MyEnum" visible="yes" exp="分两种方式：0，输入改变时重新开始一个新的控制周期。1，周期结束后才开始一个新的控制周期。" optype="" opvalue="" opnode="" relate="">周期结束后开始新周期,输入改变时开始新周期</Property>
        <Property name="前段时间" varname="preCycle" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="后段时间" varname="aftCycle" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="时间记录" varname="timeRec" type="System.Int32" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 脉宽调制输出
uint8 PVMControl(PVMStruct *PVM)
{
	fp32 fIn;
	uint32 timerInterval;  // 时间跨度
	 // 时间处理
	 if(timerCount &lt; PVM-&gt;timeRec)
	 {
	 	  timerInterval = 0xffffffff - PVM-&gt;timeRec + timerCount;
	 }
	 else
	 {
	 	  timerInterval = timerCount - PVM-&gt;timeRec;
	 }

	Pop(&amp;paramStack,&amp;fIn);
	fIn = fIn &lt; 0 ? 0 : fIn;
	fIn = fIn &gt; 1 ? 1 : fIn;
	#ifdef PVM_lCycle_0
	if(PVM-&gt;lCycle == 0)
		PVM-&gt;lCycle = 1000;
	#endif
	
	if(timerInterval &lt;= PVM-&gt;preCycle)
	{// 前半段
		PVM-&gt;cPV = 1; // 输出为1
	}
	else
	{// 后半段
		PVM-&gt;cPV = 0; // 输出为0
	}
	if((PVM-&gt;cReset != 0) || (PVM-&gt;cStyle == 0 &amp;&amp; fIn != PVM-&gt;fLastMV) ||
		(PVM-&gt;cStyle != 0 &amp;&amp; (timerInterval &gt;= PVM-&gt;lCycle)))
	{// 重新开始控制周期 重置为1 方式0时输入改变 方式1周期结束开始新的周期
		PVM-&gt;preCycle = PVM-&gt;lCycle * fIn;
		PVM-&gt;aftCycle = PVM-&gt;lCycle * (1 - fIn);
		PVM-&gt;timeRec = timerCount;
		PVM-&gt;fLastMV = fIn;	
	}
	Push(&amp;paramStack,PVM-&gt;cPV);
	return 1;
}</Property>
        <Property name="Description">指令名：ＰＶＷ

该控制块主要是完成模拟量输出到数字量的转换。把模拟量
（必须进行归一化，即必须在0~1之间），按在一个周期内的百
分比输出高低电平。例如输入是0.6，则输出在一个周期的开始
的前60%时间输出高电平，后40%时间输出低电平信号。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,加权平均滤波器,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">AVEFLT</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">IN</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">加权平均滤波器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="系数1" varname="fCoefficient[0]" type="System.Single" visible="yes" exp="加权系数1。" optype="" opvalue="" opnode="" relate="">12.5</Property>
        <Property name="系数2" varname="fCoefficient[1]" type="System.Single" visible="yes" exp="加权系数2。" optype="" opvalue="" opnode="" relate="">12.5</Property>
        <Property name="系数3" varname="fCoefficient[2]" type="System.Single" visible="yes" exp="加权系数3。" optype="" opvalue="" opnode="" relate="">12.5</Property>
        <Property name="系数4" varname="fCoefficient[3]" type="System.Single" visible="yes" exp="加权系数4。" optype="" opvalue="" opnode="" relate="">12.5</Property>
        <Property name="系数5" varname="fCoefficient[4]" type="System.Single" visible="yes" exp="加权系数5。" optype="" opvalue="" opnode="" relate="">12.5</Property>
        <Property name="系数6" varname="fCoefficient[5]" type="System.Single" visible="yes" exp="加权系数6。" optype="" opvalue="" opnode="" relate="">12.5</Property>
        <Property name="系数7" varname="fCoefficient[6]" type="System.Single" visible="yes" exp="加权系数7。" optype="" opvalue="" opnode="" relate="">12.5</Property>
        <Property name="系数8" varname="fCoefficient[7]" type="System.Single" visible="yes" exp="加权系数8。" optype="" opvalue="" opnode="" relate="">12.5</Property>
        <Property name="输入1" varname="fSavedIn[0]" type="System.Single" visible="yes" exp="输入1。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输入2" varname="fSavedIn[1]" type="System.Single" visible="yes" exp="输入2。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输入3" varname="fSavedIn[2]" type="System.Single" visible="yes" exp="输入3。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输入4" varname="fSavedIn[3]" type="System.Single" visible="yes" exp="输入4。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输入5" varname="fSavedIn[4]" type="System.Single" visible="yes" exp="输入5。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输入6" varname="fSavedIn[5]" type="System.Single" visible="yes" exp="输入6。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输入7" varname="fSavedIn[6]" type="System.Single" visible="yes" exp="输入7。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输入8" varname="fSavedIn[7]" type="System.Single" visible="yes" exp="输入8。" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 加权平均滤波器
uint8 AVEFLTControl(AVEFLTStruct *AVEFLT)
{
    fp32 fIn,fOut,temp;
    uint8 i;
     
    Pop(&amp;paramStack,&amp;fIn);
	temp = AVEFLT-&gt;fCoefficient[0] + AVEFLT-&gt;fCoefficient[1] +
         AVEFLT-&gt;fCoefficient[2] + AVEFLT-&gt;fCoefficient[3] +
         AVEFLT-&gt;fCoefficient[4] + AVEFLT-&gt;fCoefficient[5] +
         AVEFLT-&gt;fCoefficient[6] + AVEFLT-&gt;fCoefficient[7];
    AVEFLT-&gt;fSavedIn[7] = fIn;
	if(temp == 0)
		fOut = fIn;
	else
	    fOut = (AVEFLT-&gt;fCoefficient[0] * AVEFLT-&gt;fSavedIn[0] + 
	         AVEFLT-&gt;fCoefficient[1] * AVEFLT-&gt;fSavedIn[1] + 
	         AVEFLT-&gt;fCoefficient[2] * AVEFLT-&gt; fSavedIn[2] + 
	         AVEFLT-&gt;fCoefficient[3] * AVEFLT-&gt;fSavedIn[3] + 
	         AVEFLT-&gt;fCoefficient[4] * AVEFLT-&gt;fSavedIn[4] + 
	         AVEFLT-&gt;fCoefficient[5] * AVEFLT-&gt;fSavedIn[5] + 
	         AVEFLT-&gt;fCoefficient[6] * AVEFLT-&gt;fSavedIn[6] + 
	         AVEFLT-&gt;fCoefficient[7] * AVEFLT-&gt;fSavedIn[7]) / temp;
          

    Push(&amp;paramStack,fOut);
    // 更新保存的值
    for(i = 0; i &lt; 8;i++)
    {
        if(i &lt; 7)
        {
            AVEFLT-&gt;fSavedIn[i] = AVEFLT-&gt;fSavedIn[i+1];
        }
        else
        {// 第8个值设为0
            AVEFLT-&gt;fSavedIn[i] = 0;
        }   
    }
	return 1;
}</Property>
        <Property name="Description">指令名：ＡＶＥＦＬＴ

为了对输入进行滤波，设计者自己可以定义各次的权系数，最
多可以对前8次进行滤波。考虑到有时输入变化比较大，希望把
前几次的数据结合起来考虑，例如需要考虑前6次的输入，可以
设置系数分别是：0.5，0.25，0.125，0.0625，0.03125，
0.03125，0，0。这表示输出是：PV = (0.5*IN0+0.25*IN1+
0.125*IN2+0.0625*IN3 +0.03125*IN4+0.03125*IN5+0*IN6+0
*IN7)/(0.5+0.25+0.125+0.0625+0.03125+0.03125+0+0)</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.SpecialControl.Calculator,ControlTactic,计算器组态,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">CALCU</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">Y0,Y1,Y2,Y3</Property>
        <Property name="InputName">X0,X1,X2,X3,X4,X5,X6,X7</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">计算器组态</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="中间变量1" varname="fM[0]" type="System.Single" visible="yes" exp="存放临时中间变量1。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="中间变量2" varname="fM[1]" type="System.Single" visible="yes" exp="存放临时中间变量2。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="中间变量3" varname="fM[2]" type="System.Single" visible="yes" exp="存放临时中间变量3。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="中间变量4" varname="fM[3]" type="System.Single" visible="yes" exp="存放临时中间变量4。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="中间变量5" varname="fM[4]" type="System.Single" visible="yes" exp="存放临时中间变量5。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="中间变量6" varname="fM[5]" type="System.Single" visible="yes" exp="存放临时中间变量6。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="中间变量7" varname="fM[6]" type="System.Single" visible="yes" exp="存放临时中间变量7。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="中间变量8" varname="fM[7]" type="System.Single" visible="yes" exp="存放临时中间变量8。" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">
        </Property>
        <Property name="Description">指令名：ＣＡＬＣＵ

可进行运算操作。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.SpecialControl.Process,ControlTactic,条件动作表,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">PROCESS</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">NULL</Property>
        <Property name="InputName">EN</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">条件动作表</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="使能" varname="isEn" type="System.Boolean" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">false</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">
        </Property>
        <Property name="Description">指令名：ＰＲＯＣＥＳＳ

条件动作表是支持最多32个条件，最多32个动作的一个功能
块。每一个动作都在指定条件下执行。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.ADControl,ControlTactic,AD转化,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">AD</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">NULL</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">AD转化</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="通道号" varname="ucCN" type="MyEnum" visible="yes" exp="选择相应的通道进行AD转换后输入。" optype="" opvalue="" opnode="" relate="">0,1,2,3,4,5,6,7,8,9</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">//AD转换器输入,有一个参数(通道号),一个输出
uint8 ADControl(ADStruct * AD)
{	 
 	 fp32 fPV;
	 ADConvert = (fp32 (*)(uint8))ADConvertAddr;	
	 fPV = ADConvert(AD-&gt;ucCN);
	 Push(&amp;paramStack,fPV);
	 return 1;
}</Property>
        <Property name="Description">指令名：ＡＤ

将选择的通道进行采样得到模拟量，将其转成数字量输入。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.DAControl,ControlTactic,DA转化,算法支撑">
      <BasicProperty>
        <Property name="ModuleName">DA</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">NULL</Property>
        <Property name="InputName">IN</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">DA转化</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="通道号" varname="ucCN" type="MyEnum" visible="yes" exp="选择相应的通道进行DA转换后输出。" optype="" opvalue="" opnode="" relate="">0,1,2,3,4,5,6,7,8,9</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">//DA
uint8 DAControl(DAStruct * DA)
{
	fp32 fMV;

	Pop(&amp;paramStack,&amp;fMV);
	DAConvert = (void (*)(fp32,uint8))DAConvertAddr;
	DAConvert(fMV,DA-&gt;ucCN);
	return 1;
}</Property>
        <Property name="Description">指令名：ＤＡ

数字量转换成模拟量，并选择通道输出。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="控制算法">
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,PID控制器,控制算法">
      <BasicProperty>
        <Property name="ModuleName">PID</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">MV</Property>
        <Property name="InputName">
          <InputValue name="SPC">-1</InputValue>
          <InputValue name="PV">0</InputValue>
        </Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">PID控制器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="被控量" varname="fPV" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="defined PID_cSelect_3 || defined PID_cSelect_4 || defined PID_fPR_NOT0" relate="">0</Property>
        <Property name="被控量报警死区" varname="fHY" type="System.Single" visible="yes" exp="为了不使报警状态频繁改变，可以设置一报警死区。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="被控量变化率" varname="fPR" type="System.Single" visible="yes" exp="为了实现平稳控制，需要对参与控制的被控量的变化率加以限制。" optype="特定值优化" opvalue="0" opnode="defined PID_fPR_NOT0" relate="">0</Property>
        <Property name="被控量的上限状态" varname="cPHA" type="MyEnum" visible="yes" exp="被控量的上限报警状态，0代表不报警，1代表报警。" optype="" opvalue="" opnode="" relate="">无报警,报警</Property>
        <Property name="被控量的下限状态" varname="cPLA" type="MyEnum" visible="yes" exp="被控量的下限报警状态，0代表不报警，1代表报警。" optype="无优化" opvalue="" opnode="" relate="">无报警,报警</Property>
        <Property name="被控量上限报警" varname="fPH" type="System.Single" visible="yes" exp="被控量的上限报警值。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="被控量下限报警" varname="fPL" type="System.Single" visible="yes" exp="被控量的下限报警值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="比例" varname="Kp" type="System.Single" visible="yes" exp="PID计算中的增益。" optype="" opvalue="" opnode="" relate="">1</Property>
        <Property name="采集周期" varname="Ts" type="System.Int32" visible="yes" exp="PID控制回路的周期，以毫秒为单位。不能等于0，如果等于0，则使用缺省值1000毫秒。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
        <Property name="给定值的变化率" varname="fSR" type="System.Single" visible="yes" exp="给定值变化率的最大值，减少给定值突变对控制系统的扰动。" optype="特定值优化" opvalue="0" opnode="defined PID_fSR_NOT0" relate="">0</Property>
        <Property name="积分(秒)" varname="Ki" type="System.Single" visible="yes" exp="积分时间常数，以秒为单位。不能为0，如果为0，则是PD控制。" optype="特定值优化" opvalue="0" opnode="defined PID_Ki_NOT0" relate="">100000</Property>
        <Property name="记录上次的给定值" varname="fSV" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="defined PID_fSR_NOT0" relate="">0</Property>
        <Property name="内给定值" varname="fSVL" type="System.Single" visible="yes" exp="控制回路设定值，可以手工设定，程序设定或上级控制回路设定。 " optype="" opvalue="" opnode="" relate="">50</Property>
        <Property name="偏差" varname="ei" type="System.Single" visible="yes" exp="测量信号与设定值的差值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="偏差报警值" varname="fDL" type="System.Single" visible="yes" exp="偏差绝对值的最值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="偏差输入补偿方式" varname="cICM" type="MyEnum" visible="yes" exp="0代表无补偿，1代表加补偿，2代表减补偿，3代表置换补偿。" optype="值优化" opvalue="" opnode="defined PID_cICM_1 || defined PID_cICM_2 || defined PID_cICM_3" relate="">不考虑输入补偿,加补偿,减补偿,置换补偿</Property>
        <Property name="偏差输入补偿量" varname="fICV" type="System.Single" visible="yes" exp="偏差的输入补偿量，用于偏差的输入补偿。" optype="" opvalue="" opnode="defined PID_cICM_1 || defined PID_cICM_2 || defined PID_cICM_3" relate="">0</Property>
        <Property name="偏差死区" varname="fBSGP" type="System.Single" visible="yes" exp="为了避免控制回路在小信号时频繁动作，磨损执行机构，因此可以设定在偏差很小时，让输出不动作或小动作。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="偏差正作用/反作用" varname="cDorR" type="MyEnum" visible="yes" exp="表示输出的正反动作，如果是0表示正动作，输出随着输入的增大而增大，非0表示反动作，输出随着输入的增大而减少。" optype="值优化" opvalue="" opnode="" relate="">偏差反作用,偏差正作用</Property>
        <Property name="上次的偏差" varname="ei_1" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上上次的偏差" varname="ei_2" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="微分(秒)" varname="Kd" type="System.Single" visible="yes" exp="微分时间常数，以秒为单位。" optype="特定值优化" opvalue="0" opnode="" relate="">0</Property>
        <Property name="偏差报警状态" varname="cDLA" type="MyEnum" visible="yes" exp="大于偏差报警值，则为报警状态；否则无报警状态。" optype="" opvalue="" opnode="" relate="">无报警,报警</Property>
        <Property name="算法选择" varname="cSelect" type="MyEnum" visible="yes" exp="0：普通PID算法 1：积分分离PID算法 2：遇限削弱积分PID算法 3：微分先行PID算法 4：梯形积分PID算法" optype="值优化" opvalue="" opnode="" relate="">普通PID算法,积分分离PID算法,遇限削弱积分PID算法,微分先行PID算法,梯形积分PID算法</Property>
        <Property name="输出值" varname="fMV" type="System.Single" visible="yes" exp="控制回路的输出，一般直接作用于被控对象或在串级时作为下级控制控制回路的设定值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="积分分离因子" varname="fE0" type="System.Single" visible="yes" exp="当选择积分分离算法时因子参数。" optype="" opvalue="" opnode="defined PID_cSelect_1" relate="">0</Property>
        <Property name="控制量上限" varname="fMH" type="System.Single" visible="yes" exp="输出值的最大值。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="控制量下限" varname="fML" type="System.Single" visible="yes" exp="输出值的最小值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的被控量" varname="fPV_1" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="defined PID_cSelect_3 || defined PID_cSelect_4" relate="">0</Property>
        <Property name="上上次的被控量" varname="fPV_2" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="defined PID_cSelect_3 || defined PID_cSelect_4" relate="">0</Property>
        <Property name="输出补偿量" varname="fOCV" type="System.Single" visible="yes" exp="对输出值进行补偿操作的值。" optype="" opvalue="" opnode="defined PID_cOCM_1 || defined PID_cOCM_2 || defined PID_cOCM_3" relate="">0</Property>
        <Property name="输出补偿方式" varname="cOCM" type="MyEnum" visible="yes" exp="0代表无补偿，1代表加补偿，2代表减补偿，3代表置换补偿。" optype="值优化" opvalue="" opnode="defined PID_cOCM_1 || defined PID_cOCM_2 || defined PID_cOCM_3" relate="">不考虑输入补偿,加补偿,减补偿,置换补偿</Property>
        <Property name="输出变化率" varname="fMR" type="System.Single" visible="yes" exp="一个执行周期的输出最大变化范围，手动和安全态不会进行变化率限制。" optype="特定值优化" opvalue="0" opnode="defined PID_fMR_NOT0" relate="">100</Property>
        <Property name="输出保持" varname="cFHorNH" type="MyEnum" visible="yes" exp="1代表输出保持，现时刻的输出值为前一时刻的输出值；0代表正常输出。" optype="值优化" opvalue="" opnode="defined PID_cFHorNH_1" relate="">保持,不保持</Property>
        <Property name="安全输出" varname="cFSorNS" type="MyEnum" visible="yes" exp="表示当前控制回路是否处于紧急状态，0表示非安全输出状态，非0表示安全输出状态。" optype="值优化" opvalue="" opnode="defined PID_cFSorNS_1" relate="">安全输出,不安全输出</Property>
        <Property name="安全输出量" varname="fMS" type="System.Single" visible="yes" exp="发生紧急状态时控制回路的安全输出值。 " optype="" opvalue="" opnode="defined PID_cFSorNS_1" relate="">0</Property>
        <Property name="自动/手动" varname="cCtrlMode" type="MyEnum" visible="yes" exp="控制回路的控制方式。0表示手动，1表示自动。" optype="值优化" opvalue="" opnode="" relate="">自动,手动</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// PID控制
uint8 PIDControl(PIDStruct* PID)
{
     uint32 Ts;	 // 计算值,S单位
     fp32 ei,ei_1,ei_2;
     fp32 deltaMV;
     fp32 mv,sv,pv;
     
	
 	 Pop(&amp;paramStack,&amp;pv);  // 获得输入值
	 Pop(&amp;paramStack,&amp;sv);  // 获得设定值
	 #ifdef PID_Ts_0
  	 if(PID-&gt;Ts == 0)
     {   
        PID-&gt;Ts = 1000;
     }
	 #endif		 
 	 Ts = PID-&gt;Ts / (fp32)1000;
	 // 给定值处理    
	 if(sv &lt; 0)
	 {// 无输入或输入值不正确,采用内给
		sv = PID-&gt;fSVL;	
	 }
	 // 特定值优化
	 #ifdef PID_fSR_NOT0 // 0与非0优化        
     if(PID-&gt;fSR != 0 &amp;&amp; fabs(sv - PID-&gt;fSV) &gt; PID-&gt;fSR)
     {// 变化率超过范围
        sv = sv &gt; PID-&gt;fSV ? (PID-&gt;fSV + PID-&gt;fSR) : 
            (PID-&gt;fSV - PID-&gt;fSR); 
     }	     
     // 记录下给定值 
     PID-&gt;fSV = sv;
	 #endif

     // 被控量处理
     if(PID-&gt;cPHA == 0)
     {
        if(pv &gt; PID-&gt;fPH)
        {// 大于上限
            PID-&gt;cPHA = 1;
        }
     }
     else
     {// 已是报警状态
         if(pv &lt; PID-&gt;fPH - PID-&gt;fHY)
         {// 不在报警死区内
            PID-&gt;cPHA = 0; 
         }
     }
     if(PID-&gt;cPLA == 0)
     {
        if(pv &lt; PID-&gt;fPL)
        {// 小于下限
            PID-&gt;cPLA = 1;
        }
     }
     else			 
     {// 已是报警状态
         if(pv &gt; PID-&gt;fPL + PID-&gt;fHY)
         {// 不在报警死区内
            PID-&gt;cPLA = 0; 
         }
     }
	 #ifdef PID_fPR_NOT0
     if(PID-&gt;fPR != 0 &amp;&amp; fabs(pv - PID-&gt;fPV) &gt; PID-&gt;fPR)
     {// 变化率超过范围
        pv = pv &gt; PID-&gt;fPV ? (PID-&gt;fPV + PID-&gt;fPR) : 
            (PID-&gt;fPV - PID-&gt;fPR); 
     }
	 #endif

	 #if defined PID_cSelect_3 || defined PID_cSelect_4
     PID-&gt;fPV_2 = PID-&gt;fPV_1;
     PID-&gt;fPV_1 = PID-&gt;fPV; 
	 #endif 
	 #if defined PID_cSelect_3 || defined PID_cSelect_4 || PID_fPR_NOT0        
     // 记录下被控量
     PID-&gt;fPV = pv;
	 #endif

     // 偏差处理
	 #ifdef PID_cDorR_1
     if(PID-&gt;cDorR != 0)  
     {// 正作用
     	ei = pv - sv;
	 }     
	 #endif
	 #ifdef PID_cDorR_0
     if(PID-&gt;cDorR == 0)  
	 {// 反作用
     	ei = sv - pv;
	 }     
	 #endif
	 

     if(fabs(ei) &gt; PID-&gt;fDL)
     {// 超出报警值
         PID-&gt;cDLA = 1;
     }
     else
     {
         PID-&gt;cDLA = 0;
     }
     // 偏差死区处理
     if(fabs(ei) &lt;= PID-&gt;fBSGP)
     {
         ei = 0;
     }
	 #ifdef PID_cICM_1
	 if(PID-&gt;cICM == 1)
     {// 加补偿
     	ei += PID-&gt;fICV;
	 }     
	 #endif
	 #ifdef PID_cICM_2 
	 if(PID-&gt;cICM == 2)
     {// 减补偿    
     	ei -= PID-&gt;fICV;
	 }
	 #endif
	 #ifdef PID_cICM_3
	 if(PID-&gt;cICM == 3)
     {// 置换补偿     			
     	ei = PID-&gt;fICV;
	 }
	 #endif	 
	 ei_1 = PID-&gt;ei;
     ei_2 = PID-&gt;ei_1;

	 #ifdef PID_cCtrlMode_1
	 if(PID-&gt;cCtrlMode != 0)
	 {   
     	mv = PID-&gt;fMV;// 此MV通过人机界面通讯得到
	 }
	 #endif
	 #ifdef PID_cCtrlMode_0
	 if(PID-&gt;cCtrlMode == 0)
	 {    
        // PID计算 
       	#ifdef PID_cSelect_0		   
		  if(PID-&gt;cSelect == 0)
		  {// 普通PID
		  	 #if defined PID_Ki_0 &amp;&amp; defined PID_Kd_0
			 if(PID-&gt;Ki == 0 &amp;&amp; PID-&gt;Kd == 0)
             {// 只有比例因子起作用
                 mv = PID-&gt;Kp * ei;
             }
			 #endif
			 #if defined PID_Ki_0 &amp;&amp; defined PID_Kd_NOT0
             if(PID-&gt;Ki == 0 &amp;&amp; PID-&gt;Kd != 0)
             {// 积分因子不起作用   
                 deltaMV = PID-&gt;Kp * ( ei - ei_1 + (PID-&gt;Kd / Ts) * (ei- 2 * ei_1 + ei_2));
                 mv = PID-&gt;fMV + deltaMV;
             }
			 #endif
			 #if defined PID_Ki_NOT0
             if(PID-&gt;Ki != 0)
             {              
                deltaMV = PID-&gt;Kp * ( ei - ei_1 + Ts * ei / PID-&gt;Ki + (PID-&gt;Kd / Ts) * (ei- 2 * ei_1 + ei_2));
                mv = PID-&gt;fMV + deltaMV;
             }
			 #endif
		  }
		 #endif //PID_cSelect_0

		 #ifdef PID_cSelect_1
		   if(PID-&gt;cSelect == 1)
		   {// 积分分离PID算法
             if(fabs(ei) &gt; PID-&gt;fE0)
             {// 采用PD
			 	#ifdef PID_Kd_0
                if(PID-&gt;Kd == 0)
                {// 只有比例因子起作用
                    mv = PID-&gt;Kp * ei;                   
                }
				#endif
				#ifdef PID_Kd_NOT0
                if(PID-&gt;Kd != 0)
                {// 积分因子不起作用
                    deltaMV = PID-&gt;Kp * ( ei - ei_1 + (PID-&gt;Kd / Ts) * (ei- 2 * ei_1 + ei_2));
                    mv = PID-&gt;fMV + deltaMV;
                }
				#endif
             }
             else
             {// PID算法
                 #if defined PID_Ki_0 &amp;&amp; defined PID_Kd_0
					 if(PID-&gt;Ki == 0 &amp;&amp; PID-&gt;Kd == 0)
		             {// 只有比例因子起作用
		                 mv = PID-&gt;Kp * ei;
		             }
				 #endif
				 #if defined PID_Ki_0 &amp;&amp; defined PID_Kd_NOT0
		             if(PID-&gt;Ki == 0 &amp;&amp; PID-&gt;Kd != 0)
		             {// 积分因子不起作用   
		                 deltaMV = PID-&gt;Kp * ( ei - ei_1 + (PID-&gt;Kd / Ts) * (ei- 2 * ei_1 + ei_2));
		                 mv = PID-&gt;fMV + deltaMV;
		             }
				 #endif
				 #if defined PID_Ki_NOT0
		             if(PID-&gt;Ki != 0)
		             {              
		                deltaMV = PID-&gt;Kp * ( ei - ei_1 + Ts * ei / PID-&gt;Ki + (PID-&gt;Kd / Ts) * (ei- 2 * ei_1 + ei_2));
		                mv = PID-&gt;fMV + deltaMV;
		             }
				 #endif
            }
		  }			
        #endif	//PID_cSelect_1
		  
		#ifdef PID_cSelect_2
		  if(PID-&gt;cSelect == 2)
		  {// 遇限削弱积分PID算法
		  	 fp32 Up,Ud,Ui;  // 比例项，积分项，微分项
             Up = PID-&gt;Kp * ( ei - ei_1);
			 #ifdef PID_Ki_0
             if(PID-&gt;Ki == 0)
             {
                Ui = 0;
             }
			 #endif
			 #ifdef PID_Ki_NOT0
             if(PID-&gt;Ki != 0)
             {
                Ui = PID-&gt;Kp * Ts * ei / PID-&gt;Ki;
             }
			 #endif
             Ud = PID-&gt;Kp * (PID-&gt;Kd / Ts) * (ei- 2 * ei_1 + ei_2);
             if(mv &gt; PID-&gt;fMH)
             {// 大于控制量上限
                if(ei &gt; 0)
                {// 舍去积分
                    deltaMV = Up + Ud;
                }
                else
                {
                    deltaMV = Up + Ui + Ud;
                }
            }
            else if(mv &lt; PID-&gt;fML)
            {
                if(ei &lt; 0)
                {// 舍去积分
                    deltaMV = Up + Ud;  
                }
                else
                {
                    deltaMV = Up + Ui + Ud;
                }
            }
             else
             {
                  deltaMV = Up + Ui + Ud;
             }
             mv = PID-&gt;fMV + deltaMV;
		}	
		#endif //PID_cSelect_2
		#ifdef PID_cSelect_3 
		   if(PID-&gt;cSelect == 3)
		   {// 微分先行PID算法
		      #if defined PID_Ki_0 &amp;&amp; defined PID_Kd_NOT0   		  
              if(PID-&gt;Ki == 0 &amp;&amp; PID-&gt;Kd != 0)
              {// 积分因子不起作用  
                 deltaMV = PID-&gt;Kp * ( ei - ei_1 + (PID-&gt;Kd / Ts) * 
                     (PID-&gt;fPV - 2*PID-&gt;fPV_1 + PID-&gt;fPV_2));
                 mv = PID-&gt;fMV + deltaMV;
              }
			  #endif
			  #if defined PID_Ki_0 &amp;&amp; defined PID_Kd_0
              if(PID-&gt;Ki == 0 &amp;&amp; PID-&gt;Kd == 0)
              {// 只有比例因子起作用
                    mv = PID-&gt;Kp * ei;
              }
			  #endif
			  #if defined PID_Ki_NOT0
              if(PID-&gt;Ki != 0 )
              {             
                 deltaMV = PID-&gt;Kp * ( ei - ei_1 + Ts * ei / PID-&gt;Ki + (PID-&gt;Kd / Ts) * 
                     (PID-&gt;fPV - 2*PID-&gt;fPV_1 + PID-&gt;fPV_2));
                 mv = PID-&gt;fMV + deltaMV;
              }
			  #endif
		   }
		#endif	//PID_cSelect_3
        #ifdef PID_cSelect_4 
		   if(PID-&gt;cSelect == 4)
		   {// 梯形积分PID算法				 	 
              #if defined PID_Ki_0 &amp;&amp; defined PID_Kd_NOT0   		  
              if(PID-&gt;Ki == 0 &amp;&amp; PID-&gt;Kd != 0)
              {// 积分因子不起作用    
                 deltaMV = PID-&gt;Kp * ( ei - ei_1 + (PID-&gt;Kd / Ts) * 
                     (PID-&gt;fPV - 2*PID-&gt;fPV_1 + PID-&gt;fPV_2));
                 mv = PID-&gt;fMV + deltaMV;
              }
			  #endif
			  #if defined PID_Ki_0 &amp;&amp; defined PID_Kd_0
              if(PID-&gt;Ki == 0 &amp;&amp; PID-&gt;Kd == 0)
              {// 只有比例因子起作用
                mv = PID-&gt;Kp * ei;
              }
              #endif
			  #if defined PID_Ki_NOT0
              if(PID-&gt;Ki != 0)
              {              
                 deltaMV = PID-&gt;Kp * ( ei - ei_1 + (Ts/PID-&gt;Ki) * (ei + ei_1)/2 + (PID-&gt;Kd / Ts) * 
                     (PID-&gt;fPV - 2*PID-&gt;fPV_1 + PID-&gt;fPV_2));
                 mv = PID-&gt;fMV + deltaMV;
              }	
			  #endif
		   }
		#endif 	//PID_cSelect_4
	}  
	#endif	//PID_cCtrlMode_0

	// 控制量处理
	#ifdef PID_cOCM_1
	if(PID-&gt;cOCM == 1)
	{// 加
    	mv += PID-&gt;fOCV;
	}
	#endif
	#ifdef PID_cOCM_2
	if(PID-&gt;cOCM == 2)
	{// 减
    	mv -= PID-&gt;fOCV;
	}
	#endif
	#ifdef PID_cOCM_3
	if(PID-&gt;cOCM == 3)
	{// 置换
    	mv = PID-&gt;fOCV;
	}
	#endif 	
	#ifdef PID_fMR_NOT0
    if(PID-&gt;fMR != 0 &amp;&amp; fabs(mv - PID-&gt;fMV) &gt; PID-&gt;fMR)
    {// 变化率限制
         mv = mv &gt; PID-&gt;fMV ? (PID-&gt;fMV + PID-&gt;fMR) : 
            (PID-&gt;fMV - PID-&gt;fMR); 
    }
	#endif

	#ifdef PID_cFHorNH_1
	if(PID-&gt;cFHorNH != 0)
    {// 输出保持
        mv = PID-&gt;fMV;
    }
	#endif
	#ifdef PID_cFSorNS_1
    if(PID-&gt;cFSorNS != 0)
    {// 安全输出
        mv = PID-&gt;fMS;
    }
	#endif
    // 输出最值的处理
    mv = mv &gt; PID-&gt;fMH ? PID-&gt;fMH : mv;
    mv = mv &lt; PID-&gt;fML ? PID-&gt;fML : mv; 
    
    // 保存值
    PID-&gt;fMV = mv;
    (*PID).ei = ei;
    (*PID).ei_1 = ei_1;
    (*PID).ei_2 = ei_2;

	// 压栈
 	Push(&amp;paramStack,mv); 
	return 1;
}      </Property>
        <Property name="Description">指令名：ＰＩＤ

在过程控制中，按偏差的比例(P)、积分(I)和微分(D)进行控制
的PID控制器（亦称PID调节器）是应用最为广泛的一种自动控
制器。它具有原理简单，易于实现，适用面广,控制参数相互独
立,参数的选定比较简单等优点；而且在理论上可以证明，对于
过程控制的典型对象──“一阶滞后＋纯滞后”与“二阶滞后
＋纯滞后”的控制对象，PID控制器是一种最优控制。所以，虽
然近20多年相继出现一批复杂的，只有计算机才能实现的控制
算法，然而在目前，即使在过程计算机控制中，PID控制仍然是
应用最广的控制算法。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,最少拍控制器,控制算法">
      <BasicProperty>
        <Property name="ModuleName">LEAST</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">IN</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">最少拍控制器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="被控对象的放大系数" varname="fK" type="System.Single" visible="yes" exp="被控对象放大系数。" optype="特定值优化" opvalue="0" opnode="" relate="">1</Property>
        <Property name="一阶被控对象的时间常数" varname="ulT1" type="System.Int32" visible="yes" exp="被控对象时间常数，以毫秒为单位。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
        <Property name="被控对象的纯滞后时间" varname="ulTao" type="System.Single" visible="yes" exp="被控对象纯滞后时间，以毫秒为单位。" optype="" opvalue="" opnode="" relate="">10000</Property>
        <Property name="采样周期" varname="ulTs" type="System.Int32" visible="yes" exp="控制回路的周期，以毫秒为单位。不能等于0，如果等于0，则使用缺省值1000毫秒。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
        <Property name="输出高限" varname="fMH" type="System.Single" visible="yes" exp="输出的最大值。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出低限" varname="fML" type="System.Single" visible="yes" exp="输出的最小值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="自动/手动" varname="cCtrlMod" type="MyEnum" visible="yes" exp="0：自动；1：手动" optype="值优化" opvalue="" opnode="" relate="">自动,手动</Property>
        <Property name="上次的偏差" varname="fei" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输出" varname="fMV" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="设定值" varname="fSV" type="System.Single" visible="yes" exp="控制回路设定值。" optype="" opvalue="" opnode="" relate="">50</Property>
        <Property name="输入队列" varname="queueMV" type="queue" visible="no" exp="" optype="" opvalue="" opnode="" relate="">NULL</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 最少拍控制
uint8 LEASTControl(LEASTStruct *LEAST)
{
    fp32 fPV,fMV,fei_1,fei,fMV_N_1;
    uint32 historyInNum;  // 输出元素个数
    uint32 qLength;  // 队列中元素个数
  
    fp32 ulTs,ulT1;
    fp32 fK;
    fp32 fMH,fML; // 输出最值
    
   
	Pop(&amp;paramStack,&amp;fPV);

	#ifdef LEAST_ulT1_0
	if(LEAST-&gt;ulT1 == 0)
    {// 时间常数
        LEAST-&gt;ulT1 = 1000;
    }
    #endif
  #ifdef LEAST_ulTs_0
	if(LEAST-&gt;ulTs == 0)
    {// 时间常数
        LEAST-&gt;ulTs = 1000;
    }
  #endif
	
    fMH = LEAST-&gt;fMH;
    fML = LEAST-&gt;fML;
	ulTs = LEAST-&gt;ulTs / (fp32)1000;
    fei = LEAST-&gt;fSV - fPV;
    fei_1 = LEAST-&gt;fei;
    ulT1 = LEAST-&gt;ulT1 / (fp32)1000;
    fK = LEAST-&gt;fK;     

    // 输出队列处理
    if(LEAST-&gt;queueMV == NULL)
    {// 队列不存在时,初始化队列
        InitQueue(&amp;LEAST-&gt;queueMV);
    }
    qLength = QueueLength(LEAST-&gt;queueMV);

    historyInNum = (uint32)(LEAST-&gt;ulTao / LEAST-&gt;ulTs);
    while(historyInNum &gt; qLength)
    {// 当队列个数不满时
        EnQueue(&amp;LEAST-&gt;queueMV,0);// 插入0
        qLength++;
    }
    while(historyInNum &lt; qLength)
    {// 当队列个数超出时
        DeQueue(&amp;LEAST-&gt;queueMV,&amp;fMV_N_1);// 删除最原始的数据
        qLength--;
    }

    DeQueue(&amp;LEAST-&gt;queueMV,&amp;fMV_N_1);
	#ifdef LEAST_cCtrlMod_1       
    if(LEAST-&gt;cCtrlMod != 0)
    {// 手动
        fMV = LEAST-&gt;fMV;
    }
	#endif
	#ifdef LEAST_cCtrlMod_0
    if(LEAST-&gt;cCtrlMod == 0)
    {// 自动
	 	#ifdef LEAST_fK_0
		if(LEAST-&gt;fK == 0)
    	{// 放大系数
        	fMV = 0;
    	}
		#endif
		#ifdef LEAST_fK_NOT0
		if(LEAST-&gt;fK != 0)
		{
			fp32 a;        
	        a = exp(-(fp32)ulTs/ulT1);          
	        fMV = (fei - a * fei_1) / (fK*(1-a)) + fMV_N_1;
		}
		#endif
    }// 自动
	#endif
	// 最值处理
    fMV = fMV &gt; fMH ? fMH : fMV;
    fMV = fMV &lt; fML ? fML : fMV;
    // 保存
    LEAST-&gt;fMV = fMV;
    LEAST-&gt;fei = fei;
    EnQueue(&amp;LEAST-&gt;queueMV,fMV);    
	Push(&amp;paramStack,fMV);
	return 1;
}</Property>
        <Property name="Description">指令名：ＬＡＥＳＴ

所谓最少拍控制，是指系统在某种典型输入信号（如阶跃信
号、速度信号、加速度信号等）作用下，经过最少的采样周期
使得系统输出的稳态误差为零。 </Property>
        <Property name="OptimizeInfo">OPTIMISE_QUEUE</Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,大林控制器,控制算法">
      <BasicProperty>
        <Property name="ModuleName">DARLIN</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">IN</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">大林控制器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输出高限" varname="fMH" type="System.Single" visible="yes" exp="输出的最大值。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出低限" varname="fML" type="System.Single" visible="yes" exp="输出的最小值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="被控对象的放大系数" varname="fK" type="System.Single" visible="yes" exp="被控对象放大系数。" optype="特定值优化" opvalue="0" opnode="" relate="">1</Property>
        <Property name="时间常数1" varname="ulT1" type="System.Int32" visible="yes" exp="被控对象时间常数1，以毫秒为单位。" optype="特定值优化" opvalue="0/ulT2" opnode="" relate="">1000</Property>
        <Property name="时间常数2" varname="ulT2" type="System.Int32" visible="yes" exp="被控对象时间常数2，以毫秒为单位。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
        <Property name="闭环系统时间常数" varname="ulTTao" type="System.Int32" visible="yes" exp="闭环系统的时间常数，以毫秒为单位。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
        <Property name="采样周期" varname="ulTs" type="System.Int32" visible="yes" exp="控制回路的周期，以毫秒为单位。不能等于0，如果等于0，则使用缺省值1000毫秒。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
        <Property name="滞后时间" varname="ulTao" type="System.Int32" visible="yes" exp="被控对象纯滞后时间，以毫秒为单位。" optype="" opvalue="" opnode="" relate="">10000</Property>
        <Property name="自动/手动" varname="cCtrlMod" type="MyEnum" visible="yes" exp="0：自动；1：手动" optype="值优化" opvalue="" opnode="" relate="">自动,手动</Property>
        <Property name="输出" varname="fMV" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上上次的输出" varname="fMV_1" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次的偏差" varname="fei" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上上次的偏差" varname="fei_1" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="设定值" varname="fSV" type="System.Single" visible="yes" exp="控制回路设定值。" optype="" opvalue="" opnode="" relate="">50</Property>
        <Property name="输入队列" varname="queueMV" type="queue" visible="no" exp="" optype="" opvalue="" opnode="" relate="">NULL</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 大林算法
uint8 DARLINControl(DARLINStruct *DARLIN)
{
    fp32 fPV,fMV,fei,fei_1,fei_2,fMV_N_1,fMV_1,fMV_N_2,fMV_2;
    uint32 historyInNum;  // 输出元素个数
    uint32 qLength;  // 队列中元素个数
    
    fp32 ulTs,ulT1,ulT2,ulTTao;
    fp32 fK;
    fp32 fMH,fML; // 输出最值

	Pop(&amp;paramStack,&amp;fPV);

	#ifdef DARLIN_ulTs_0
	if(DARLIN-&gt;ulTs == 0)
    {// 周期
        DARLIN-&gt;ulTs = 1000;
    }
	#endif
	#ifdef DARLIN_ulT1_0
    if(DARLIN-&gt;ulT1 == 0)
    {
        DARLIN-&gt;ulT1 = 1000;
    }
	#endif
	#ifdef DARLIN_ulTTao_0
	if(DARLIN-&gt;ulTTao == 0)
    {
        DARLIN-&gt;ulTTao = 1000;
    }
	#endif
	

    ulTs = DARLIN-&gt;ulTs / (fp32)1000;
    ulT1 = DARLIN-&gt;ulT1 / (fp32)1000;
    ulT2 = DARLIN-&gt;ulT2 / (fp32)1000;
    ulTTao = DARLIN-&gt;ulTTao / (fp32)1000;    
    fMH = DARLIN-&gt;fMH;
    fML = DARLIN-&gt;fML;
    
	fei = DARLIN-&gt;fSV - fPV;
    fei_1 = DARLIN-&gt;fei;
    fei_2 = DARLIN-&gt;fei_1;
    fK = DARLIN-&gt;fK;
    fMV_1 = DARLIN-&gt;fMV;
    fMV_2 = DARLIN-&gt;fMV_1;      

    // 输出队列处理
    if(DARLIN-&gt;queueMV == NULL)
    {// 队列不存在时,初始化队列
        InitQueue(&amp;DARLIN-&gt;queueMV);
    }
    qLength = QueueLength(DARLIN-&gt;queueMV);

	#ifdef DARLIN_ulT2_0
    if(ulT2 == 0)
    {
        historyInNum = (uint32)(DARLIN-&gt;ulTao / DARLIN-&gt;ulTs);
    }
	#endif
	#ifdef DARLIN_ulT2_NOT0
    if(ulT2 != 0)
    {// 二阶对象时,得多存一个
        historyInNum = (uint32)(DARLIN-&gt;ulTao / DARLIN-&gt;ulTs) + 1;
    }
	#endif
    while(historyInNum &gt; qLength)
    {// 当队列个数不满时
        EnQueue(&amp;DARLIN-&gt;queueMV,0);// 插入0
        qLength++;
    }
    while(historyInNum &lt; qLength)
    {// 当队列个数超出时
        DeQueue(&amp;DARLIN-&gt;queueMV,&amp;fMV_N_1);// 删除最原始的数据
        qLength--;
    }
	DeQueue(&amp;DARLIN-&gt;queueMV,&amp;fMV_N_1);
	
	#ifdef DARLIN_cCtrlMod_1          
    if(DARLIN-&gt;cCtrlMod != 0)
    {// 手动
        fMV = DARLIN-&gt;fMV;
    }
    #endif
	#ifdef DARLIN_cCtrlMod_0
	if(DARLIN-&gt;cCtrlMod == 0)
    {// 自动
		#ifdef DARLIN_fK_0
		if(DARLIN-&gt;fK == 0)
	    {
	        fMV = 0;
	    }
		#endif
		#ifdef DARLIN_fK_NOT0
		if(DARLIN-&gt;fK != 0)
		{
			fp32 a,b;  // 计算时的临时变量
		    a = exp(-ulTs/ulTTao);
		    b = exp(-ulTs/ulT1);
			#ifdef DARLIN_ulT2_0
		    if(ulT2 == 0)
		    {// 一阶对象
		        fMV=((1-a)*fei-b*(1-a)*fei_1+fK*a*(1-b)*fMV_1+fK*(1-a)*(1-b)*fMV_N_1)/(fK*(1-b));            
		    }
			#endif
		    #ifdef DARLIN_ulT2_NOT0
		    if(ulT2 != 0)
		    {// 二阶对象
				#ifdef DARLIN_ulT1_ulT2
		        if(ulT1 == ulT2)
		        {
		            fMV = 0;
		        }
				#endif
				#ifdef DARLIN_ulT1_NOTulT2
		        if(ulT2 != ulT2)
		        {
					fp32 c,c1,c2;
    			    fp32 temp1,temp2;                
		            fMV_N_2 = GetQueueElement(DARLIN-&gt;queueMV);
		            c=exp(-ulTs/ulT2);
		            c1=1+(ulT1*b-ulT2*c)/(ulT2-ulT1);
		            c2=b*c+(ulT1*c-ulT2*b)/(ulT2-ulT1);
		            temp1=((1-a)*fei-(c+b)*(1-a)*fei_1+b*c*fei_2*(1-a))/fK;
		            temp2=(c2-c1*a)*fMV_1-c2*a*fMV_2-c1*(1-a)*fMV_N_2-c2*(1-a)*fMV_N_1;
		            fMV = temp1 - temp2;
		        }
				#endif
		    }
			#endif
		}
		#endif		
    }// 自动
	#endif
	// 最值处理
    fMV = fMV &gt; fMH ? fMH : fMV;
    fMV = fMV &lt; fML ? fML : fMV;
    // 保存
    DARLIN-&gt;fMV = fMV;
    DARLIN-&gt;fMV_1 = fMV_1;
    DARLIN-&gt;fei = fei;                  
    DARLIN-&gt;fei_1 = fei_1;                  
    EnQueue(&amp;DARLIN-&gt;queueMV,fMV);	
	Push(&amp;paramStack,fMV);
	return 1;
}</Property>
        <Property name="Description">指令名：ＤＡＲＬＩＮ

大林算法的设计目标是使整个闭环系统所期望的传递函数相当
于一个延迟环节和一个惯性环节相串联，并期望整个闭环系统
的纯滞后时间和被控对象的纯滞后时间相同。</Property>
        <Property name="OptimizeInfo">OPTIMISE_QUEUE</Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.Arithmetic,ControlTactic,前馈器,控制算法">
      <BasicProperty>
        <Property name="ModuleName">PRE</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">IN</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">前馈器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输出高限" varname="fMH" type="System.Single" visible="yes" exp="输出的最大值。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="输出低限" varname="fML" type="System.Single" visible="yes" exp="输出的最小值。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="扰动对象的放大系数" varname="fK1" type="System.Single" visible="yes" exp="扰动通道的放大系数。" optype="" opvalue="" opnode="" relate="">1</Property>
        <Property name="被控对象的时间常数" varname="ulT2" type="System.Int32" visible="yes" exp="被控对象的时间常数，以毫秒为单位。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="扰动通道的时间常数" varname="ulT1" type="System.Int32" visible="yes" exp="扰动通道的时间常数，以毫秒为单位。" optype="" opvalue="" opnode="" relate="">10000</Property>
        <Property name="采样周期" varname="ulTs" type="System.Int32" visible="yes" exp="控制回路的周期，以毫秒为单位。不能等于0，如果等于0，则使用缺省值1000毫秒。" optype="" opvalue="" opnode="" relate="">1000</Property>
        <Property name="被控对象的放大系数" varname="fK2" type="System.Single" visible="yes" exp="被控对象的放大系数。" optype="" opvalue="" opnode="" relate="">1</Property>
        <Property name="扰动通道的滞后时间" varname="ulTTao1" type="System.Int32" visible="yes" exp="扰动通道的滞后时间，以毫秒为单位。" optype="" opvalue="" opnode="" relate="">10000</Property>
        <Property name="自动/手动" varname="cCtrlMod" type="MyEnum" visible="yes" exp="0：自动；1：手动" optype="" opvalue="" opnode="" relate="">自动,手动</Property>
        <Property name="上次的输出" varname="fMV" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="输入队列" varname="queuePV" type="queue" visible="no" exp="" optype="" opvalue="" opnode="" relate="">NULL</Property>
        <Property name="被控对象的滞后时间" varname="ulTTao2" type="System.Int32" visible="yes" exp="被控对象纯滞后时间，以毫秒为单位。" optype="" opvalue="" opnode="" relate="">10000</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 前馈控制
uint8 PREControl(PREStruct *PRE)
{
    fp32 fPV,fMV,fMV_1,fPV_N,fPV_N_1;
    uint32 historyInNum;  // 输出元素个数
    uint32 qLength;  // 队列中元素个数

    fp32 ulTs,ulT1,ulT2,ulTTao1,ulTTao2;
    fp32 fK1,fK2;
    fp32 fMH,fML; // 输出最值

	Pop(&amp;paramStack,&amp;fPV);

	#ifdef PRE_ulTs_0
	if(PRE-&gt;ulTs == 0)
    {// 周期
        PRE-&gt;ulTs = 1000;
    }
	#endif
	#ifdef PRE_ulT1_0 
	if(PRE-&gt;ulT1 == 0)
    {// 扰动时间常数
        PRE-&gt;ulT1   = 1000;
    }
	#endif
	 
    ulTs = PRE-&gt;ulTs / (fp32)1000;
    fMH = PRE-&gt;fMH;
    fML = PRE-&gt;fML;
    
    fK1 = PRE-&gt;fK1;
    fK2 = PRE-&gt;fK2; 
    ulT1 = PRE-&gt;ulT1 / (fp32)1000;
    ulT2 = PRE-&gt;ulT2 / (fp32)1000;
    ulTTao1 = PRE-&gt;ulTTao1 / (fp32)1000;
	ulTTao2 = PRE-&gt;ulTTao2 / (fp32)1000;
    fMV_1 = PRE-&gt;fMV;
          

    // 输出队列处理
    if(PRE-&gt;queuePV == NULL)
    {// 队列不存在时,初始化队列
        InitQueue(&amp;PRE-&gt;queuePV);
    }
    qLength = QueueLength(PRE-&gt;queuePV);

    historyInNum = (uint32)((ulTTao1 - ulTTao2) / ulTs) + 1;
    while(historyInNum &gt; qLength)
    {// 当队列个数不满时
        EnQueue(&amp;PRE-&gt;queuePV,0);// 插入0
        qLength++;
    }
    while(historyInNum &lt; qLength)
    {// 当队列个数超出时
        DeQueue(&amp;PRE-&gt;queuePV,&amp;fPV_N);// 删除最原始的数据
        qLength--;
    }

    DeQueue(&amp;PRE-&gt;queuePV,&amp;fPV_N_1);
	#ifdef PRE_cCtrlMod_1      
    if(PRE-&gt;cCtrlMod != 0)
    {// 手动
        fMV = PRE-&gt;fMV;
    }
	#endif	// PRE_cCtrlMod_1
	#ifdef PRE_cCtrlMod_0
    if(PRE-&gt;cCtrlMod == 0)
    {// 自动
		#ifdef PRE_fK2_0
		if(PRE-&gt;fK2 == 0)
		{
		    fMV = 0;
		}
		#endif // PRE_fK2_0
		#ifdef PRE_fK2_NOT0  
		if(PRE-&gt;fK2 != 0)
		{
			fp32 a,b,c,fKf;      
	        if(historyInNum == 1)
	        {
	            fPV_N = fPV;
	        }
	        else
	        {
	            fPV_N = GetQueueElement(PRE-&gt;queuePV);
	        }
	        fKf = -(fK1 * ulT2)/(fK2 * ulT1);
	        a = (fp32)ulT1 / (ulT1 + ulTs);
	        b = fKf * ulT1 * (ulTs + ulT2) / (ulT2 * (ulTs + ulT1));
	        c = -fKf * ulT1 / (ulTs + ulT1);         
	        fMV = a * fMV_1 + b * fPV_N + c * fPV_N_1;
        }
		#endif // PRE_fK2_NOT0 
    }// 自动
	#endif	// PRE_cCtrlMod_0
	// 最值处理
    fMV = fMV &gt; fMH ? fMH : fMV;
    fMV = fMV &lt; fML ? fML : fMV;
    // 保存
    PRE-&gt;fMV = fMV;         
    EnQueue(&amp;PRE-&gt;queuePV,fPV);
	Push(&amp;paramStack,fMV);
	return 1;
}  </Property>
        <Property name="Description">指令名：ＰＲＥ

前馈控制是按扰动量进行控制的，当系统出现扰动时，前馈控
制就按扰动量直接产生校正作用，以抵消扰动的影响。</Property>
        <Property name="OptimizeInfo">OPTIMISE_QUEUE</Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.SpecialControl.JieOu,ControlTactic,解耦补偿控制器,控制算法">
      <BasicProperty>
        <Property name="ModuleName">JIEOU</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">OUT0,OUT1</Property>
        <Property name="InputName">IN0,IN1</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">解耦补偿控制器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="解耦路数" varname="iN" type="System.Int32" visible="yes" exp="几路解耦。" optype="" opvalue="" opnode="" relate="">2</Property>
        <Property name="解耦矩阵的参数" varname="paramMatrix" type="System.Single" visible="no" exp="解耦矩阵的参数N*N矩阵,一般是用被控对象的比例系数作为参数。" optype="" opvalue="" opnode="" relate="">array</Property>
        <Property name="上次偏差数组" varname="ei" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上上次偏差数组" varname="ei_1" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="上次控制器输出" varname="fUk" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="比例" varname="fKp" type="System.Single" visible="no" exp="PID计算中的增益。" optype="" opvalue="" opnode="" relate="">array</Property>
        <Property name="积分" varname="fKi" type="System.Single" visible="no" exp="积分时间常数，以秒为单位。不能为0，如果为0，则是PD控制。" optype="" opvalue="" opnode="" relate="">array</Property>
        <Property name="微分" varname="fKd" type="System.Single" visible="no" exp="微分时间常数，以秒为单位。" optype="" opvalue="" opnode="" relate="">array</Property>
        <Property name="设定值" varname="fSV" type="System.Single" visible="no" exp="控制回路设定值。" optype="" opvalue="" opnode="" relate="">array</Property>
        <Property name="自动/手动" varname="cCtrlMod" type="MyEnum" visible="no" exp="" optype="" opvalue="" opnode="" relate="">array</Property>
        <Property name="控制量上限" varname="fMH" type="System.Single" visible="no" exp="输出值的最大值。" optype="" opvalue="" opnode="" relate="">array</Property>
        <Property name="控制量下限" varname="fML" type="System.Single" visible="no" exp="输出值的最小值。" optype="" opvalue="" opnode="" relate="">array</Property>
        <Property name="控制量输出" varname="fMV" type="System.Single" visible="no" exp="控制回路的输出。" optype="" opvalue="" opnode="" relate="">array</Property>
        <Property name="采样周期" varname="ulTs" type="System.Int32" visible="yes" exp="控制回路的周期，以毫秒为单位。不能等于0，如果等于0，则使用缺省值1000毫秒。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
        <Property name="解耦矩阵" varname="jieOuMatrix" type="queue" visible="no" exp="" optype="" opvalue="" opnode="" relate="">NULL</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 解耦控制
uint8 JIEOUControl(JIEOUStruct *JIEOU)
{
    fp32 *JieOuMatrix(fp32 *matrix,uint32 n);
    fp32 *fPV;
    uint32 iN;    // 几路
    int32 i,j;
    fp32 *paramMatrix;  // 解耦的参数矩阵 
    fp32 *ei,*ei_1,*ei_2;  // 偏差
    fp32 *fKp,*fKi,*fKd,*fSV,*fMV;
    uint8 *cCtrlMod;    
    fp32 ulTs;
    fp32 *fUk,*fUk_1;  // 控制器输出

	#ifdef JIEOU_ulTs_0
	if(JIEOU-&gt;ulTs == 0)
	{
		JIEOU-&gt;ulTs = 1000;	
	}
	#endif
    fKp = JIEOU-&gt;fKp;
    fKi = JIEOU-&gt;fKi;
    fKd = JIEOU-&gt;fKd;
    fSV = JIEOU-&gt;fSV;   
    cCtrlMod = JIEOU-&gt;cCtrlMod;
    ulTs = JIEOU-&gt;ulTs / (fp32)1000;
    iN = JIEOU-&gt;iN;
    paramMatrix = JIEOU-&gt;paramMatrix;	
    fUk_1 = JIEOU-&gt;fUk;
    ei_2 = JIEOU-&gt;ei_1;
    ei_1 = JIEOU-&gt;ei;
    ei = (fp32 *)malloc(sizeof(fp32) * iN);
    fUk = (fp32 *)malloc(sizeof(fp32) * iN);
	fMV = (fp32 *)malloc(sizeof(fp32) * iN);
	fPV = (fp32 *)malloc(sizeof(fp32) * iN);
	
    // 求得解耦矩阵
	if(JIEOU-&gt;jieOuMatrix == NULL)
	{
   		 JIEOU-&gt;jieOuMatrix = JieOuMatrix(paramMatrix,iN);		 
	}
    // 求得每路控制器输出
    for(i = iN - 1;i &gt;= 0;i--)
    {           
		Pop(&amp;paramStack,&amp;fPV[i]);   
        ei[i] = fSV[i] - fPV[i];		        
        
        // 算出控制器输出
        if(fKi == 0)
        {// 积分不起作用
            fUk[i] = fUk_1[i]+fKp[i]*(ei[i]-ei_1[i]+(fKd[i]/ulTs)*(ei[i]-2*ei_1[i]+ ei_2[i]));
        }
        else
        {
            fUk[i] = fUk_1[i]+fKp[i]*(ei[i]-ei_1[i]+ulTs*ei[i]/fKi[i]+(fKd[i]/ulTs)*(ei[i]- 2*ei_1[i]+ei_2[i]));
        }
        fUk[i] = fUk[i] &gt; 1 ? 1 : fUk[i];
        fUk[i] = fUk[i] &lt; 0 ? 0 : fUk[i];
    }// 循环每个回路
	
	// 求得解耦输出
    for(i = 0;i &lt; iN;i++)
    {
        if(cCtrlMod[i] != 1)        
        {// 自动  
            fMV[i] = 0;
            for(j = 0;j &lt; iN;j++)
            {
                fMV[i] += fUk[j]* JIEOU-&gt;jieOuMatrix[i*iN+j]; // 这便是耦合关系,不能拆开算
            }            				
		}
		else
		{// 手
		 	fMV[i] = JIEOU-&gt;fMV[i];	
		}
		fMV[i] = fMV[i] &gt; JIEOU-&gt;fMH[i] ? JIEOU-&gt;fMH[i] : fMV[i];
        fMV[i] = fMV[i] &lt; JIEOU-&gt;fML[i] ? JIEOU-&gt;fML[i] : fMV[i];
		// 保存
		JIEOU-&gt;fMV[i] = fMV[i];
        JIEOU-&gt;ei[i] = ei[i];
        JIEOU-&gt;ei_1[i] = ei_1[i];
        JIEOU-&gt;fUk[i] = fUk[i];                
		Push(&amp;paramStack,fMV[i]);
	}
	// 释放
	free(ei);
	free(fUk);
	free(fMV);
	free(fPV);
	return 1;
}</Property>
        <Property name="Description">指令名：ＪＩＥＯＵ

在实际生产过程中，各个变量之间相互耦合、相互影响的控制
系统是普遍存在的。而且在多数情况下，由于这种耦合，使得
系统的性能很差，过程长久不能平稳下来，直接影响质量，严
重时还会使系统无法正常工作，甚至造成生产事故，危及设备
和人身安全。为此必须进行“解耦”，把各个回路之间相互耦
合的多输入-多输出系统变换为若干个相互独立的单变量系统。</Property>
        <Property name="OptimizeInfo">OPTIMISE_MATRIX</Property>
      </OtherInfo>
    </FDToolBoxItem>
    <FDToolBoxItem Type="ControlTactic.SpecialControl.Fuzzy,ControlTactic,模糊控制器,控制算法">
      <BasicProperty>
        <Property name="ModuleName">FUZZY</Property>
        <Property name="TextColor">255,0,0,255</Property>
        <Property name="OutputName">PV</Property>
        <Property name="InputName">IN</Property>
        <Property name="ModuleColor">255,102,205,170</Property>
        <Property name="ModuleSort">模糊控制器</Property>
      </BasicProperty>
      <FunctionProperty>
        <Property name="模块点名" varname="portnum" type="System.Int32" visible="yes" exp="描述模块的唯一标识。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="模糊控制表" varname="fuzzyControlList" type="System.Single" visible="no" exp="用于查表的模糊控制表，离线计算可得。" optype="" opvalue="" opnode="" relate="">array</Property>
        <Property name="采样周期" varname="ulTs" type="System.Int32" visible="yes" exp="控制回路的周期，以毫秒为单位。不能等于0，如果等于0，则使用缺省值1000毫秒。" optype="特定值优化" opvalue="0" opnode="" relate="">1000</Property>
        <Property name="偏差最值" varname="fEH" type="System.Single" visible="yes" exp="偏差的最值。" optype="特定值优化" opvalue="0" opnode="" relate="">100</Property>
        <Property name="偏差变化率最值" varname="fECH" type="System.Single" visible="yes" exp="偏差变化率的最值。" optype="特定值优化" opvalue="0" opnode="" relate="">100</Property>
        <Property name="输出最值" varname="fUH" type="System.Single" visible="yes" exp="控制量的最值。" optype="" opvalue="" opnode="" relate="">100</Property>
        <Property name="自动/手动" varname="cCtrlMod" type="MyEnum" visible="yes" exp="0：自动；1：手动" optype="值优化" opvalue="" opnode="" relate="">自动,手动</Property>
        <Property name="偏差模糊论域" varname="ulL" type="System.Int32" visible="no" exp="偏差的论域[-l, l]。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="偏差变化率模糊论域" varname="ulM" type="System.Int32" visible="no" exp="偏差变化率的论域[-m, m]。" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="偏差" varname="fEi" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="控制量模糊论域" varname="ulN" type="System.Int32" visible="yes" exp="输出的模糊量论域[-n, n]。" optype="特定值优化" opvalue="0" opnode="" relate="">0</Property>
        <Property name="输出" varname="fMV" type="System.Single" visible="no" exp="" optype="" opvalue="" opnode="" relate="">0</Property>
        <Property name="设定值" varname="fSV" type="System.Single" visible="yes" exp="控制回路设定值。" optype="" opvalue="" opnode="" relate="">0</Property>
      </FunctionProperty>
      <OtherInfo>
        <Property name="CodeInfo">// 量化,模糊化
uint32 ClearToFuzzy(fp32 clearValue,fp32 scale,uint32 ulH)
{
    int32 fuzzyValue;

    fuzzyValue = clearValue * scale;
    if(fuzzyValue &gt; (int32)ulH)
    {
        fuzzyValue = ulH;
    }
    //fuzzyValue = fuzzyValue &lt; (-ulH) ? (-ulH) : fuzzyValue;
    if(fuzzyValue &lt; (int32)-ulH)
    {
        fuzzyValue = -ulH;
    }

    return fuzzyValue;
}
// 清晰化
fp32 FuzzyToClear(fp32 FuzzyValue ,fp32 ProportionGene,fp32 ClearMax) 
{
    fp32 Result;
    Result=FuzzyValue * ProportionGene;
    if ( Result &gt; ClearMax )
    {
        Result=ClearMax;
    }
    else if ( Result &lt; (-ClearMax) )
    {
        Result= (-ClearMax);
    }
    return Result;
}
// 模糊控制
uint8 FUZZYControl(FUZZYStruct *FUZZY)
{
    fp32 fPV,fDeltaMV;
    fp32 fEH,fECH,fEi,fUH,fMV,fEi_1;    
	fp32 ulTs;
    uint8 cCtrlMod;
	
	Pop(&amp;paramStack,&amp;fPV);
	#ifdef FUZZY_ulTs_0
	if(FUZZY-&gt;ulTs == 0)
	{
		FUZZY-&gt;ulTs = 1000;	
	}
	#endif
	#ifdef FUZZY_fEH_0
	if(FUZZY-&gt;fEH == 0)
	{
		FUZZY-&gt;fEH = 1;	
	}
	#endif
	#ifdef FUZZY_fECH_0
	if(FUZZY-&gt;fECH == 0)
	{
		FUZZY-&gt;fECH = 1;	
	}
	#endif
	#ifdef FUZZY_ulN_0
	if(FUZZY-&gt;ulN == 0)
	{
		FUZZY-&gt;ulN = 1;	
	}
	#endif
    cCtrlMod = FUZZY-&gt;cCtrlMod;
    ulTs = FUZZY-&gt;ulTs / (fp32)1000; 
	fEH = FUZZY-&gt;fEH;fECH = FUZZY-&gt;fECH;fUH = FUZZY-&gt;fUH;
    fMV = FUZZY-&gt;fMV;
	fEi_1 = FUZZY-&gt;fEi; fEi = FUZZY-&gt;fSV - fPV; 
	// 范围控制
    fEi = fEi &gt; fEH ? fEH : fEi;
    fEi = fEi &lt; (-fEH) ? (-fEH) : fEi;
    
	#ifdef FUZZY_cCtrlMod_0      
    if(cCtrlMod == 0)       
    {// 自动
		uint32 ulL,ulM,ulN;
		fp32 scaleE,scaleEC,scaleU;  // 比例因子
		fp32 *fuzzyControlList;
		int32 ulFuzzyE,ulFuzzyEC; // 偏差与偏差变化率模糊化结果
		fp32 fDeltaE;  // 偏差变化
		fp32 fuzzyValue;  // 模糊化结果

        fuzzyControlList = FUZZY-&gt;fuzzyControlList;        
        
		fDeltaE = fEi-fEi_1; // 偏差变化率
	    fDeltaE = fDeltaE &gt; fECH ? fECH : fDeltaE;
	    fDeltaE = fDeltaE &lt; (-fECH) ? (-fECH) : fDeltaE;             
        ulL = FUZZY-&gt;ulL;ulM = FUZZY-&gt;ulM;ulN = FUZZY-&gt;ulN;
        scaleE = ulL/fEH;scaleEC = ulM/fECH;scaleU = fUH/ulN;
        // 模糊化
        ulFuzzyE = ClearToFuzzy(fEi,scaleE,ulL);
        ulFuzzyEC = ClearToFuzzy(fDeltaE,scaleEC,ulM);
        // 取值 e为横坐标,ec为纵坐标
        fuzzyValue = fuzzyControlList[(ulFuzzyEC+ulM)*(2*ulL+1)+(ulFuzzyE+ulL)];
        // 清晰化
        fDeltaMV = FuzzyToClear(fuzzyValue,scaleU,fUH);
        fMV = FUZZY-&gt;fMV + fDeltaMV;          
    }
	#endif
	#ifdef FUZZY_cCtrlMod_1
	if(cCtrlMod != 0)
	{
		fMV = FUZZY-&gt;fMV;
	}
	#endif
	fMV = fMV &gt; FUZZY-&gt;fUH ? FUZZY-&gt;fUH : fMV;
    fMV = fMV &lt; 0 ? 0 : fMV;  // 模拟控制器输出最小值为0

    FUZZY-&gt;fMV = fMV;
    FUZZY-&gt;fEi = fEi; 
	Push(&amp;paramStack,fMV);
	return 1;
}</Property>
        <Property name="Description">指令名：ＦＵＺＺＹ

模糊是在一定程度上模仿了人的控制，它不需要准确的控制对
象模型，是一种智能控制的方法，它即可用于简单的控制对象
也可以用于复杂的过程。</Property>
        <Property name="OptimizeInfo">
        </Property>
      </OtherInfo>
    </FDToolBoxItem>
  </Category>
  <Category DisplayName="特殊代码">
    <CodeProperty name="头文件" varname="h_code">#include "configuration_control.h"
#include "CassSysVar.h"

stack paramStack;

// 常量输入
void CONControl(fp32 a)
{
    Push(&amp;paramStack,a);    
}

// 输入: Bingo
void LDControl(fp32 *a)
{
    Push(&amp;paramStack,*a);
}

// 输出
void STControl(fp32 *a)
{
    Pop(&amp;paramStack,a);
}</CodeProperty>
    <CodeProperty name="弹出指令" varname="POP">// 数据弹出控制
uint8 POPControl(void)
{
	paramStack.top--;
	return 1;
}</CodeProperty>
  </Category>
</configuration>